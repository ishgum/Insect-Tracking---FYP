*** File /home/ubuntu/fyp/Project2_NT/Project2/Thresholding.h:
                
                #ifndef THRESHOLDING
                #define THRESHOLDING
                
                #include <opencv2/core/core.hpp>
                #include <opencv2/imgproc/imgproc.hpp>
                
                
                using namespace cv;
                using namespace std;
                
                
         873 -> class myHist {
                	vector<double> histogram;
                	vector<int> peakLocs;
                	vector<int> minLocs;
                	int absMaxLoc;
                	bool checkThreshold(int);
                	int findNextMin(int);
                public:
                	int threshold;
                
                	myHist();
                	myHist(Mat);
                	void findPeaksandMins(int);
                	void findThresholdByArea(int);
                };
                
                
                int findThreshold(Mat inputImage);
                
                #endif

Top 10 Lines:

     Line      Count

       13        873

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      873   Total number of line executions
   873.00   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_numeric.h:
                // Numeric functions implementation -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_numeric.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{numeric}
                 */
                
                #ifndef _STL_NUMERIC_H
                #define _STL_NUMERIC_H 1
                
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                #include <bits/move.h> // For _GLIBCXX_MOVE
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @brief  Create a range of sequentially increasing values.
                   *
                   *  For each element in the range @p [first,last) assigns @p value and
                   *  increments @p value as if by @p ++value.
                   *
                   *  @param  __first  Start of range.
                   *  @param  __last  End of range.
                   *  @param  __value  Starting value.
                   *  @return  Nothing.
                   */
                  template<typename _ForwardIterator, typename _Tp>
                    void
                    iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	{
                	  *__first = __value;
                	  ++__value;
                	}
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief  Accumulate values in a range.
                   *
                   *  Accumulates the values in the range [first,last) using operator+().  The
                   *  initial value is @a init.  The values are processed in order.
                   *
                   *  @param  __first  Start of range.
                   *  @param  __last  End of range.
                   *  @param  __init  Starting value to add other values to.
                   *  @return  The final sum.
                   */
                  template<typename _InputIterator, typename _Tp>
                    inline _Tp
         844 ->     accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	__init = __init + *__first;
                      return __init;
                    }
                
                  /**
                   *  @brief  Accumulate values in a range with operation.
                   *
                   *  Accumulates the values in the range [first,last) using the function
                   *  object @p __binary_op.  The initial value is @p __init.  The values are
                   *  processed in order.
                   *
                   *  @param  __first  Start of range.
                   *  @param  __last  End of range.
                   *  @param  __init  Starting value to add other values to.
                   *  @param  __binary_op  Function object to accumulate with.
                   *  @return  The final sum.
                   */
                  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
                    inline _Tp
                    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
                	       _BinaryOperation __binary_op)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	__init = __binary_op(__init, *__first);
                      return __init;
                    }
                
                  /**
                   *  @brief  Compute inner product of two ranges.
                   *
                   *  Starting with an initial value of @p __init, multiplies successive
                   *  elements from the two ranges and adds each product into the accumulated
                   *  value using operator+().  The values in the ranges are processed in
                   *  order.
                   *
                   *  @param  __first1  Start of range 1.
                   *  @param  __last1  End of range 1.
                   *  @param  __first2  Start of range 2.
                   *  @param  __init  Starting value to add other values to.
                   *  @return  The final inner product.
                   */
                  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
                    inline _Tp
                    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
                		  _InputIterator2 __first2, _Tp __init)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, ++__first2)
                	__init = __init + (*__first1 * *__first2);
                      return __init;
                    }
                
                  /**
                   *  @brief  Compute inner product of two ranges.
                   *
                   *  Starting with an initial value of @p __init, applies @p __binary_op2 to
                   *  successive elements from the two ranges and accumulates each result into
                   *  the accumulated value using @p __binary_op1.  The values in the ranges are
                   *  processed in order.
                   *
                   *  @param  __first1  Start of range 1.
                   *  @param  __last1  End of range 1.
                   *  @param  __first2  Start of range 2.
                   *  @param  __init  Starting value to add other values to.
                   *  @param  __binary_op1  Function object to accumulate with.
                   *  @param  __binary_op2  Function object to apply to pairs of input values.
                   *  @return  The final inner product.
                   */
                  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
                	   typename _BinaryOperation1, typename _BinaryOperation2>
                    inline _Tp
                    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
                		  _InputIterator2 __first2, _Tp __init,
                		  _BinaryOperation1 __binary_op1,
                		  _BinaryOperation2 __binary_op2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, ++__first2)
                	__init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
                      return __init;
                    }
                
                  /**
                   *  @brief  Return list of partial sums
                   *
                   *  Accumulates the values in the range [first,last) using the @c + operator.
                   *  As each successive input value is added into the total, that partial sum
                   *  is written to @p __result.  Therefore, the first value in @p __result is
                   *  the first value of the input, the second value in @p __result is the sum
                   *  of the first and second input values, and so on.
                   *
                   *  @param  __first  Start of input range.
                   *  @param  __last  End of input range.
                   *  @param  __result  Output sum.
                   *  @return  Iterator pointing just beyond the values written to __result.
                   */
                  template<typename _InputIterator, typename _OutputIterator>
                    _OutputIterator
                    partial_sum(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                				                         _ValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      _ValueType __value = *__first;
                      *__result = __value;
                      while (++__first != __last)
                	{
                	  __value = __value + *__first;
                	  *++__result = __value;
                	}
                      return ++__result;
                    }
                
                  /**
                   *  @brief  Return list of partial sums
                   *
                   *  Accumulates the values in the range [first,last) using @p __binary_op.
                   *  As each successive input value is added into the total, that partial sum
                   *  is written to @p __result.  Therefore, the first value in @p __result is
                   *  the first value of the input, the second value in @p __result is the sum
                   *  of the first and second input values, and so on.
                   *
                   *  @param  __first  Start of input range.
                   *  @param  __last  End of input range.
                   *  @param  __result  Output sum.
                   *  @param  __binary_op  Function object.
                   *  @return  Iterator pointing just beyond the values written to __result.
                   */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryOperation>
                    _OutputIterator
                    partial_sum(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result, _BinaryOperation __binary_op)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                				                         _ValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      _ValueType __value = *__first;
                      *__result = __value;
                      while (++__first != __last)
                	{
                	  __value = __binary_op(__value, *__first);
                	  *++__result = __value;
                	}
                      return ++__result;
                    }
                
                  /**
                   *  @brief  Return differences between adjacent values.
                   *
                   *  Computes the difference between adjacent values in the range
                   *  [first,last) using operator-() and writes the result to @p __result.
                   *
                   *  @param  __first  Start of input range.
                   *  @param  __last  End of input range.
                   *  @param  __result  Output sums.
                   *  @return  Iterator pointing just beyond the values written to result.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 539. partial_sum and adjacent_difference should mention requirements
                   */
                  template<typename _InputIterator, typename _OutputIterator>
                    _OutputIterator
                    adjacent_difference(_InputIterator __first,
                			_InputIterator __last, _OutputIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                				                         _ValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      _ValueType __value = *__first;
                      *__result = __value;
                      while (++__first != __last)
                	{
                	  _ValueType __tmp = *__first;
                	  *++__result = __tmp - __value;
                	  __value = _GLIBCXX_MOVE(__tmp);
                	}
                      return ++__result;
                    }
                
                  /**
                   *  @brief  Return differences between adjacent values.
                   *
                   *  Computes the difference between adjacent values in the range
                   *  [__first,__last) using the function object @p __binary_op and writes the
                   *  result to @p __result.
                   *
                   *  @param  __first  Start of input range.
                   *  @param  __last  End of input range.
                   *  @param  __result  Output sum.
                   *  @param  __binary_op Function object.
                   *  @return  Iterator pointing just beyond the values written to result.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 539. partial_sum and adjacent_difference should mention requirements
                   */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryOperation>
                    _OutputIterator
                    adjacent_difference(_InputIterator __first, _InputIterator __last,
                			_OutputIterator __result, _BinaryOperation __binary_op)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                				                         _ValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      _ValueType __value = *__first;
                      *__result = __value;
                      while (++__first != __last)
                	{
                	  _ValueType __tmp = *__first;
                	  *++__result = __binary_op(__tmp, __value);
                	  __value = _GLIBCXX_MOVE(__tmp);
                	}
                      return ++__result;
                    }
                
                _GLIBCXX_END_NAMESPACE_ALGO
                } // namespace std
                
                #endif /* _STL_NUMERIC_H */


Top 10 Lines:

     Line      Count

      120        844

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      844   Total number of line executions
   844.00   Average executions per line


*** File /usr/include/c++/4.8/bits/move.h:
                // Move, forward and identity for C++0x + swap -*- C++ -*-
                
                // Copyright (C) 2007-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/move.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _MOVE_H
                #define _MOVE_H 1
                
                #include <bits/c++config.h>
                #include <bits/concept_check.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Used, in C++03 mode too, by allocators, etc.
                  /**
                   *  @brief Same as C++11 std::addressof
                   *  @ingroup utilities
                   */
                  template<typename _Tp>
                    inline _Tp*
        7137 ->     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
                    {
                      return reinterpret_cast<_Tp*>
                	(&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L
                #include <type_traits> // Brings in std::declval too.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief  Forward an lvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
                    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
                    { return static_cast<_Tp&&>(__t); }
                
                  /**
                   *  @brief  Forward an rvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
                    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
                    {
                      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
                		    " substituting _Tp is an lvalue reference type");
                      return static_cast<_Tp&&>(__t);
                    }
                
                  /**
                   *  @brief  Convert a value to an rvalue.
                   *  @param  __t  A thing of arbitrary type.
                   *  @return The parameter cast to an rvalue-reference to allow moving it.
                  */
                  template<typename _Tp>
                    constexpr typename std::remove_reference<_Tp>::type&&
                    move(_Tp&& __t) noexcept
                    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
                
                
                  template<typename _Tp>
                    struct __move_if_noexcept_cond
                    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                                    is_copy_constructible<_Tp>>::type { };
                
                  /**
                   *  @brief  Conditionally convert a value to an rvalue.
                   *  @param  __x  A thing of arbitrary type.
                   *  @return The parameter, possibly cast to an rvalue-reference.
                   *
                   *  Same as std::move unless the type's move constructor could throw and the
                   *  type is copyable, in which case an lvalue-reference is returned instead.
                   */
                  template<typename _Tp>
                    inline constexpr typename
                    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
                    move_if_noexcept(_Tp& __x) noexcept
                    { return std::move(__x); }
                
                  // declval, from type_traits.
                
                  /**
                   *  @brief Returns the actual address of the object or function
                   *         referenced by r, even in the presence of an overloaded
                   *         operator&.
                   *  @param  __r  Reference to an object or function.
                   *  @return   The actual address.
                  */
                  template<typename _Tp>
                    inline _Tp*
                    addressof(_Tp& __r) noexcept
                    { return std::__addressof(__r); }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #define _GLIBCXX_MOVE(__val) std::move(__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
                #else
                #define _GLIBCXX_MOVE(__val) (__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) (__val)
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief Swaps two values.
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   Nothing.
                  */
                  template<typename _Tp>
                    inline void
                    swap(_Tp& __a, _Tp& __b)
                #if __cplusplus >= 201103L
                    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
                	            is_nothrow_move_assignable<_Tp>>::value)
                #endif
                    {
                      // concept requirements
                      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
                
                      _Tp __tmp = _GLIBCXX_MOVE(__a);
                      __a = _GLIBCXX_MOVE(__b);
                      __b = _GLIBCXX_MOVE(__tmp);
                    }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 809. std::swap should be overloaded for array types.
                  /// Swap the contents of two arrays.
                  template<typename _Tp, size_t _Nm>
                    inline void
                    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                #if __cplusplus >= 201103L
                    noexcept(noexcept(swap(*__a, *__b)))
                #endif
                    {
                      for (size_t __n = 0; __n < _Nm; ++__n)
                	swap(__a[__n], __b[__n]);
                    }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _MOVE_H */


Top 10 Lines:

     Line      Count

       47       7137

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     7137   Total number of line executions
  7137.00   Average executions per line


*** File /home/ubuntu/fyp/Project2_NT/Project2/Fps.cpp:
                #include "Fps.h"
                
                // Functions for system clock so we can determine runtine FPS
                // copied from http://stackoverflow.com/questions/17432502
                //  Windows
                #ifdef _WIN32
                double Fps::get_wall_time(void){
                	LARGE_INTEGER time, freq;
                	if (!QueryPerformanceFrequency(&freq)){
                		//  Handle error
                		return 0;
                	}
                	if (!QueryPerformanceCounter(&time)){
                		//  Handle error
                		return 0;
                	}
                	return (double)time.QuadPart / freq.QuadPart;
                }
                double Fps::get_cpu_time(void){
                	FILETIME a, b, c, d; // see https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284(v=vs.85).aspx for deets
                	if (GetProcessTimes(GetCurrentProcess(), &a, &b, &c, &d) != 0){
                		//  Returns total user time.
                		//  Can be tweaked to include kernel times as well.
                		return
                			//(double)(d.dwLowDateTime)*0.0000001; // return time in s
                			(double)(d.dwLowDateTime |
                			((unsigned long long)d.dwHighDateTime << 32)) * 0.0000001;
                	}
                	else{
                		//  Handle error
                		return 0;
                	}
                }
                //  Posix/Linux
                #else
        1059 -> double Fps::get_wall_time(void){
                	struct timeval time;
                	if (gettimeofday(&time, NULL)){
                		//  Handle error
                		return 0;
                	}
                	return (double)time.tv_sec + (double)time.tv_usec * .000001;
                }
           1 -> double Fps::get_cpu_time(void){
                	return (double)clock() / CLOCKS_PER_SEC;
                }
                #endif
                
           1 -> Fps::Fps(int wait_period, fps_mode_t mode) {
                	mode_ = mode;
                	frame_num = 1;
                	wall0 = get_wall_time();
                	cpu0 = get_cpu_time();
                	num_frames_proc = 0;
                	fps_wall = 0, fps_cpu = 0;
                	cpu_running_total = 0;
                	wait_period_ = wait_period;
                	wall1 = wall0;
                	cpu1 = cpu0;	
                }
                
         873 -> void Fps::checkFPS(void){
                	frame_num++;
                	num_frames_proc++;
                
                	switch (mode_){
                	case (WALL):
                		wall1 = get_wall_time();
                		if (wall1 >= (wall0 + 1)){ // check if >1s has elapsed
                			fps_wall = num_frames_proc / (wall1 - wall0 - num_frames_proc*0.001*wait_period_);
                			printf("\tWALL:\t%f\t", fps_wall);
                			num_frames_proc = 0;
                			wall0 = get_wall_time();
                		}
                		break;
                	case(CPU) :
                		cpu1 = get_cpu_time();
                		if ((cpu1 > cpu0)){ // check if reported cpu time has changed. sometimes get_cpu_time appears not to change for an unknown reason
                
                			fps_cpu = num_frames_proc / (cpu1 - cpu0);// - num_frames_proc*0.001*wait_period);
                			printf("\tFPS:  %f\t", fps_cpu);
                			num_frames_proc = 0;
                			cpu_running_total += (cpu1 - cpu0);
                			cpu0 = get_cpu_time();
                		}
                		break;
                	case(BOTH) :
                		wall1 = get_wall_time();
                		cpu1 = get_cpu_time();
                		if (wall1 >= (wall0 + 1) && (cpu1 > cpu0)){ //Check if >1s has elapsed And,
                			// check if reported cpu time has changed. sometimes get_cpu_time appears not to change for an unknown reason
                
                			//fps_wall_displayed = num_frames_proc / (wall1 - wall0); //rate displayed
                			fps_wall = num_frames_proc / (wall1 - wall0 - num_frames_proc*0.001*wait_period_);
                			fps_cpu = num_frames_proc / (cpu1 - cpu0);// - num_frames_proc*0.001*wait_period);
                			printf("\tFPS:  %f\tWALL:\t%f\t", fps_cpu, fps_wall);
                			num_frames_proc = 0;
                			cpu_running_total += (cpu1 - cpu0);
                			wall0 = get_wall_time();
                			cpu0 = get_cpu_time();
                		}
                		break;
                	}
                
                }
                
         873 -> void Fps::displayFPS(Mat src, Rect ROI){
                	// Display FPS
                	Mat src_w_text = src.clone();	// so we don't mess up original source
                	rectangle(src_w_text, ROI, Scalar(255, 255, 255), 2, 8, 0);
                	//resize(src_w_text, src_w_text, Size(), 0.3, 0.3);
                	// add fps text to "1. Frame" window
                	// Displayed FPS accounts for the delay we add in waitkey, far, far below.
                
                	Point fps_wall_text_loc(10, 30);
                	Point fps_cpu_text_loc(10, 60);
                	Point frame_num_text_loc(10, 90);
                	char fps_wall_c[30];  // Needs to be large enough to avoid corrupting stack
                	char fps_cpu_c[30];   // Needs to be large enough to avoid corrupting stack
                	char frame_num_c[30]; // Needs to be large enough to avoid corrupting stack
                
                
                	if (mode_ == WALL || mode_ == BOTH){
                		//wall time
                		sprintf(fps_wall_c, "wall FPS %4.2f", fps_wall);
                		putText(src_w_text, fps_wall_c, fps_wall_text_loc,
                			FONT_HERSHEY_SIMPLEX, 0.6, { 255, 255, 255 }, 1.5);
                	}
                	if (mode_ == CPU || mode_ == BOTH){
                		//cpu time
                		sprintf(fps_cpu_c, "cpu FPS %4.2f", fps_cpu);
                		putText(src_w_text, fps_cpu_c, fps_cpu_text_loc,
                			FONT_HERSHEY_SIMPLEX, 0.6, { 255, 255, 255 }, 1.5);
                	}
                
                	//Frame Number
                	sprintf(frame_num_c, "Frame #: %5i", frame_num);
                	putText(src_w_text, frame_num_c, frame_num_text_loc, FONT_HERSHEY_SIMPLEX, 0.6, { 255, 255, 255 }, 1.5);
                	//imshow("FPS", src_w_text);
                
                	//printf("\nFrame: %i\tCPU total: %f\tCPU FPS: %f", frame_num, cpu_running_total, fps_cpu);
                
                	//#ifdef RECORD_SOURCE_W_BOX
                	//		// write output video w/ text
                	//		outputVideo.write(src_w_text);
                	//#endif
                }


Top 10 Lines:

     Line      Count

       36       1059
       62        873
      107        873
       44          1
       49          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

     2807   Total number of line executions
   561.40   Average executions per line


*** File /home/ubuntu/fyp/Project2_NT/Project2/Insect.cpp:
                #include "Insect.h"
                
                #define HEIGHT_FILTER_SIZE 10
                #define HEIGHT_BRACKET 20
                
           1 -> Insect::Insect(Mat* src) {
                	found = false;
                	heightMA = vector<int>(HEIGHT_FILTER_SIZE, 0);
                	position = Point(0, 0);
                	prevPosition = position;
                	speed = 0.0;
                	ROI = Rect(0, 0, src->cols, src->rows);
                	frameCentre = Point(src->cols / 2, src->rows / 2);
                }
                
                
         844 -> void Insect::updateHeight(int brightness) {
                	heightMA.push_back(brightness);
                	heightMA.erase(heightMA.begin());
                
                	heightBracket = std::accumulate(heightMA.begin(), heightMA.end(), 0) / (HEIGHT_FILTER_SIZE * HEIGHT_BRACKET);
                }
                
         775 -> void Insect::updatePosition(Point2f centre) {
                	position = Point2f(centre.x + ROI.x, centre.y + ROI.y);
                	
                	velocity = position - prevPosition;
                	speed = norm(velocity);
                	direction = atan2f(velocity.y, velocity.x) * 180 / CV_PI;
                
                	relPosition = position - frameCentre;
                	relNorm = norm(relPosition);
                	relAngle = atan2f(relPosition.y, relPosition.x) *180 / CV_PI;
                
                	humanReadableOutput();
                	prevPosition = position;
                }
                
                
         873 -> void Insect::updateROI(Mat* src) {
                	if (found) {
                		// Updates the size and location of the region of interest
                		int roiSize = ROI_SIZE * src->rows;
                
                		if (position.x > (roiSize / 2)) {
                			ROI.x = int(position.x) - roiSize / 2;
                		}
                		if (position.y > (roiSize / 2)) {
                			ROI.y = int(position.y) - roiSize / 2;
                		}
                		if (position.x + roiSize / 2 > src->cols) {
                			ROI.x = src->cols - roiSize;
                		}
                		if (position.y + roiSize / 2 > src->rows) {
                			ROI.y = src->rows - roiSize;
                		}
                		ROI.width = roiSize;
                		ROI.height = roiSize;
                	}
                	else {
                		ROI = Rect(0, HEIGHT_OFFSET, src->cols, src->rows - HEIGHT_OFFSET); //Reset ROI
                	}
                }
                
         775 -> void Insect::humanReadableOutput(void) {
                	printf("\n");
                	printf("Distance: %.0f	", relNorm / 40);
                	if (relAngle > 22.5 &&  relAngle < 157.5) {
                		printf("Down ");
                	}
                	if (relAngle < -22.5 &&  relAngle > -157.5) {
                		printf("Up ");
                	}
                	if (relAngle < -112.5 ||  relAngle > 112.5) {
                		printf("Left ");
                	}
                	if (relAngle > -67.5 &&  relAngle < 67.5) {
                		printf("Right ");
                	}
                }

Top 10 Lines:

     Line      Count

       40        873
       17        844
       24        775
       65        775
        6          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

     3268   Total number of line executions
   653.60   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_construct.h:
                // nonstandard construct and destroy functions -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_construct.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_CONSTRUCT_H
                #define _STL_CONSTRUCT_H 1
                
                #include <new>
                #include <bits/move.h>
                #include <ext/alloc_traits.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * Constructs an object in existing memory by invoking an allocated
                   * object's constructor with an initializer.
                   */
                #if __cplusplus >= 201103L
                  template<typename _T1, typename... _Args>
                    inline void
                    _Construct(_T1* __p, _Args&&... __args)
                    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
                #else
                  template<typename _T1, typename _T2>
                    inline void
        1316 ->     _Construct(_T1* __p, const _T2& __value)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_]allocator::construct
                      ::new(static_cast<void*>(__p)) _T1(__value);
                    }
                #endif
                
                  /**
                   * Destroy the object pointed to by a pointer type.
                   */
                  template<typename _Tp>
                    inline void
        5821 ->     _Destroy(_Tp* __pointer)
                    { __pointer->~_Tp(); }
                
                  template<bool>
                    struct _Destroy_aux
                    {
                      template<typename _ForwardIterator>
                        static void
         844 ->         __destroy(_ForwardIterator __first, _ForwardIterator __last)
                	{
                	  for (; __first != __last; ++__first)
                	    std::_Destroy(std::__addressof(*__first));
                	}
                    };
                
                  template<>
                    struct _Destroy_aux<true>
                    {
                      template<typename _ForwardIterator>
                        static void
       26178 ->         __destroy(_ForwardIterator, _ForwardIterator) { }
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator>
                    inline void
       27022 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy(__first, __last);
                    }
                
                  /**
                   * Destroy a range of objects using the supplied allocator.  For
                   * nondefault allocators we do not optimize away invocation of 
                   * destroy() even if _Tp has a trivial destructor.
                   */
                
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     _Allocator& __alloc)
                    {
                      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                      for (; __first != __last; ++__first)
                	__traits::destroy(__alloc, std::__addressof(*__first));
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
       27022 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     allocator<_Tp>&)
                    {
                      _Destroy(__first, __last);
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_CONSTRUCT_H */
                


Top 10 Lines:

     Line      Count

      122      27022
      148      27022
      112      26178
       92       5821
       79       1316
      100        844

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

    88203   Total number of line executions
 14700.50   Average executions per line


*** File /usr/include/c++/4.8/bits/vector.tcc:
                // Vector implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/vector.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _VECTOR_TCC
                #define _VECTOR_TCC 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    reserve(size_type __n)
                    {
                      if (__n > this->max_size())
                	__throw_length_error(__N("vector::reserve"));
                      if (this->capacity() < __n)
                	{
                	  const size_type __old_size = size();
                	  pointer __tmp = _M_allocate_and_copy(__n,
                	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
                	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
                	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			_M_get_Tp_allocator());
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __tmp;
                	  this->_M_impl._M_finish = __tmp + __old_size;
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
                      vector<_Tp, _Alloc>::
                      emplace_back(_Args&&... __args)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    insert(iterator __position, const value_type& __x)
                    {
                      const size_type __n = __position - begin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
                	  && __position == end())
                	{
                	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                #if __cplusplus >= 201103L
                	  if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	    {
                	      _Tp __x_copy = __x;
                	      _M_insert_aux(__position, std::move(__x_copy));
                	    }
                	  else
                #endif
                	    _M_insert_aux(__position, __x);
                	}
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
         844 ->     vector<_Tp, _Alloc>::
                    erase(iterator __position)
                    {
                      if (__position + 1 != end())
                	_GLIBCXX_MOVE3(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      return __position;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	{
                	  if (__last != end())
                	    _GLIBCXX_MOVE3(__last, end(), __first);
                	  _M_erase_at_end(__first.base() + (end() - __last));
                	}
                      return __first;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    vector<_Tp, _Alloc>&
         874 ->     vector<_Tp, _Alloc>::
                    operator=(const vector<_Tp, _Alloc>& __x)
                    {
                      if (&__x != this)
                	{
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      if (!_Alloc_traits::_S_always_equal()
                	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
                	        {
                		  // replacement allocator cannot free existing storage
                		  this->clear();
                		  _M_deallocate(this->_M_impl._M_start,
                				this->_M_impl._M_end_of_storage
                				- this->_M_impl._M_start);
                		  this->_M_impl._M_start = nullptr;
                		  this->_M_impl._M_finish = nullptr;
                		  this->_M_impl._M_end_of_storage = nullptr;
                		}
                	      std::__alloc_on_copy(_M_get_Tp_allocator(),
                				   __x._M_get_Tp_allocator());
                	    }
                #endif
                	  const size_type __xlen = __x.size();
                	  if (__xlen > capacity())
                	    {
                	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
                						   __x.end());
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __tmp;
                	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
                	    }
                	  else if (size() >= __xlen)
                	    {
                	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
                			    end(), _M_get_Tp_allocator());
                	    }
                	  else
                	    {
                	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
                			this->_M_impl._M_start);
                	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
                					  __x._M_impl._M_finish,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    }
                	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
                	}
                      return *this;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_assign(size_t __n, const value_type& __val)
                    {
                      if (__n > capacity())
                	{
                	  vector __tmp(__n, __val, _M_get_Tp_allocator());
                	  __tmp.swap(*this);
                	}
                      else if (__n > size())
                	{
                	  std::fill(begin(), end(), __val);
                	  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                					__n - size(), __val,
                					_M_get_Tp_allocator());
                	  this->_M_impl._M_finish += __n - size();
                	}
                      else
                        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                	pointer __cur(this->_M_impl._M_start);
                	for (; __first != __last && __cur != this->_M_impl._M_finish;
                	     ++__cur, ++__first)
                	  *__cur = *__first;
                	if (__first == __last)
                	  _M_erase_at_end(__cur);
                	else
                	  insert(end(), __first, __last);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		    std::forward_iterator_tag)
                      {
                	const size_type __len = std::distance(__first, __last);
                
                	if (__len > capacity())
                	  {
                	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    _M_deallocate(this->_M_impl._M_start,
                			  this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_start);
                	    this->_M_impl._M_start = __tmp;
                	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
                	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
                	  }
                	else if (size() >= __len)
                	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
                	else
                	  {
                	    _ForwardIterator __mid = __first;
                	    std::advance(__mid, size());
                	    std::copy(__first, __mid, this->_M_impl._M_start);
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_copy_a(__mid, __last,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	  }
                      }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      typename vector<_Tp, _Alloc>::iterator
                      vector<_Tp, _Alloc>::
                      emplace(iterator __position, _Args&&... __args)
                      {
                	const size_type __n = __position - begin();
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
                	    && __position == end())
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                	  _M_insert_aux(__position, std::forward<_Args>(__args)...);
                	return iterator(this->_M_impl._M_start + __n);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
                      vector<_Tp, _Alloc>::
                      _M_insert_aux(iterator __position, _Args&&... __args)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
       13427 ->     vector<_Tp, _Alloc>::
                    _M_insert_aux(iterator __position, const _Tp& __x)
                #endif
                    {
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	{
                	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                			           _GLIBCXX_MOVE(*(this->_M_impl._M_finish
                				                   - 1)));
                	  ++this->_M_impl._M_finish;
                #if __cplusplus < 201103L
                	  _Tp __x_copy = __x;
                #endif
                	  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                				  this->_M_impl._M_finish - 2,
                				  this->_M_impl._M_finish - 1);
                #if __cplusplus < 201103L
                	  *__position = __x_copy;
                #else
                	  *__position = _Tp(std::forward<_Args>(__args)...);
                #endif
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector::_M_insert_aux");
                	  const size_type __elems_before = __position - begin();
                	  pointer __new_start(this->_M_allocate(__len));
                	  pointer __new_finish(__new_start);
                	  __try
                	    {
                	      // The order of the three operations is dictated by the C++0x
                	      // case, where the moves could alter a new element belonging
                	      // to the existing vector.  This is an issue only for callers
                	      // taking the element by const lvalue ref (see 23.1/13).
                	      _Alloc_traits::construct(this->_M_impl,
                		                       __new_start + __elems_before,
                #if __cplusplus >= 201103L
                				       std::forward<_Args>(__args)...);
                #else
                	                               __x);
                #endif
                	      __new_finish = 0;
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(this->_M_impl._M_start, __position.base(),
                		 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__position.base(), this->_M_impl._M_finish,
                		 __new_finish, _M_get_Tp_allocator());
                	    }
                          __catch(...)
                	    {
                	      if (!__new_finish)
                		_Alloc_traits::destroy(this->_M_impl,
                		                       __new_start + __elems_before);
                	      else
                		std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	      _M_deallocate(__new_start, __len);
                	      __throw_exception_again;
                	    }
                	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			_M_get_Tp_allocator());
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __new_start;
                	  this->_M_impl._M_finish = __new_finish;
                	  this->_M_impl._M_end_of_storage = __new_start + __len;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
                      vector<_Tp, _Alloc>::
                      _M_emplace_back_aux(_Args&&... __args)
                      {
                	const size_type __len =
                	  _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
                	pointer __new_start(this->_M_allocate(__len));
                	pointer __new_finish(__new_start);
                	__try
                	  {
                	    _Alloc_traits::construct(this->_M_impl, __new_start + size(),
                				     std::forward<_Args>(__args)...);
                	    __new_finish = 0;
                
                	    __new_finish
                	      = std::__uninitialized_move_if_noexcept_a
                	      (this->_M_impl._M_start, this->_M_impl._M_finish,
                	       __new_start, _M_get_Tp_allocator());
                
                	    ++__new_finish;
                	  }
                	__catch(...)
                	  {
                	    if (!__new_finish)
                	      _Alloc_traits::destroy(this->_M_impl, __new_start + size());
                	    else
                	      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	    _M_deallocate(__new_start, __len);
                	    __throw_exception_again;
                	  }
                	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator());
                	_M_deallocate(this->_M_impl._M_start,
                		      this->_M_impl._M_end_of_storage
                		      - this->_M_impl._M_start);
                	this->_M_impl._M_start = __new_start;
                	this->_M_impl._M_finish = __new_finish;
                	this->_M_impl._M_end_of_storage = __new_start + __len;
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                	      value_type __x_copy = __x;
                	      const size_type __elems_after = end() - __position;
                	      pointer __old_finish(this->_M_impl._M_finish);
                	      if (__elems_after > __n)
                		{
                		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n;
                		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					  __old_finish - __n, __old_finish);
                		  std::fill(__position.base(), __position.base() + __n,
                			    __x_copy);
                		}
                	      else
                		{
                		  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                						__n - __elems_after,
                						__x_copy,
                						_M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n - __elems_after;
                		  std::__uninitialized_move_a(__position.base(), __old_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __elems_after;
                		  std::fill(__position.base(), __old_finish, __x_copy);
                		}
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_fill_insert");
                	      const size_type __elems_before = __position - begin();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  // See _M_insert_aux above.
                		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
                						__n, __x,
                						_M_get_Tp_allocator());
                		  __new_finish = 0;
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, __position.base(),
                		     __new_start, _M_get_Tp_allocator());
                
                		  __new_finish += __n;
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (__position.base(), this->_M_impl._M_finish,
                		     __new_finish, _M_get_Tp_allocator());
                		}
                	      __catch(...)
                		{
                		  if (!__new_finish)
                		    std::_Destroy(__new_start + __elems_before,
                				  __new_start + __elems_before + __n,
                				  _M_get_Tp_allocator());
                		  else
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_default_append(size_type __n)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                	      std::__uninitialized_default_n_a(this->_M_impl._M_finish,
                					       __n, _M_get_Tp_allocator());
                	      this->_M_impl._M_finish += __n;
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_default_append");
                	      const size_type __old_size = this->size();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, this->_M_impl._M_finish,
                		     __new_start, _M_get_Tp_allocator());
                		  std::__uninitialized_default_n_a(__new_finish, __n,
                						   _M_get_Tp_allocator());
                		  __new_finish += __n;
                		}
                	      __catch(...)
                		{
                		  std::_Destroy(__new_start, __new_finish,
                				_M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    bool
                    vector<_Tp, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() == size())
                	return false;
                      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
                    }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __pos, _InputIterator __first,
                		      _InputIterator __last, std::input_iterator_tag)
                      {
                	for (; __first != __last; ++__first)
                	  {
                	    __pos = insert(__pos, *__first);
                	    ++__pos;
                	  }
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __position, _ForwardIterator __first,
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    const size_type __n = std::distance(__first, __last);
                	    if (size_type(this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_finish) >= __n)
                	      {
                		const size_type __elems_after = end() - __position;
                		pointer __old_finish(this->_M_impl._M_finish);
                		if (__elems_after > __n)
                		  {
                		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                						this->_M_impl._M_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n;
                		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					    __old_finish - __n, __old_finish);
                		    std::copy(__first, __last, __position);
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, __elems_after);
                		    std::__uninitialized_copy_a(__mid, __last,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n - __elems_after;
                		    std::__uninitialized_move_a(__position.base(),
                						__old_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __elems_after;
                		    std::copy(__first, __mid, __position);
                		  }
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector::_M_range_insert");
                		pointer __new_start(this->_M_allocate(__len));
                		pointer __new_finish(__new_start);
                		__try
                		  {
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (this->_M_impl._M_start, __position.base(),
                		       __new_start, _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_copy_a(__first, __last,
                						    __new_finish,
                						    _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (__position.base(), this->_M_impl._M_finish,
                		       __new_finish, _M_get_Tp_allocator());
                		  }
                		__catch(...)
                		  {
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		    _M_deallocate(__new_start, __len);
                		    __throw_exception_again;
                		  }
                		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      _M_get_Tp_allocator());
                		_M_deallocate(this->_M_impl._M_start,
                			      this->_M_impl._M_end_of_storage
                			      - this->_M_impl._M_start);
                		this->_M_impl._M_start = __new_start;
                		this->_M_impl._M_finish = __new_finish;
                		this->_M_impl._M_end_of_storage = __new_start + __len;
                	      }
                	  }
                      }
                
                
                  // vector<bool>
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_reallocate(size_type __n)
                    {
                      _Bit_type* __q = this->_M_allocate(__n);
                      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
                						iterator(__q, 0));
                      this->_M_deallocate();
                      this->_M_impl._M_start = iterator(__q, 0);
                      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                    }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, bool __x)
                    {
                      if (__n == 0)
                	return;
                      if (capacity() - size() >= __n)
                	{
                	  std::copy_backward(__position, end(),
                			     this->_M_impl._M_finish + difference_type(__n));
                	  std::fill(__position, __position + difference_type(__n), __x);
                	  this->_M_impl._M_finish += difference_type(__n);
                	}
                      else
                	{
                	  const size_type __len = 
                	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
                	  _Bit_type * __q = this->_M_allocate(__len);
                	  iterator __i = _M_copy_aligned(begin(), __position,
                					 iterator(__q, 0));
                	  std::fill(__i, __i + difference_type(__n), __x);
                	  this->_M_impl._M_finish = std::copy(__position, end(),
                					      __i + difference_type(__n));
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = iterator(__q, 0);
                	}
                    }
                
                  template<typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<bool, _Alloc>::
                      _M_insert_range(iterator __position, _ForwardIterator __first, 
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    size_type __n = std::distance(__first, __last);
                	    if (capacity() - size() >= __n)
                	      {
                		std::copy_backward(__position, end(),
                				   this->_M_impl._M_finish
                				   + difference_type(__n));
                		std::copy(__first, __last, __position);
                		this->_M_impl._M_finish += difference_type(__n);
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector<bool>::_M_insert_range");
                		_Bit_type * __q = this->_M_allocate(__len);
                		iterator __i = _M_copy_aligned(begin(), __position,
                					       iterator(__q, 0));
                		__i = std::copy(__first, __last, __i);
                		this->_M_impl._M_finish = std::copy(__position, end(), __i);
                		this->_M_deallocate();
                		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                		this->_M_impl._M_start = iterator(__q, 0);
                	      }
                	  }
                      }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_insert_aux(iterator __position, bool __x)
                    {
                      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
                	{
                	  std::copy_backward(__position, this->_M_impl._M_finish, 
                			     this->_M_impl._M_finish + 1);
                	  *__position = __x;
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
                	  _Bit_type * __q = this->_M_allocate(__len);
                	  iterator __i = _M_copy_aligned(begin(), __position,
                					 iterator(__q, 0));
                	  *__i++ = __x;
                	  this->_M_impl._M_finish = std::copy(__position, end(), __i);
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = iterator(__q, 0);
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Alloc>
                    bool
                    vector<bool, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() - size() < int(_S_word_bit))
                	return false;
                      __try
                	{
                	  _M_reallocate(size());
                	  return true;
                	}
                      __catch(...)
                	{ return false; }
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Alloc>
                    size_t
                    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
                    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
                    {
                      size_t __hash = 0;
                      using _GLIBCXX_STD_C::_S_word_bit;
                      using _GLIBCXX_STD_C::_Bit_type;
                
                      const size_t __words = __b.size() / _S_word_bit;
                      if (__words)
                	{
                	  const size_t __clength = __words * sizeof(_Bit_type);
                	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
                	}
                
                      const size_t __extrabits = __b.size() % _S_word_bit;
                      if (__extrabits)
                	{
                	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
                	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
                
                	  const size_t __clength
                	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
                	  if (__words)
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
                	  else
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
                	}
                
                      return __hash;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif /* _VECTOR_TCC */


Top 10 Lines:

     Line      Count

      318      13427
      160        874
      134        844

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

    15145   Total number of line executions
  5048.33   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_iterator.h:
                // Iterators -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file implements reverse_iterator, back_insert_iterator,
                 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
                 *  supporting functions and overloaded operators.
                 */
                
                #ifndef _STL_ITERATOR_H
                #define _STL_ITERATOR_H 1
                
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <bits/move.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                  // 24.4.1 Reverse iterators
                  /**
                   *  Bidirectional and random access iterators have corresponding reverse
                   *  %iterator adaptors that iterate through the data structure in the
                   *  opposite direction.  They have the same signatures as the corresponding
                   *  iterators.  The fundamental relation between a reverse %iterator and its
                   *  corresponding %iterator @c i is established by the identity:
                   *  @code
                   *      &*(reverse_iterator(i)) == &*(i - 1)
                   *  @endcode
                   *
                   *  <em>This mapping is dictated by the fact that while there is always a
                   *  pointer past the end of an array, there might not be a valid pointer
                   *  before the beginning of an array.</em> [24.4.1]/1,2
                   *
                   *  Reverse iterators can be tricky and surprising at first.  Their
                   *  semantics make sense, however, and the trickiness is a side effect of
                   *  the requirement that the iterators must be safe.
                  */
                  template<typename _Iterator>
                    class reverse_iterator
                    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                		      typename iterator_traits<_Iterator>::value_type,
                		      typename iterator_traits<_Iterator>::difference_type,
                		      typename iterator_traits<_Iterator>::pointer,
                                      typename iterator_traits<_Iterator>::reference>
                    {
                    protected:
                      _Iterator current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      typedef typename __traits_type::pointer		pointer;
                      typedef typename __traits_type::reference		reference;
                
                      /**
                       *  The default constructor value-initializes member @p current.
                       *  If it is a pointer, that means it is zero-initialized.
                      */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 235 No specification of default ctor for reverse_iterator
                      reverse_iterator() : current() { }
                
                      /**
                       *  This %iterator will move in the opposite direction that @p x does.
                      */
                      explicit
                      reverse_iterator(iterator_type __x) : current(__x) { }
                
                      /**
                       *  The copy constructor is normal.
                      */
                      reverse_iterator(const reverse_iterator& __x)
                      : current(__x.current) { }
                
                      /**
                       *  A %reverse_iterator across other types can be copied if the
                       *  underlying %iterator can be converted to the type of @c current.
                      */
                      template<typename _Iter>
                        reverse_iterator(const reverse_iterator<_Iter>& __x)
                	: current(__x.base()) { }
                
                      /**
                       *  @return  @c current, the %iterator used for underlying work.
                      */
                      iterator_type
                      base() const
                      { return current; }
                
                      /**
                       *  @return  A reference to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                       *
                       *  @warning This implementation requires that for an iterator of the
                       *           underlying iterator type, @c x, a reference obtained by
                       *           @c *x remains valid after @c x has been modified or
                       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
                      */
                      reference
                      operator*() const
                      {
                	_Iterator __tmp = current;
                	return *--__tmp;
                      }
                
                      /**
                       *  @return  A pointer to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                      */
                      pointer
                      operator->() const
                      { return &(operator*()); }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      reverse_iterator&
                      operator++()
                      {
                	--current;
                	return *this;
                      }
                
                      /**
                       *  @return  The original value of @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      reverse_iterator
                      operator++(int)
                      {
                	reverse_iterator __tmp = *this;
                	--current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      reverse_iterator&
                      operator--()
                      {
                	++current;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator with the previous value of @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      reverse_iterator
                      operator--(int)
                      {
                	reverse_iterator __tmp = *this;
                	++current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reverse_iterator
                      operator+(difference_type __n) const
                      { return reverse_iterator(current - __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator backwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reverse_iterator&
                      operator+=(difference_type __n)
                      {
                	current -= __n;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reverse_iterator
                      operator-(difference_type __n) const
                      { return reverse_iterator(current + __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator forwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reverse_iterator&
                      operator-=(difference_type __n)
                      {
                	current += __n;
                	return *this;
                      }
                
                      /**
                       *  @return  The value at @c current - @a __n - 1
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reference
                      operator[](difference_type __n) const
                      { return *(*this + __n); }
                    };
                
                  //@{
                  /**
                   *  @param  __x  A %reverse_iterator.
                   *  @param  __y  A %reverse_iterator.
                   *  @return  A simple bool.
                   *
                   *  Reverse iterators forward many operations to their underlying base()
                   *  iterators.  Others are implemented in terms of one another.
                   *
                  */
                  template<typename _Iterator>
                    inline bool
                    operator==(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline bool
                    operator<(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _Iterator>
                    inline bool
                    operator!=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline bool
                    operator>(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline bool
                    operator<=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline bool
                    operator>=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Iterator>
                    inline typename reverse_iterator<_Iterator>::difference_type
                    operator-(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() - __x.base(); }
                
                  template<typename _Iterator>
                    inline reverse_iterator<_Iterator>
                    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
                	      const reverse_iterator<_Iterator>& __x)
                    { return reverse_iterator<_Iterator>(__x.base() - __n); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator==(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator!=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x < __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                #if __cplusplus >= 201103L
                    // DR 685.
                    inline auto
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    -> decltype(__y.base() - __x.base())
                #else
                    inline typename reverse_iterator<_IteratorL>::difference_type
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                #endif
                    { return __y.base() - __x.base(); }
                  //@}
                
                  // 24.4.2.2.1 back_insert_iterator
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator appends it to the container using
                   *  push_back.
                   *
                   *  Tip:  Using the back_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class back_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit
                      back_insert_iterator(_Container& __x) : container(&__x) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the end, if you like).  Assigning a value to the %iterator will
                       *  always append the value to the end of the container.
                      */
                #if __cplusplus < 201103L
                      back_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                #else
                      back_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                
                      back_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_back(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      back_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      back_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      back_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of back_insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating back_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline back_insert_iterator<_Container>
                    back_inserter(_Container& __x)
                    { return back_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator prepends it to the container using
                   *  push_front.
                   *
                   *  Tip:  Using the front_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class front_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the front, if you like).  Assigning a value to the %iterator will
                       *  always prepend the value to the front of the container.
                      */
                #if __cplusplus < 201103L
                      front_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                #else
                      front_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                
                      front_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_front(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      front_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      front_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      front_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of front_insert_iterator working on @p x.
                   *
                   *  This wrapper function helps in creating front_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline front_insert_iterator<_Container>
                    front_inserter(_Container& __x)
                    { return front_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator inserts it in the container at the
                   *  %iterator's position, rather than overwriting the value at that
                   *  position.
                   *
                   *  (Sequences will actually insert a @e copy of the value before the
                   *  %iterator's position.)
                   *
                   *  Tip:  Using the inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                      typename _Container::iterator iter;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /**
                       *  The only way to create this %iterator is with a container and an
                       *  initial position (a normal %iterator into the container).
                      */
                      insert_iterator(_Container& __x, typename _Container::iterator __i)
                      : container(&__x), iter(__i) {}
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator maintains its own position in the
                       *  container.  Assigning a value to the %iterator will insert the
                       *  value into the container at the place before the %iterator.
                       *
                       *  The position is maintained such that subsequent assignments will
                       *  insert values immediately after one another.  For example,
                       *  @code
                       *     // vector v contains A and Z
                       *
                       *     insert_iterator i (v, ++v.begin());
                       *     i = 1;
                       *     i = 2;
                       *     i = 3;
                       *
                       *     // vector v contains A, 1, 2, 3, and Z
                       *  @endcode
                      */
                #if __cplusplus < 201103L
                      insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                #else
                      insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                
                      insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	iter = container->insert(iter, std::move(__value));
                	++iter;
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      insert_iterator&
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param __x  A container of arbitrary type.
                   *  @return  An instance of insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container, typename _Iterator>
                    inline insert_iterator<_Container>
                    inserter(_Container& __x, _Iterator __i)
                    {
                      return insert_iterator<_Container>(__x,
                					 typename _Container::iterator(__i));
                    }
                
                  // @} group iterators
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // This iterator adapter is @a normal in the sense that it does not
                  // change the semantics of any of the operators of its iterator
                  // parameter.  Its primary purpose is to convert an iterator that is
                  // not a class, e.g. a pointer, into an iterator that is a class.
                  // The _Container parameter exists solely so that different containers
                  // using this template can instantiate different types, even if the
                  // _Iterator parameter is the same.
                  using std::iterator_traits;
                  using std::iterator;
                  template<typename _Iterator, typename _Container>
                    class __normal_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type 	difference_type;
                      typedef typename __traits_type::reference 	reference;
                      typedef typename __traits_type::pointer   	pointer;
                
                      _GLIBCXX_CONSTEXPR __normal_iterator() : _M_current(_Iterator()) { }
                
                      explicit
       41466 ->       __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
                
                      // Allow iterator to const_iterator conversion
                      template<typename _Iter>
                        __normal_iterator(const __normal_iterator<_Iter,
                			  typename __enable_if<
                      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
                		      _Container>::__type>& __i)
                        : _M_current(__i.base()) { }
                
                      // Forward iterator requirements
                      reference
        8440 ->       operator*() const
                      { return *_M_current; }
                
                      pointer
                      operator->() const
                      { return _M_current; }
                
                      __normal_iterator&
        8440 ->       operator++()
                      {
                	++_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator++(int)
                      { return __normal_iterator(_M_current++); }
                
                      // Bidirectional iterator requirements
                      __normal_iterator&
                      operator--()
                      {
                	--_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator--(int)
                      { return __normal_iterator(_M_current--); }
                
                      // Random access iterator requirements
                      reference
                      operator[](const difference_type& __n) const
                      { return _M_current[__n]; }
                
                      __normal_iterator&
                      operator+=(const difference_type& __n)
                      { _M_current += __n; return *this; }
                
                      __normal_iterator
        1688 ->       operator+(const difference_type& __n) const
                      { return __normal_iterator(_M_current + __n); }
                
                      __normal_iterator&
                      operator-=(const difference_type& __n)
                      { _M_current -= __n; return *this; }
                
                      __normal_iterator
                      operator-(const difference_type& __n) const
                      { return __normal_iterator(_M_current - __n); }
                
                      const _Iterator&
       82613 ->       base() const
                      { return _M_current; }
                    };
                
                  // Note: In what follows, the left- and right-hand-side iterators are
                  // allowed to vary in types (conceptually in cv-qualification) so that
                  // comparison between cv-qualified and non-cv-qualified iterators be
                  // valid.  However, the greedy and unfriendly operators in std::rel_ops
                  // will make overload resolution ambiguous (when in scope) if we don't
                  // provide overloads whose operands are of the same type.  Can someone
                  // remind me what generic programming is about? -- Gaby
                
                  // Forward iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() != __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
       10128 ->     operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() != __rhs.base(); }
                
                  // Random access iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() >= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() >= __rhs.base(); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // According to the resolution of DR179 not only the various comparison
                  // operators but also operator- must accept mixed iterator/const_iterator
                  // parameters.
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                #if __cplusplus >= 201103L
                    // DR 685.
                    inline auto
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    -> decltype(__lhs.base() - __rhs.base())
                #else
                    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                #endif
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline typename __normal_iterator<_Iterator, _Container>::difference_type
       13428 ->     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline __normal_iterator<_Iterator, _Container>
                    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
                	      __n, const __normal_iterator<_Iterator, _Container>& __i)
                    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                  // 24.4.3  Move iterators
                  /**
                   *  Class template move_iterator is an iterator adapter with the same
                   *  behavior as the underlying iterator except that its dereference
                   *  operator implicitly converts the value returned by the underlying
                   *  iterator's dereference operator to an rvalue reference.  Some
                   *  generic algorithms can be called with move iterators to replace
                   *  copying with moving.
                   */
                  template<typename _Iterator>
                    class move_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      // NB: DR 680.
                      typedef _Iterator					pointer;
                      typedef value_type&&				reference;
                
                      move_iterator()
                      : _M_current() { }
                
                      explicit
                      move_iterator(iterator_type __i)
                      : _M_current(__i) { }
                
                      template<typename _Iter>
                	move_iterator(const move_iterator<_Iter>& __i)
                	: _M_current(__i.base()) { }
                
                      iterator_type
                      base() const
                      { return _M_current; }
                
                      reference
                      operator*() const
                      { return std::move(*_M_current); }
                
                      pointer
                      operator->() const
                      { return _M_current; }
                
                      move_iterator&
                      operator++()
                      {
                	++_M_current;
                	return *this;
                      }
                
                      move_iterator
                      operator++(int)
                      {
                	move_iterator __tmp = *this;
                	++_M_current;
                	return __tmp;
                      }
                
                      move_iterator&
                      operator--()
                      {
                	--_M_current;
                	return *this;
                      }
                
                      move_iterator
                      operator--(int)
                      {
                	move_iterator __tmp = *this;
                	--_M_current;
                	return __tmp;
                      }
                
                      move_iterator
                      operator+(difference_type __n) const
                      { return move_iterator(_M_current + __n); }
                
                      move_iterator&
                      operator+=(difference_type __n)
                      {
                	_M_current += __n;
                	return *this;
                      }
                
                      move_iterator
                      operator-(difference_type __n) const
                      { return move_iterator(_M_current - __n); }
                    
                      move_iterator&
                      operator-=(difference_type __n)
                      { 
                	_M_current -= __n;
                	return *this;
                      }
                
                      reference
                      operator[](difference_type __n) const
                      { return std::move(_M_current[__n]); }
                    };
                
                  // Note: See __normal_iterator operators note from Gaby to understand
                  // why there are always 2 versions for most of the move_iterator
                  // operators.
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator==(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline bool
                    operator==(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator!=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline bool
                    operator!=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _Iterator>
                    inline bool
                    operator<(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline bool
                    operator<=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline bool
                    operator>(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Iterator>
                    inline bool
                    operator>=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  // DR 685.
                  template<typename _IteratorL, typename _IteratorR>
                    inline auto
                    operator-(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    -> decltype(__x.base() - __y.base())
                    { return __x.base() - __y.base(); }
                
                  template<typename _Iterator>
                    inline auto
                    operator-(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    -> decltype(__x.base() - __y.base())
                    { return __x.base() - __y.base(); }
                
                  template<typename _Iterator>
                    inline move_iterator<_Iterator>
                    operator+(typename move_iterator<_Iterator>::difference_type __n,
                	      const move_iterator<_Iterator>& __x)
                    { return __x + __n; }
                
                  template<typename _Iterator>
                    inline move_iterator<_Iterator>
                    make_move_iterator(_Iterator __i)
                    { return move_iterator<_Iterator>(__i); }
                
                  template<typename _Iterator, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond
                      <typename iterator_traits<_Iterator>::value_type>::value,
                                _Iterator, move_iterator<_Iterator>>::type>
                    inline _ReturnType
                    __make_move_if_noexcept_iterator(_Iterator __i)
                    { return _ReturnType(__i); }
                
                  // @} group iterators
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \
                  std::__make_move_if_noexcept_iterator(_Iter)
                #else
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)
                #endif // C++11
                
                #endif


Top 10 Lines:

     Line      Count

      790      82613
      726      41466
      896      13428
      823      10128
      738       8440
      746       8440
      778       1688

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

   166203   Total number of line executions
 23743.29   Average executions per line


*** File /home/ubuntu/fyp/Project2_NT/Project2/Thresholding.cpp:
                
                #include "Thresholding.h"
                
                //#define SHOWHISTOGRAM
                
                
         873 -> Mat findHistogram(Mat inputImage, int numBins = 256) {
                	Mat hist;
                	Mat histNormal;
                
                
                	/// Establish the number of bins
                	int histSize = numBins;
                	float range[] = { 0, 256 };
                	const float* histRange = { range };
                
                	calcHist(&inputImage, 1, 0, Mat(), hist, 1, &histSize, &histRange, true, false);
                
                #ifdef SHOWHISTOGRAM
                	int hist_w = 512; int hist_h = 400;
                	int bin_w = cvRound((double)hist_w / histSize);
                
                	Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));
                
                	/// Normalize the result to [ 0, histImage.rows ]
                	normalize(hist, histNormal, 0, histImage.rows, NORM_MINMAX, -1, Mat());
                
                
                	for (int i = 1; i < histSize; i++)
                	{
                		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(histNormal.at<float>(i - 1))),
                			Point(bin_w*(i), hist_h - cvRound(histNormal.at<float>(i))),
                			Scalar(255, 255, 255), 1, 8, 0);
                	}
                
                	namedWindow("calcHist Demo", CV_WINDOW_AUTOSIZE);
                	imshow("calcHist Demo", histImage);
                #endif // DEBUG
                
                
                	return hist;
                }
                
                
       ##### -> myHist::myHist() {
                	absMaxLoc = 0;
                }
                
         873 -> myHist::myHist(Mat inputHistogram) {
                	inputHistogram.col(0).copyTo(histogram);
                	absMaxLoc = 0;
                }
                
         873 -> void myHist::findPeaksandMins(int findWidth = 15) {
                
                	int forLoopMin = -findWidth;
                	int forLoopMax = findWidth;
                
                	for (int i = 0; i < histogram.size(); i++) {
                
                		//Set for loop min and maximums
                		if (i < findWidth) {
                			forLoopMin = -i;
                			forLoopMax = findWidth;
                		}
                		else if ((i + findWidth) > histogram.size()) {
                			forLoopMax = int(histogram.size()) - i;
                			forLoopMin = -findWidth;
                		}
                		else {
                			forLoopMin = -findWidth;
                			forLoopMax = findWidth;
                		}
                
                
                		//If current position is the current min or max, save it's position.
                		double currentMin = histogram[i];
                		double currentMax = histogram[i];
                
                		for (int k = forLoopMin; k < forLoopMax; k++) {
                			if (histogram[i + k] < currentMin) {
                				currentMin = histogram[i + k];
                			}
                			if (histogram[i + k] > currentMax) {
                				currentMax = histogram[i + k];
                			}
                		}
                
                		if (currentMin == histogram[i]) {
                			minLocs.push_back(i);
                		}
                		if (currentMax == histogram[i] && currentMax != 0) {
                			peakLocs.push_back(i);
                		}
                
                		if (histogram[i] > histogram[absMaxLoc]) {
                			absMaxLoc = i;
                		}
                	}
                }
                
                
                void myHist::findThresholdByArea(int minArea = 30)
         873 -> {
                	double threshSum = 0;
                	int i = 0;
                	bool areaFound = false;
                
                	for (i = int(histogram.size()) - 1; i > 0 && areaFound == false; i--) {
                		threshSum += histogram[i];
                
                		if (threshSum > minArea)
                		{
                			areaFound = true;
                		}
                	}
                
                	if (checkThreshold(i)) {
                		threshold = findNextMin(i);
                	}
                	else {
                		threshold = -1;
                	}
                }
                
         873 -> bool myHist::checkThreshold(int testThreshold) {
                	return !((testThreshold - 10) < absMaxLoc);
                }
                
         844 -> int myHist::findNextMin(int testThreshold) {
                	for (int i = int(minLocs.size()) - 1; i >= 0; i--) {
                		if (minLocs[i] < testThreshold) {
                			return minLocs[i];
                		}
                	}
                	return -1;
                }
                
                
         873 -> int findThreshold(Mat inputImage) {
                
                	myHist hist(findHistogram(inputImage));
                	hist.findPeaksandMins();
                	hist.findThresholdByArea();
                
                	//printf("Threshold: %i ", hist.threshold);
                	return hist.threshold;
                
                }

Top 10 Lines:

     Line      Count

        7        873
       49        873
       54        873
      104        873
      126        873
      140        873
      130        844

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

     6082   Total number of line executions
   760.25   Average executions per line


*** File /home/ubuntu/fyp/Project2_NT/Project2/Insect.h:
                #ifndef INSECT
                #define INSECT
                
                #include <opencv2/core/core.hpp>
                #include <numeric> 
                #include <stdio.h>
                
                using namespace cv;
                using namespace std;
                
                
                #define ROI_SIZE .15
                #define HEIGHT_OFFSET 10
                
        4366 -> class Insect {
                	vector<int> heightMA;
                	Point2f prevPosition;
                	Point2f frameCentre;
                
                	void humanReadableOutput(void);
                public:
                	int heightBracket;
                	Point2f velocity;
                	float speed;
                	float direction;
                	Point2f position;
                	Point2f relPosition;
                	float relNorm;
                	float relAngle;
                	bool found;
                	Rect ROI;
                
                	Insect(Mat*);
                	void updateHeight(int);
                	void updatePosition(Point2f);
                	void updateROI(Mat*);
                };
                
                #endif // !INSECT


Top 10 Lines:

     Line      Count

       15       4366

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     4366   Total number of line executions
  4366.00   Average executions per line


*** File /usr/include/c++/4.8/bits/allocator.h:
                // Allocators -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 * Copyright (c) 1996-1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/allocator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOCATOR_H
                #define _ALLOCATOR_H 1
                
                #include <bits/c++allocator.h> // Define the base class to std::allocator.
                #include <bits/memoryfwd.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup allocators
                   *  @{
                   */
                
                  /// allocator<void> specialization.
                  template<>
                    class allocator<void>
                    {
                    public:
                      typedef size_t      size_type;
                      typedef ptrdiff_t   difference_type;
                      typedef void*       pointer;
                      typedef const void* const_pointer;
                      typedef void        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                #endif
                    };
                
                  /**
                   * @brief  The @a standard allocator, as per [20.4].
                   *
                   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html
                   *  for further details.
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class allocator: public __allocator_base<_Tp>
                    {
                   public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                #endif
                
        5153 ->       allocator() throw() { }
                
        1747 ->       allocator(const allocator& __a) throw()
                      : __allocator_base<_Tp>(__a) { }
                
                      template<typename _Tp1>
                        allocator(const allocator<_Tp1>&) throw() { }
                
       12721 ->       ~allocator() throw() { }
                
                      // Inherit everything else.
                    };
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator==(const allocator<_T1>&, const allocator<_T2>&)
                    { return true; }
                
                  template<typename _Tp>
                    inline bool
                    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
                    { return true; }
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator!=(const allocator<_T1>&, const allocator<_T2>&)
                    { return false; }
                
                  template<typename _Tp>
                    inline bool
                    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
                    { return false; }
                
                  /// @} group allocator
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class allocator<char>;
                  extern template class allocator<wchar_t>;
                #endif
                
                  // Undefine.
                #undef __allocator_base
                
                  // To implement Option 3 of DR 431.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_swap
                    { static void _S_do_it(_Alloc&, _Alloc&) { } };
                
                  template<typename _Alloc>
                    struct __alloc_swap<_Alloc, false>
                    {
                      static void
                      _S_do_it(_Alloc& __one, _Alloc& __two)
                      {
                	// Precondition: swappable allocators.
                	if (__one != __two)
                	  swap(__one, __two);
                      }
                    };
                
                  // Optimize for stateless allocators.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_neq
                    {
                      static bool
                      _S_do_it(const _Alloc&, const _Alloc&)
                      { return false; }
                    };
                
                  template<typename _Alloc>
                    struct __alloc_neq<_Alloc, false>
                    {
                      static bool
                      _S_do_it(const _Alloc& __one, const _Alloc& __two)
                      { return __one != __two; }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, bool
                    = __or_<is_copy_constructible<typename _Tp::value_type>,
                            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
                    struct __shrink_to_fit_aux
                    { static bool _S_do_it(_Tp&) { return false; } };
                
                  template<typename _Tp>
                    struct __shrink_to_fit_aux<_Tp, true>
                    {
                      static bool
                      _S_do_it(_Tp& __c)
                      {
                	__try
                	  {
                	    _Tp(__make_move_if_noexcept_iterator(__c.begin()),
                		__make_move_if_noexcept_iterator(__c.end()),
                		__c.get_allocator()).swap(__c);
                	    return true;
                	  }
                	__catch(...)
                	  { return false; }
                      }
                    };
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      121      12721
      113       5153
      115       1747

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

    19621   Total number of line executions
  6540.33   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_iterator_base_types.h:
                // Types used in iterator implementation -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_types.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility types,
                 *  such as iterator_traits and struct iterator.
                 */
                
                #ifndef _STL_ITERATOR_BASE_TYPES_H
                #define _STL_ITERATOR_BASE_TYPES_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>  // For _GLIBCXX_HAS_NESTED_TYPE, is_convertible
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @defgroup iterators Iterators
                   *  Abstractions for uniform iterating through various underlying types.
                  */
                  //@{ 
                
                  /**
                   *  @defgroup iterator_tags Iterator Tags
                   *  These are empty types, used to distinguish different iterators.  The
                   *  distinction is not made by what they contain, but simply by what they
                   *  are.  Different underlying algorithms can then be used based on the
                   *  different operations supported by different iterator types.
                  */
                  //@{ 
                  ///  Marking input iterators.
                  struct input_iterator_tag { };
                
                  ///  Marking output iterators.
                  struct output_iterator_tag { };
                
                  /// Forward iterators support a superset of input iterator operations.
                  struct forward_iterator_tag : public input_iterator_tag { };
                
                  /// Bidirectional iterators support a superset of forward iterator
                  /// operations.
                  struct bidirectional_iterator_tag : public forward_iterator_tag { };
                
                  /// Random-access iterators support a superset of bidirectional
                  /// iterator operations.
                  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
                  //@}
                
                  /**
                   *  @brief  Common %iterator class.
                   *
                   *  This class does nothing but define nested typedefs.  %Iterator classes
                   *  can inherit from this class to save some work.  The typedefs are then
                   *  used in specializations and overloading.
                   *
                   *  In particular, there are no default implementations of requirements
                   *  such as @c operator++ and the like.  (How could there be?)
                  */
                  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
                           typename _Pointer = _Tp*, typename _Reference = _Tp&>
                    struct iterator
                    {
                      /// One of the @link iterator_tags tag types@endlink.
                      typedef _Category  iterator_category;
                      /// The type "pointed to" by the iterator.
                      typedef _Tp        value_type;
                      /// Distance between iterators is represented as this type.
                      typedef _Distance  difference_type;
                      /// This type represents a pointer-to-value_type.
                      typedef _Pointer   pointer;
                      /// This type represents a reference-to-value_type.
                      typedef _Reference reference;
                    };
                
                  /**
                   *  @brief  Traits class for iterators.
                   *
                   *  This class does nothing but define nested typedefs.  The general
                   *  version simply @a forwards the nested typedefs from the Iterator
                   *  argument.  Specialized versions for pointers and pointers-to-const
                   *  provide tighter, more correct semantics.
                  */
                #if __cplusplus >= 201103L
                
                _GLIBCXX_HAS_NESTED_TYPE(iterator_category)
                
                  template<typename _Iterator,
                	   bool = __has_iterator_category<_Iterator>::value>
                    struct __iterator_traits { };
                
                  template<typename _Iterator>
                    struct __iterator_traits<_Iterator, true>
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                
                  template<typename _Iterator>
                    struct iterator_traits
                    : public __iterator_traits<_Iterator> { };
                #else
                  template<typename _Iterator>
                    struct iterator_traits
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                #endif
                
                  /// Partial specialization for pointer types.
                  template<typename _Tp>
                    struct iterator_traits<_Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef _Tp*                        pointer;
                      typedef _Tp&                        reference;
                    };
                
                  /// Partial specialization for const pointer types.
                  template<typename _Tp>
                    struct iterator_traits<const _Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef const _Tp*                  pointer;
                      typedef const _Tp&                  reference;
                    };
                
                  /**
                   *  This function is not a part of the C++ standard but is syntactic
                   *  sugar for internal library use only.
                  */
                  template<typename _Iter>
                    inline typename iterator_traits<_Iter>::iterator_category
                    __iterator_category(const _Iter&)
                    { return typename iterator_traits<_Iter>::iterator_category(); }
                
                  //@}
                
                  // If _Iterator has a base returns it otherwise _Iterator is returned
                  // untouched
                  template<typename _Iterator, bool _HasBase>
                    struct _Iter_base
                    {
                      typedef _Iterator iterator_type;
      126276 ->       static iterator_type _S_base(_Iterator __it)
                      { return __it; }
                    };
                
                  template<typename _Iterator>
                    struct _Iter_base<_Iterator, true>
                    {
                      typedef typename _Iterator::iterator_type iterator_type;
        8645 ->       static iterator_type _S_base(_Iterator __it)
                      { return __it.base(); }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _InIter>
                    using _RequireInputIter = typename
                      enable_if<is_convertible<typename
                		iterator_traits<_InIter>::iterator_category,
                			       input_iterator_tag>::value>::type;
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_TYPES_H */
                


Top 10 Lines:

     Line      Count

      212     126276
      220       8645

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

   134921   Total number of line executions
 67460.50   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_uninitialized.h:
                // Raw memory manipulators -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_uninitialized.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_UNINITIALIZED_H
                #define _STL_UNINITIALIZED_H 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<bool _TrivialValueTypes>
                    struct __uninitialized_copy
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
        3336 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        {
                	  _ForwardIterator __cur = __result;
                	  __try
                	    {
                	      for (; __first != __last; ++__first, ++__cur)
                		std::_Construct(std::__addressof(*__cur), *__first);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__result, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_copy<true>
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
       25267 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        { return std::copy(__first, __last, __result); }
                    };
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   __result + (__first - __last)
                   *
                   *  Like copy(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
       28603 ->     uninitialized_copy(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                
                      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
                					&& __is_trivial(_ValueType2))>::
                	__uninit_copy(__first, __last, __result);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill<true>
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        { std::fill(__first, __last, __x); }
                    };
                
                  /**
                   *  @brief Copies the value x into the range [first,last).
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
                		       const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      std::__uninitialized_fill<__is_trivial(_ValueType)>::
                	__uninit_fill(__first, __last, __x);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill_n
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static void
                        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill_n<true>
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static void
           1 ->         __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        { std::fill_n(__first, __n, __x); }
                    };
                
                  /**
                   *  @brief Copies the value x into the range [first,first+n).
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of copies to make.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill_n(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline void
           1 ->     uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
                	__uninit_fill_n(__first, __n, __x);
                    }
                
                  // Extensions: versions of uninitialized_copy, uninitialized_fill,
                  //  and uninitialized_fill_n that take an allocator parameter.
                  //  We dispatch back to the standard versions when we're given the
                  //  default allocator.  For nondefault allocators we do not use 
                  //  any of the POD optimizations.
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __first != __last; ++__first, ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
       28603 ->     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, allocator<_Tp>&)
                    { return std::uninitialized_copy(__first, __last, __result); }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
                					 __result, __alloc);
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
       26856 ->     __uninitialized_move_if_noexcept_a(_InputIterator __first,
                				       _InputIterator __last,
                				       _ForwardIterator __result,
                				       _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a
                	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
                    void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
                    inline void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, allocator<_Tp2>&)
                    { std::uninitialized_fill(__first, __last, __x); }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Allocator>
                    void
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Tp2>
                    inline void
           1 ->     __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, allocator<_Tp2>&)
                    { std::uninitialized_fill_n(__first, __n, __x); }
                
                
                  // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
                  // __uninitialized_fill_move, __uninitialized_move_fill.
                  // All of these algorithms take a user-supplied allocator, which is used
                  // for construction and destruction.
                
                  // __uninitialized_copy_move
                  // Copies [first1, last1) into [result, result + (last1 - first1)), and
                  //  move [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_copy_move(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_copy
                  // Moves [first1, last1) into [result, result + (last1 - first1)), and
                  //  copies [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_copy(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                  
                  // __uninitialized_fill_move
                  // Fills [result, mid) with x, and moves [first, last) into
                  //  [mid, mid + (last - first)).
                  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
                			      const _Tp& __x, _InputIterator __first,
                			      _InputIterator __last, _Allocator& __alloc)
                    {
                      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_fill
                  // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and
                  //  fills [first2 + (last1 - first1), last2) with x.
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
                	   typename _Allocator>
                    inline void
                    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
                			      _ForwardIterator __first2,
                			      _ForwardIterator __last2, const _Tp& __x,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
                							    __first2,
                							    __alloc);
                      __try
                	{
                	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first2, __mid2, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  // Extensions: __uninitialized_default, __uninitialized_default_n,
                  // __uninitialized_default_a, __uninitialized_default_n_a.
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_1
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  std::fill(__first, __last, _ValueType());
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static void
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static void
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  std::fill_n(__first, __n, _ValueType());
                	}
                    };
                
                  // __uninitialized_default
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s).
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default(_ForwardIterator __first,
                			    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      std::__uninitialized_default_1<__is_trivial(_ValueType)>::
                	__uninit_default(__first, __last);
                    }
                
                  // __uninitialized_default_n
                  // Fills [first, first + n) with n default constructed value_type(s).
                  template<typename _ForwardIterator, typename _Size>
                    inline void
                    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      std::__uninitialized_default_n_1<__is_trivial(_ValueType)>::
                	__uninit_default_n(__first, __n);
                    }
                
                
                  // __uninitialized_default_a
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s), constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      allocator<_Tp>&)
                    { std::__uninitialized_default(__first, __last); }
                
                
                  // __uninitialized_default_n_a
                  // Fills [first, first + n) with n default constructed value_types(s),
                  // constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Size, typename _Allocator>
                    void
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				_Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline void
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				allocator<_Tp>&)
                    { std::__uninitialized_default_n(__first, __n); }
                
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    _ForwardIterator
                    __uninitialized_copy_n(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline _ForwardIterator
                    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    { return std::uninitialized_copy(__first, __first + __n, __result); }
                
                  /**
                   *  @brief Copies the range [first,first+n) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  __result + __n
                   *
                   *  Like copy_n(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_copy_n(_InputIterator __first, _Size __n,
                			 _ForwardIterator __result)
                    { return std::__uninitialized_copy_n(__first, __n, __result,
                					 std::__iterator_category(__first)); }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_UNINITIALIZED_H */


Top 10 Lines:

     Line      Count

      107      28603
      256      28603
      274      26856
       91      25267
       68       3336
      202          1
      218          1
      332          1

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

   112668   Total number of line executions
 14083.50   Average executions per line


*** File /usr/include/c++/4.8/new:
                // The -*- C++ -*- dynamic memory management header.
                
                // Copyright (C) 1994-2013 Free Software Foundation, Inc.
                
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                // 
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                // 
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file new
                 *  This is a Standard C++ Library header.
                 *
                 *  The header @c new defines several functions to manage dynamic memory and
                 *  handling memory allocation errors; see
                 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
                 */
                
                #ifndef _NEW
                #define _NEW
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <exception>
                
                #pragma GCC visibility push(default)
                
                extern "C++" {
                
                namespace std 
                {
                  /**
                   *  @brief  Exception possibly thrown by @c new.
                   *  @ingroup exceptions
                   *
                   *  @c bad_alloc (or classes derived from it) is used to report allocation
                   *  errors from the throwing forms of @c new.  */
                  class bad_alloc : public exception 
                  {
                  public:
                    bad_alloc() throw() { }
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_alloc() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                
                  struct nothrow_t { };
                
                  extern const nothrow_t nothrow;
                
                  /** If you write your own error handler to be called by @c new, it must
                   *  be of this type.  */
                  typedef void (*new_handler)();
                
                  /// Takes a replacement handler as the argument, returns the
                  /// previous handler.
                  new_handler set_new_handler(new_handler) throw();
                } // namespace std
                
                //@{
                /** These are replaceable signatures:
                 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
                 *  - normal array new and delete (same)
                 *  - @c nothrow single new and delete (take a @c nothrow argument, return
                 *    @c NULL on error)
                 *  - @c nothrow array new and delete (same)
                 *
                 *  Placement new and delete signatures (take a memory address argument,
                 *  does nothing) may not be replaced by a user's program.
                */
                void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                
                // Default placement versions of operator new.
                inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
      101841 -> { return __p; }
                inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
                { return __p; }
                
                // Default placement versions of operator delete.
                inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                //@}
                } // extern "C++"
                
                #pragma GCC visibility pop
                
                #endif


Top 10 Lines:

     Line      Count

      110     101841

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

   101841   Total number of line executions
101841.00   Average executions per line


*** File /usr/include/c++/4.8/ext/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/alloc_traits.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _EXT_ALLOC_TRAITS_H
                #define _EXT_ALLOC_TRAITS_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus >= 201103L
                # include <bits/move.h>
                # include <bits/alloc_traits.h>
                #else
                # include <bits/allocator.h>  // for __alloc_swap
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus >= 201103L
                  template<typename _Alloc>
                    struct __allocator_always_compares_equal
                    { static const bool value = false; };
                
                  template<typename _Alloc>
                    const bool __allocator_always_compares_equal<_Alloc>::value;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<std::allocator<_Tp>>
                    { static const bool value = true; };
                
                  template<typename _Tp>
                    const bool __allocator_always_compares_equal<std::allocator<_Tp>>::value;
                
                  template<typename, typename> struct array_allocator;
                
                  template<typename _Tp, typename _Array>
                    struct __allocator_always_compares_equal<array_allocator<_Tp, _Array>>
                    { static const bool value = true; };
                
                  template<typename _Tp, typename _Array>
                    const bool
                    __allocator_always_compares_equal<array_allocator<_Tp, _Array>>::value;
                
                  template<typename> struct bitmap_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<bitmap_allocator<_Tp>>
                    { static const bool value = true; };
                
                  template<typename _Tp>
                    const bool __allocator_always_compares_equal<bitmap_allocator<_Tp>>::value;
                
                  template<typename> struct malloc_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<malloc_allocator<_Tp>>
                    { static const bool value = true; };
                
                  template<typename _Tp>
                    const bool __allocator_always_compares_equal<malloc_allocator<_Tp>>::value;
                
                  template<typename> struct mt_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<mt_allocator<_Tp>>
                    { static const bool value = true; };
                
                  template<typename _Tp>
                    const bool __allocator_always_compares_equal<mt_allocator<_Tp>>::value;
                
                  template<typename> struct new_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<new_allocator<_Tp>>
                    { static const bool value = true; };
                
                  template<typename _Tp>
                    const bool __allocator_always_compares_equal<new_allocator<_Tp>>::value;
                
                  template<typename> struct pool_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<pool_allocator<_Tp>>
                    { static const bool value = true; };
                
                  template<typename _Tp>
                    const bool __allocator_always_compares_equal<pool_allocator<_Tp>>::value;
                #endif
                
                /**
                 * @brief  Uniform interface to C++98 and C++0x allocators.
                 * @ingroup allocators
                */
                template<typename _Alloc>
                  struct __alloc_traits
                #if __cplusplus >= 201103L
                  : std::allocator_traits<_Alloc>
                #endif
                  {
                    typedef _Alloc allocator_type;
                #if __cplusplus >= 201103L
                    typedef std::allocator_traits<_Alloc>           _Base_type;
                    typedef typename _Base_type::value_type         value_type;
                    typedef typename _Base_type::pointer            pointer;
                    typedef typename _Base_type::const_pointer      const_pointer;
                    typedef typename _Base_type::size_type          size_type;
                    typedef typename _Base_type::difference_type    difference_type;
                    // C++0x allocators do not define reference or const_reference
                    typedef value_type&                             reference;
                    typedef const value_type&                       const_reference;
                    using _Base_type::allocate;
                    using _Base_type::deallocate;
                    using _Base_type::construct;
                    using _Base_type::destroy;
                    using _Base_type::max_size;
                
                  private:
                    template<typename _Ptr>
                      struct __is_custom_pointer
                      : std::integral_constant<bool, std::is_same<pointer, _Ptr>::value
                                                     && !std::is_pointer<_Ptr>::value>
                      { };
                
                  public:
                    // overload construct for non-standard pointer types
                    template<typename _Ptr, typename... _Args>
                      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
                      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
                      {
                	_Base_type::construct(__a, std::addressof(*__p),
                			      std::forward<_Args>(__args)...);
                      }
                
                    // overload destroy for non-standard pointer types
                    template<typename _Ptr>
                      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
                      destroy(_Alloc& __a, _Ptr __p)
                      { _Base_type::destroy(__a, std::addressof(*__p)); }
                
                    static _Alloc _S_select_on_copy(const _Alloc& __a)
                    { return _Base_type::select_on_container_copy_construction(__a); }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    { std::__alloc_on_swap(__a, __b); }
                
                    static constexpr bool _S_propagate_on_copy_assign()
                    { return _Base_type::propagate_on_container_copy_assignment::value; }
                
                    static constexpr bool _S_propagate_on_move_assign()
                    { return _Base_type::propagate_on_container_move_assignment::value; }
                
                    static constexpr bool _S_propagate_on_swap()
                    { return _Base_type::propagate_on_container_swap::value; }
                
                    static constexpr bool _S_always_equal()
                    { return __allocator_always_compares_equal<_Alloc>::value; }
                
                    static constexpr bool _S_nothrow_move()
                    { return _S_propagate_on_move_assign() || _S_always_equal(); }
                
                    static constexpr bool _S_nothrow_swap()
                    {
                      using std::swap;
                      return !_S_propagate_on_swap()
                       	|| noexcept(swap(std::declval<_Alloc&>(), std::declval<_Alloc&>()));
                    }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
                #else
                
                    typedef typename _Alloc::pointer                pointer;
                    typedef typename _Alloc::const_pointer          const_pointer;
                    typedef typename _Alloc::value_type             value_type;
                    typedef typename _Alloc::reference              reference;
                    typedef typename _Alloc::const_reference        const_reference;
                    typedef typename _Alloc::size_type              size_type;
                    typedef typename _Alloc::difference_type        difference_type;
                
                    static pointer
                    allocate(_Alloc& __a, size_type __n)
                    { return __a.allocate(__n); }
                
                    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
                    { __a.deallocate(__p, __n); }
                
                    template<typename _Tp>
      100525 ->       static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
                      { __a.construct(__p, __arg); }
                
         844 ->     static void destroy(_Alloc& __a, pointer __p)
                    { __a.destroy(__p); }
                
       26856 ->     static size_type max_size(const _Alloc& __a)
                    { return __a.max_size(); }
                
        1746 ->     static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 431. Swapping containers with unequal allocators.
                      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
                    }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Alloc::template rebind<_Tp>::other other; };
                #endif
                  };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      215     100525
      221      26856
      224       1746
      218        844

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

   129971   Total number of line executions
 32492.75   Average executions per line


*** File /usr/include/opencv2/core/mat.hpp:
                /*M///////////////////////////////////////////////////////////////////////////////////////
                //
                //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
                //
                //  By downloading, copying, installing or using the software you agree to this license.
                //  If you do not agree to this license, do not download, install,
                //  copy or use the software.
                //
                //
                //                           License Agreement
                //                For Open Source Computer Vision Library
                //
                // Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
                // Copyright (C) 2009, Willow Garage Inc., all rights reserved.
                // Third party copyrights are property of their respective owners.
                //
                // Redistribution and use in source and binary forms, with or without modification,
                // are permitted provided that the following conditions are met:
                //
                //   * Redistribution's of source code must retain the above copyright notice,
                //     this list of conditions and the following disclaimer.
                //
                //   * Redistribution's in binary form must reproduce the above copyright notice,
                //     this list of conditions and the following disclaimer in the documentation
                //     and/or other materials provided with the distribution.
                //
                //   * The name of the copyright holders may not be used to endorse or promote products
                //     derived from this software without specific prior written permission.
                //
                // This software is provided by the copyright holders and contributors "as is" and
                // any express or implied warranties, including, but not limited to, the implied
                // warranties of merchantability and fitness for a particular purpose are disclaimed.
                // In no event shall the Intel Corporation or contributors be liable for any direct,
                // indirect, incidental, special, exemplary, or consequential damages
                // (including, but not limited to, procurement of substitute goods or services;
                // loss of use, data, or profits; or business interruption) however caused
                // and on any theory of liability, whether in contract, strict liability,
                // or tort (including negligence or otherwise) arising in any way out of
                // the use of this software, even if advised of the possibility of such damage.
                //
                //M*/
                
                #ifndef __OPENCV_CORE_MATRIX_OPERATIONS_HPP__
                #define __OPENCV_CORE_MATRIX_OPERATIONS_HPP__
                
                #ifndef SKIP_INCLUDES
                #include <limits.h>
                #include <string.h>
                #endif // SKIP_INCLUDES
                
                #ifdef __cplusplus
                
                namespace cv
                {
                
                //////////////////////////////// Mat ////////////////////////////////
                
                inline void Mat::initEmpty()
        8703 -> {
                    flags = MAGIC_VAL;
                    dims = rows = cols = 0;
                    data = datastart = dataend = datalimit = 0;
                    refcount = 0;
                    allocator = 0;
                }
                
        8703 -> inline Mat::Mat() : size(&rows)
                {
                    initEmpty();
                }
                
                inline Mat::Mat(int _rows, int _cols, int _type) : size(&rows)
                {
                    initEmpty();
                    create(_rows, _cols, _type);
                }
                
                inline Mat::Mat(int _rows, int _cols, int _type, const Scalar& _s) : size(&rows)
                {
                    initEmpty();
                    create(_rows, _cols, _type);
                    *this = _s;
                }
                
                inline Mat::Mat(Size _sz, int _type) : size(&rows)
                {
                    initEmpty();
                    create( _sz.height, _sz.width, _type );
                }
                
                inline Mat::Mat(Size _sz, int _type, const Scalar& _s) : size(&rows)
                {
                    initEmpty();
                    create(_sz.height, _sz.width, _type);
                    *this = _s;
                }
                
                inline Mat::Mat(int _dims, const int* _sz, int _type) : size(&rows)
                {
                    initEmpty();
                    create(_dims, _sz, _type);
                }
                
                inline Mat::Mat(int _dims, const int* _sz, int _type, const Scalar& _s) : size(&rows)
                {
                    initEmpty();
                    create(_dims, _sz, _type);
                    *this = _s;
                }
                
        3463 -> inline Mat::Mat(const Mat& m)
                    : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data),
                    refcount(m.refcount), datastart(m.datastart), dataend(m.dataend),
                    datalimit(m.datalimit), allocator(m.allocator), size(&rows)
                {
                    if( refcount )
                        CV_XADD(refcount, 1);
                    if( m.dims <= 2 )
                    {
                        step[0] = m.step[0]; step[1] = m.step[1];
                    }
                    else
                    {
                        dims = 0;
                        copySize(m);
                    }
                }
                
                inline Mat::Mat(int _rows, int _cols, int _type, void* _data, size_t _step)
                    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_rows), cols(_cols),
                    data((uchar*)_data), refcount(0), datastart((uchar*)_data), dataend(0),
                    datalimit(0), allocator(0), size(&rows)
                {
                    size_t esz = CV_ELEM_SIZE(_type), minstep = cols*esz;
                    if( _step == AUTO_STEP )
                    {
                        _step = minstep;
                        flags |= CONTINUOUS_FLAG;
                    }
                    else
                    {
                        if( rows == 1 ) _step = minstep;
                        CV_DbgAssert( _step >= minstep );
                        flags |= _step == minstep ? CONTINUOUS_FLAG : 0;
                    }
                    step[0] = _step; step[1] = esz;
                    datalimit = datastart + _step*rows;
                    dataend = datalimit - _step + minstep;
                }
                
                inline Mat::Mat(Size _sz, int _type, void* _data, size_t _step)
                    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_sz.height), cols(_sz.width),
                    data((uchar*)_data), refcount(0), datastart((uchar*)_data), dataend(0),
                    datalimit(0), allocator(0), size(&rows)
                {
                    size_t esz = CV_ELEM_SIZE(_type), minstep = cols*esz;
                    if( _step == AUTO_STEP )
                    {
                        _step = minstep;
                        flags |= CONTINUOUS_FLAG;
                    }
                    else
                    {
                        if( rows == 1 ) _step = minstep;
                        CV_DbgAssert( _step >= minstep );
                        flags |= _step == minstep ? CONTINUOUS_FLAG : 0;
                    }
                    step[0] = _step; step[1] = esz;
                    datalimit = datastart + _step*rows;
                    dataend = datalimit - _step + minstep;
                }
                
                
                template<typename _Tp> inline Mat::Mat(const vector<_Tp>& vec, bool copyData)
                    : flags(MAGIC_VAL | DataType<_Tp>::type | CV_MAT_CONT_FLAG),
                    dims(2), rows((int)vec.size()), cols(1), data(0), refcount(0),
                    datastart(0), dataend(0), allocator(0), size(&rows)
                {
                    if(vec.empty())
                        return;
                    if( !copyData )
                    {
                        step[0] = step[1] = sizeof(_Tp);
                        data = datastart = (uchar*)&vec[0];
                        datalimit = dataend = datastart + rows*step[0];
                    }
                    else
                        Mat((int)vec.size(), 1, DataType<_Tp>::type, (uchar*)&vec[0]).copyTo(*this);
                }
                
                
                template<typename _Tp, int n> inline Mat::Mat(const Vec<_Tp, n>& vec, bool copyData)
                    : flags(MAGIC_VAL | DataType<_Tp>::type | CV_MAT_CONT_FLAG),
                    dims(2), rows(n), cols(1), data(0), refcount(0),
                    datastart(0), dataend(0), allocator(0), size(&rows)
                {
                    if( !copyData )
                    {
                        step[0] = step[1] = sizeof(_Tp);
                        data = datastart = (uchar*)vec.val;
                        datalimit = dataend = datastart + rows*step[0];
                    }
                    else
                        Mat(n, 1, DataType<_Tp>::type, (void*)vec.val).copyTo(*this);
                }
                
                
                template<typename _Tp, int m, int n> inline Mat::Mat(const Matx<_Tp,m,n>& M, bool copyData)
                    : flags(MAGIC_VAL | DataType<_Tp>::type | CV_MAT_CONT_FLAG),
                    dims(2), rows(m), cols(n), data(0), refcount(0),
                    datastart(0), dataend(0), allocator(0), size(&rows)
                {
                    if( !copyData )
                    {
                        step[0] = cols*sizeof(_Tp);
                        step[1] = sizeof(_Tp);
                        data = datastart = (uchar*)M.val;
                        datalimit = dataend = datastart + rows*step[0];
                    }
                    else
                        Mat(m, n, DataType<_Tp>::type, (uchar*)M.val).copyTo(*this);
                }
                
                
                template<typename _Tp> inline Mat::Mat(const Point_<_Tp>& pt, bool copyData)
                    : flags(MAGIC_VAL | DataType<_Tp>::type | CV_MAT_CONT_FLAG),
                    dims(2), rows(2), cols(1), data(0), refcount(0),
                    datastart(0), dataend(0), allocator(0), size(&rows)
                {
                    if( !copyData )
                    {
                        step[0] = step[1] = sizeof(_Tp);
                        data = datastart = (uchar*)&pt.x;
                        datalimit = dataend = datastart + rows*step[0];
                    }
                    else
                    {
                        create(2, 1, DataType<_Tp>::type);
                        ((_Tp*)data)[0] = pt.x;
                        ((_Tp*)data)[1] = pt.y;
                    }
                }
                
                
                template<typename _Tp> inline Mat::Mat(const Point3_<_Tp>& pt, bool copyData)
                    : flags(MAGIC_VAL | DataType<_Tp>::type | CV_MAT_CONT_FLAG),
                    dims(2), rows(3), cols(1), data(0), refcount(0),
                    datastart(0), dataend(0), allocator(0), size(&rows)
                {
                    if( !copyData )
                    {
                        step[0] = step[1] = sizeof(_Tp);
                        data = datastart = (uchar*)&pt.x;
                        datalimit = dataend = datastart + rows*step[0];
                    }
                    else
                    {
                        create(3, 1, DataType<_Tp>::type);
                        ((_Tp*)data)[0] = pt.x;
                        ((_Tp*)data)[1] = pt.y;
                        ((_Tp*)data)[2] = pt.z;
                    }
                }
                
                
                template<typename _Tp> inline Mat::Mat(const MatCommaInitializer_<_Tp>& commaInitializer)
                    : flags(MAGIC_VAL | DataType<_Tp>::type | CV_MAT_CONT_FLAG),
                    dims(0), rows(0), cols(0), data(0), refcount(0),
                    datastart(0), dataend(0), allocator(0), size(&rows)
                {
                    *this = *commaInitializer;
                }
                
       13912 -> inline Mat::~Mat()
                {
                    release();
                    if( step.p != step.buf )
                        fastFree(step.p);
                }
                
                inline Mat& Mat::operator = (const Mat& m)
        1746 -> {
                    if( this != &m )
                    {
                        if( m.refcount )
                            CV_XADD(m.refcount, 1);
                        release();
                        flags = m.flags;
                        if( dims <= 2 && m.dims <= 2 )
                        {
                            dims = m.dims;
                            rows = m.rows;
                            cols = m.cols;
                            step[0] = m.step[0];
                            step[1] = m.step[1];
                        }
                        else
                            copySize(m);
                        data = m.data;
                        datastart = m.datastart;
                        dataend = m.dataend;
                        datalimit = m.datalimit;
                        refcount = m.refcount;
                        allocator = m.allocator;
                    }
                    return *this;
                }
                
                inline Mat Mat::row(int y) const { return Mat(*this, Range(y, y+1), Range::all()); }
         873 -> inline Mat Mat::col(int x) const { return Mat(*this, Range::all(), Range(x, x+1)); }
                inline Mat Mat::rowRange(int startrow, int endrow) const
                    { return Mat(*this, Range(startrow, endrow), Range::all()); }
                inline Mat Mat::rowRange(const Range& r) const
                    { return Mat(*this, r, Range::all()); }
                inline Mat Mat::colRange(int startcol, int endcol) const
                    { return Mat(*this, Range::all(), Range(startcol, endcol)); }
                inline Mat Mat::colRange(const Range& r) const
                    { return Mat(*this, Range::all(), r); }
                
                inline Mat Mat::diag(const Mat& d)
                {
                    CV_Assert( d.cols == 1 || d.rows == 1 );
                    int len = d.rows + d.cols - 1;
                    Mat m(len, len, d.type(), Scalar(0)), md = m.diag();
                    if( d.cols == 1 )
                        d.copyTo(md);
                    else
                        transpose(d, md);
                    return m;
                }
                
                inline Mat Mat::clone() const
         873 -> {
                    Mat m;
                    copyTo(m);
                    return m;
                }
                
                inline void Mat::assignTo( Mat& m, int _type ) const
                {
                    if( _type < 0 )
                        m = *this;
                    else
                        convertTo(m, _type);
                }
                
                inline void Mat::create(int _rows, int _cols, int _type)
                {
                    _type &= TYPE_MASK;
                    if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && data )
                        return;
                    int sz[] = {_rows, _cols};
                    create(2, sz, _type);
                }
                
                inline void Mat::create(Size _sz, int _type)
                {
                    create(_sz.height, _sz.width, _type);
                }
                
                inline void Mat::addref()
                { if( refcount ) CV_XADD(refcount, 1); }
                
                inline void Mat::release()
       15658 -> {
                    if( refcount && CV_XADD(refcount, -1) == 1 )
                        deallocate();
                    data = datastart = dataend = datalimit = 0;
                    for(int i = 0; i < dims; i++)
                        size.p[i] = 0;
                    refcount = 0;
                }
                
                inline Mat Mat::operator()( Range _rowRange, Range _colRange ) const
                {
                    return Mat(*this, _rowRange, _colRange);
                }
                
                inline Mat Mat::operator()( const Rect& roi ) const
         873 -> { return Mat(*this, roi); }
                
                inline Mat Mat::operator()(const Range* ranges) const
                {
                    return Mat(*this, ranges);
                }
                
                inline Mat::operator CvMat() const
                {
                    CV_DbgAssert(dims <= 2);
                    CvMat m = cvMat(rows, dims == 1 ? 1 : cols, type(), data);
                    m.step = (int)step[0];
                    m.type = (m.type & ~CONTINUOUS_FLAG) | (flags & CONTINUOUS_FLAG);
                    return m;
                }
                
                inline bool Mat::isContinuous() const { return (flags & CONTINUOUS_FLAG) != 0; }
                inline bool Mat::isSubmatrix() const { return (flags & SUBMATRIX_FLAG) != 0; }
                inline size_t Mat::elemSize() const { return dims > 0 ? step.p[dims-1] : 0; }
                inline size_t Mat::elemSize1() const { return CV_ELEM_SIZE1(flags); }
                inline int Mat::type() const { return CV_MAT_TYPE(flags); }
                inline int Mat::depth() const { return CV_MAT_DEPTH(flags); }
                inline int Mat::channels() const { return CV_MAT_CN(flags); }
                inline size_t Mat::step1(int i) const { return step.p[i]/elemSize1(); }
         874 -> inline bool Mat::empty() const { return data == 0 || total() == 0; }
                inline size_t Mat::total() const
         873 -> {
                    if( dims <= 2 )
                        return (size_t)rows*cols;
                    size_t p = 1;
                    for( int i = 0; i < dims; i++ )
                        p *= size[i];
                    return p;
                }
                
                inline uchar* Mat::ptr(int y)
                {
                    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
                    return data + step.p[0]*y;
                }
                
                inline const uchar* Mat::ptr(int y) const
                {
                    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
                    return data + step.p[0]*y;
                }
                
                template<typename _Tp> inline _Tp* Mat::ptr(int y)
                {
                    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
                    return (_Tp*)(data + step.p[0]*y);
                }
                
                template<typename _Tp> inline const _Tp* Mat::ptr(int y) const
                {
                    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
                    return (const _Tp*)(data + step.p[0]*y);
                }
                
                
                inline uchar* Mat::ptr(int i0, int i1)
                {
                    CV_DbgAssert( dims >= 2 && data &&
                                  (unsigned)i0 < (unsigned)size.p[0] &&
                                  (unsigned)i1 < (unsigned)size.p[1] );
                    return data + i0*step.p[0] + i1*step.p[1];
                }
                
                inline const uchar* Mat::ptr(int i0, int i1) const
                {
                    CV_DbgAssert( dims >= 2 && data &&
                                 (unsigned)i0 < (unsigned)size.p[0] &&
                                 (unsigned)i1 < (unsigned)size.p[1] );
                    return data + i0*step.p[0] + i1*step.p[1];
                }
                
                template<typename _Tp> inline _Tp* Mat::ptr(int i0, int i1)
                {
                    CV_DbgAssert( dims >= 2 && data &&
                                  (unsigned)i0 < (unsigned)size.p[0] &&
                                  (unsigned)i1 < (unsigned)size.p[1] );
                    return (_Tp*)(data + i0*step.p[0] + i1*step.p[1]);
                }
                
                template<typename _Tp> inline const _Tp* Mat::ptr(int i0, int i1) const
                {
                    CV_DbgAssert( dims >= 2 && data &&
                                  (unsigned)i0 < (unsigned)size.p[0] &&
                                  (unsigned)i1 < (unsigned)size.p[1] );
                    return (const _Tp*)(data + i0*step.p[0] + i1*step.p[1]);
                }
                
                inline uchar* Mat::ptr(int i0, int i1, int i2)
                {
                    CV_DbgAssert( dims >= 3 && data &&
                                  (unsigned)i0 < (unsigned)size.p[0] &&
                                  (unsigned)i1 < (unsigned)size.p[1] &&
                                  (unsigned)i2 < (unsigned)size.p[2] );
                    return data + i0*step.p[0] + i1*step.p[1] + i2*step.p[2];
                }
                
                inline const uchar* Mat::ptr(int i0, int i1, int i2) const
                {
                    CV_DbgAssert( dims >= 3 && data &&
                                  (unsigned)i0 < (unsigned)size.p[0] &&
                                  (unsigned)i1 < (unsigned)size.p[1] &&
                                  (unsigned)i2 < (unsigned)size.p[2] );
                    return data + i0*step.p[0] + i1*step.p[1] + i2*step.p[2];
                }
                
                template<typename _Tp> inline _Tp* Mat::ptr(int i0, int i1, int i2)
                {
                    CV_DbgAssert( dims >= 3 && data &&
                                  (unsigned)i0 < (unsigned)size.p[0] &&
                                  (unsigned)i1 < (unsigned)size.p[1] &&
                                  (unsigned)i2 < (unsigned)size.p[2] );
                    return (_Tp*)(data + i0*step.p[0] + i1*step.p[1] + i2*step.p[2]);
                }
                
                template<typename _Tp> inline const _Tp* Mat::ptr(int i0, int i1, int i2) const
                {
                    CV_DbgAssert( dims >= 3 && data &&
                                  (unsigned)i0 < (unsigned)size.p[0] &&
                                  (unsigned)i1 < (unsigned)size.p[1] &&
                                  (unsigned)i2 < (unsigned)size.p[2] );
                    return (const _Tp*)(data + i0*step.p[0] + i1*step.p[1] + i2*step.p[2]);
                }
                
                inline uchar* Mat::ptr(const int* idx)
                {
                    int i, d = dims;
                    uchar* p = data;
                    CV_DbgAssert( d >= 1 && p );
                    for( i = 0; i < d; i++ )
                    {
                        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
                        p += idx[i]*step.p[i];
                    }
                    return p;
                }
                
                inline const uchar* Mat::ptr(const int* idx) const
                {
                    int i, d = dims;
                    uchar* p = data;
                    CV_DbgAssert( d >= 1 && p );
                    for( i = 0; i < d; i++ )
                    {
                        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
                        p += idx[i]*step.p[i];
                    }
                    return p;
                }
                
                template<typename _Tp> inline _Tp& Mat::at(int i0, int i1)
                {
                    CV_DbgAssert( dims <= 2 && data && (unsigned)i0 < (unsigned)size.p[0] &&
                        (unsigned)(i1*DataType<_Tp>::channels) < (unsigned)(size.p[1]*channels()) &&
                        CV_ELEM_SIZE1(DataType<_Tp>::depth) == elemSize1());
                    return ((_Tp*)(data + step.p[0]*i0))[i1];
                }
                
                template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1) const
                {
                    CV_DbgAssert( dims <= 2 && data && (unsigned)i0 < (unsigned)size.p[0] &&
                        (unsigned)(i1*DataType<_Tp>::channels) < (unsigned)(size.p[1]*channels()) &&
                        CV_ELEM_SIZE1(DataType<_Tp>::depth) == elemSize1());
                    return ((const _Tp*)(data + step.p[0]*i0))[i1];
                }
                
                template<typename _Tp> inline _Tp& Mat::at(Point pt)
                {
                    CV_DbgAssert( dims <= 2 && data && (unsigned)pt.y < (unsigned)size.p[0] &&
                        (unsigned)(pt.x*DataType<_Tp>::channels) < (unsigned)(size.p[1]*channels()) &&
                        CV_ELEM_SIZE1(DataType<_Tp>::depth) == elemSize1());
                    return ((_Tp*)(data + step.p[0]*pt.y))[pt.x];
                }
                
                template<typename _Tp> inline const _Tp& Mat::at(Point pt) const
                {
                    CV_DbgAssert( dims <= 2 && data && (unsigned)pt.y < (unsigned)size.p[0] &&
                        (unsigned)(pt.x*DataType<_Tp>::channels) < (unsigned)(size.p[1]*channels()) &&
                        CV_ELEM_SIZE1(DataType<_Tp>::depth) == elemSize1());
                    return ((const _Tp*)(data + step.p[0]*pt.y))[pt.x];
                }
                
                template<typename _Tp> inline _Tp& Mat::at(int i0)
                {
                    CV_DbgAssert( dims <= 2 && data &&
                                 (unsigned)i0 < (unsigned)(size.p[0]*size.p[1]) &&
                                 elemSize() == CV_ELEM_SIZE(DataType<_Tp>::type) );
                    if( isContinuous() || size.p[0] == 1 )
                        return ((_Tp*)data)[i0];
                    if( size.p[1] == 1 )
                        return *(_Tp*)(data + step.p[0]*i0);
                    int i = i0/cols, j = i0 - i*cols;
                    return ((_Tp*)(data + step.p[0]*i))[j];
                }
                
                template<typename _Tp> inline const _Tp& Mat::at(int i0) const
                {
                    CV_DbgAssert( dims <= 2 && data &&
                                 (unsigned)i0 < (unsigned)(size.p[0]*size.p[1]) &&
                                 elemSize() == CV_ELEM_SIZE(DataType<_Tp>::type) );
                    if( isContinuous() || size.p[0] == 1 )
                        return ((const _Tp*)data)[i0];
                    if( size.p[1] == 1 )
                        return *(const _Tp*)(data + step.p[0]*i0);
                    int i = i0/cols, j = i0 - i*cols;
                    return ((const _Tp*)(data + step.p[0]*i))[j];
                }
                
                template<typename _Tp> inline _Tp& Mat::at(int i0, int i1, int i2)
                {
                    CV_DbgAssert( elemSize() == CV_ELEM_SIZE(DataType<_Tp>::type) );
                    return *(_Tp*)ptr(i0, i1, i2);
                }
                template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1, int i2) const
                {
                    CV_DbgAssert( elemSize() == CV_ELEM_SIZE(DataType<_Tp>::type) );
                    return *(const _Tp*)ptr(i0, i1, i2);
                }
                template<typename _Tp> inline _Tp& Mat::at(const int* idx)
                {
                    CV_DbgAssert( elemSize() == CV_ELEM_SIZE(DataType<_Tp>::type) );
                    return *(_Tp*)ptr(idx);
                }
                template<typename _Tp> inline const _Tp& Mat::at(const int* idx) const
                {
                    CV_DbgAssert( elemSize() == CV_ELEM_SIZE(DataType<_Tp>::type) );
                    return *(const _Tp*)ptr(idx);
                }
                template<typename _Tp, int n> _Tp& Mat::at(const Vec<int, n>& idx)
                {
                    CV_DbgAssert( elemSize() == CV_ELEM_SIZE(DataType<_Tp>::type) );
                    return *(_Tp*)ptr(idx.val);
                }
                template<typename _Tp, int n> inline const _Tp& Mat::at(const Vec<int, n>& idx) const
                {
                    CV_DbgAssert( elemSize() == CV_ELEM_SIZE(DataType<_Tp>::type) );
                    return *(const _Tp*)ptr(idx.val);
                }
                
                
                template<typename _Tp> inline MatConstIterator_<_Tp> Mat::begin() const
                {
                    CV_DbgAssert( elemSize() == sizeof(_Tp) );
                    return MatConstIterator_<_Tp>((const Mat_<_Tp>*)this);
                }
                
                template<typename _Tp> inline MatConstIterator_<_Tp> Mat::end() const
                {
                    CV_DbgAssert( elemSize() == sizeof(_Tp) );
                    MatConstIterator_<_Tp> it((const Mat_<_Tp>*)this);
                    it += total();
                    return it;
                }
                
                template<typename _Tp> inline MatIterator_<_Tp> Mat::begin()
                {
                    CV_DbgAssert( elemSize() == sizeof(_Tp) );
                    return MatIterator_<_Tp>((Mat_<_Tp>*)this);
                }
                
                template<typename _Tp> inline MatIterator_<_Tp> Mat::end()
                {
                    CV_DbgAssert( elemSize() == sizeof(_Tp) );
                    MatIterator_<_Tp> it((Mat_<_Tp>*)this);
                    it += total();
                    return it;
                }
                
                template<typename _Tp> inline Mat::operator vector<_Tp>() const
                {
                    vector<_Tp> v;
                    copyTo(v);
                    return v;
                }
                
                template<typename _Tp, int n> inline Mat::operator Vec<_Tp, n>() const
                {
                    CV_Assert( data && dims <= 2 && (rows == 1 || cols == 1) &&
                               rows + cols - 1 == n && channels() == 1 );
                
                    if( isContinuous() && type() == DataType<_Tp>::type )
                        return Vec<_Tp, n>((_Tp*)data);
                    Vec<_Tp, n> v; Mat tmp(rows, cols, DataType<_Tp>::type, v.val);
                    convertTo(tmp, tmp.type());
                    return v;
                }
                
                template<typename _Tp, int m, int n> inline Mat::operator Matx<_Tp, m, n>() const
                {
                    CV_Assert( data && dims <= 2 && rows == m && cols == n && channels() == 1 );
                
                    if( isContinuous() && type() == DataType<_Tp>::type )
                        return Matx<_Tp, m, n>((_Tp*)data);
                    Matx<_Tp, m, n> mtx; Mat tmp(rows, cols, DataType<_Tp>::type, mtx.val);
                    convertTo(tmp, tmp.type());
                    return mtx;
                }
                
                
                template<typename _Tp> inline void Mat::push_back(const _Tp& elem)
                {
                    if( !data )
                    {
                        CV_Assert((type()==0) || (DataType<_Tp>::type == type()));
                
                        *this = Mat(1, 1, DataType<_Tp>::type, (void*)&elem).clone();
                        return;
                    }
                    CV_Assert(DataType<_Tp>::type == type() && cols == 1
                              /* && dims == 2 (cols == 1 implies dims == 2) */);
                    uchar* tmp = dataend + step[0];
                    if( !isSubmatrix() && isContinuous() && tmp <= datalimit )
                    {
                        *(_Tp*)(data + (size.p[0]++)*step.p[0]) = elem;
                        dataend = tmp;
                    }
                    else
                        push_back_(&elem);
                }
                
                template<typename _Tp> inline void Mat::push_back(const Mat_<_Tp>& m)
                {
                    push_back((const Mat&)m);
                }
                
       12166 -> inline Mat::MSize::MSize(int* _p) : p(_p) {}
                inline Size Mat::MSize::operator()() const
                {
                    CV_DbgAssert(p[-1] <= 2);
                    return Size(p[1], p[0]);
                }
       ##### -> inline const int& Mat::MSize::operator[](int i) const { return p[i]; }
                inline int& Mat::MSize::operator[](int i) { return p[i]; }
                inline Mat::MSize::operator const int*() const { return p; }
                
                inline bool Mat::MSize::operator == (const MSize& sz) const
                {
                    int d = p[-1], dsz = sz.p[-1];
                    if( d != dsz )
                        return false;
                    if( d == 2 )
                        return p[0] == sz.p[0] && p[1] == sz.p[1];
                
                    for( int i = 0; i < d; i++ )
                        if( p[i] != sz.p[i] )
                            return false;
                    return true;
                }
                
                inline bool Mat::MSize::operator != (const MSize& sz) const
                {
                    return !(*this == sz);
                }
                
       12166 -> inline Mat::MStep::MStep() { p = buf; p[0] = p[1] = 0; }
                inline Mat::MStep::MStep(size_t s) { p = buf; p[0] = s; p[1] = 0; }
       10418 -> inline const size_t& Mat::MStep::operator[](int i) const { return p[i]; }
       10418 -> inline size_t& Mat::MStep::operator[](int i) { return p[i]; }
                inline Mat::MStep::operator size_t() const
                {
                    CV_DbgAssert( p == buf );
                    return buf[0];
                }
                inline Mat::MStep& Mat::MStep::operator = (size_t s)
                {
                    CV_DbgAssert( p == buf );
                    buf[0] = s;
                    return *this;
                }
                
                static inline Mat cvarrToMatND(const CvArr* arr, bool copyData=false, int coiMode=0)
                {
                    return cvarrToMat(arr, copyData, true, coiMode);
                }
                
                ///////////////////////////////////////////// SVD //////////////////////////////////////////////////////
                
                inline SVD::SVD() {}
                inline SVD::SVD( InputArray m, int flags ) { operator ()(m, flags); }
                inline void SVD::solveZ( InputArray m, OutputArray _dst )
                {
                    Mat mtx = m.getMat();
                    SVD svd(mtx, (mtx.rows >= mtx.cols ? 0 : SVD::FULL_UV));
                    _dst.create(svd.vt.cols, 1, svd.vt.type());
                    Mat dst = _dst.getMat();
                    svd.vt.row(svd.vt.rows-1).reshape(1,svd.vt.cols).copyTo(dst);
                }
                
                template<typename _Tp, int m, int n, int nm> inline void
                    SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
                {
                    assert( nm == MIN(m, n));
                    Mat _a(a, false), _u(u, false), _w(w, false), _vt(vt, false);
                    SVD::compute(_a, _w, _u, _vt);
                    CV_Assert(_w.data == (uchar*)&w.val[0] && _u.data == (uchar*)&u.val[0] && _vt.data == (uchar*)&vt.val[0]);
                }
                
                template<typename _Tp, int m, int n, int nm> inline void
                SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
                {
                    assert( nm == MIN(m, n));
                    Mat _a(a, false), _w(w, false);
                    SVD::compute(_a, _w);
                    CV_Assert(_w.data == (uchar*)&w.val[0]);
                }
                
                template<typename _Tp, int m, int n, int nm, int nb> inline void
                SVD::backSubst( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u,
                                const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs,
                                Matx<_Tp, n, nb>& dst )
                {
                    assert( nm == MIN(m, n));
                    Mat _u(u, false), _w(w, false), _vt(vt, false), _rhs(rhs, false), _dst(dst, false);
                    SVD::backSubst(_w, _u, _vt, _rhs, _dst);
                    CV_Assert(_dst.data == (uchar*)&dst.val[0]);
                }
                
                ///////////////////////////////// Mat_<_Tp> ////////////////////////////////////
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_()
                    : Mat() { flags = (flags & ~CV_MAT_TYPE_MASK) | DataType<_Tp>::type; }
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols)
                    : Mat(_rows, _cols, DataType<_Tp>::type) {}
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, const _Tp& value)
                    : Mat(_rows, _cols, DataType<_Tp>::type) { *this = value; }
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz)
                    : Mat(_sz.height, _sz.width, DataType<_Tp>::type) {}
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz, const _Tp& value)
                    : Mat(_sz.height, _sz.width, DataType<_Tp>::type) { *this = value; }
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz)
                    : Mat(_dims, _sz, DataType<_Tp>::type) {}
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz, const _Tp& _s)
                    : Mat(_dims, _sz, DataType<_Tp>::type, Scalar(_s)) {}
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const Range* ranges)
                    : Mat(m, ranges) {}
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat& m)
                    : Mat() { flags = (flags & ~CV_MAT_TYPE_MASK) | DataType<_Tp>::type; *this = m; }
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m)
                    : Mat(m) {}
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, _Tp* _data, size_t steps)
                    : Mat(_rows, _cols, DataType<_Tp>::type, _data, steps) {}
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Range& _rowRange, const Range& _colRange)
                    : Mat(m, _rowRange, _colRange) {}
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Rect& roi)
                    : Mat(m, roi) {}
                
                template<typename _Tp> template<int n> inline
                    Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
                    : Mat(n/DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&vec)
                {
                    CV_Assert(n%DataType<_Tp>::channels == 0);
                    if( copyData )
                        *this = clone();
                }
                
                template<typename _Tp> template<int m, int n> inline
                    Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)
                    : Mat(m, n/DataType<_Tp>::channels, DataType<_Tp>::type, (void*)&M)
                {
                    CV_Assert(n % DataType<_Tp>::channels == 0);
                    if( copyData )
                        *this = clone();
                }
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
                    : Mat(2/DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&pt)
                {
                    CV_Assert(2 % DataType<_Tp>::channels == 0);
                    if( copyData )
                        *this = clone();
                }
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
                    : Mat(3/DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&pt)
                {
                    CV_Assert(3 % DataType<_Tp>::channels == 0);
                    if( copyData )
                        *this = clone();
                }
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatCommaInitializer_<_Tp>& commaInitializer)
                    : Mat(commaInitializer) {}
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const vector<_Tp>& vec, bool copyData)
                    : Mat(vec, copyData) {}
                
                template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat& m)
                {
                    if( DataType<_Tp>::type == m.type() )
                    {
                        Mat::operator = (m);
                        return *this;
                    }
                    if( DataType<_Tp>::depth == m.depth() )
                    {
                        return (*this = m.reshape(DataType<_Tp>::channels, m.dims, 0));
                    }
                    CV_DbgAssert(DataType<_Tp>::channels == m.channels());
                    m.convertTo(*this, type());
                    return *this;
                }
                
                template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat_& m)
                {
                    Mat::operator=(m);
                    return *this;
                }
                
                template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const _Tp& s)
                {
                    typedef typename DataType<_Tp>::vec_type VT;
                    Mat::operator=(Scalar((const VT&)s));
                    return *this;
                }
                
                template<typename _Tp> inline void Mat_<_Tp>::create(int _rows, int _cols)
                {
                    Mat::create(_rows, _cols, DataType<_Tp>::type);
                }
                
                template<typename _Tp> inline void Mat_<_Tp>::create(Size _sz)
                {
                    Mat::create(_sz, DataType<_Tp>::type);
                }
                
                template<typename _Tp> inline void Mat_<_Tp>::create(int _dims, const int* _sz)
                {
                    Mat::create(_dims, _sz, DataType<_Tp>::type);
                }
                
                
                template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::cross(const Mat_& m) const
                { return Mat_<_Tp>(Mat::cross(m)); }
                
                template<typename _Tp> template<typename T2> inline Mat_<_Tp>::operator Mat_<T2>() const
                { return Mat_<T2>(*this); }
                
                template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::row(int y) const
                { return Mat_(*this, Range(y, y+1), Range::all()); }
                template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::col(int x) const
                { return Mat_(*this, Range::all(), Range(x, x+1)); }
                template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::diag(int d) const
                { return Mat_(Mat::diag(d)); }
                template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::clone() const
                { return Mat_(Mat::clone()); }
                
                template<typename _Tp> inline size_t Mat_<_Tp>::elemSize() const
                {
                    CV_DbgAssert( Mat::elemSize() == sizeof(_Tp) );
                    return sizeof(_Tp);
                }
                
                template<typename _Tp> inline size_t Mat_<_Tp>::elemSize1() const
                {
                    CV_DbgAssert( Mat::elemSize1() == sizeof(_Tp)/DataType<_Tp>::channels );
                    return sizeof(_Tp)/DataType<_Tp>::channels;
                }
                template<typename _Tp> inline int Mat_<_Tp>::type() const
                {
                    CV_DbgAssert( Mat::type() == DataType<_Tp>::type );
                    return DataType<_Tp>::type;
                }
                template<typename _Tp> inline int Mat_<_Tp>::depth() const
                {
                    CV_DbgAssert( Mat::depth() == DataType<_Tp>::depth );
                    return DataType<_Tp>::depth;
                }
                template<typename _Tp> inline int Mat_<_Tp>::channels() const
                {
                    CV_DbgAssert( Mat::channels() == DataType<_Tp>::channels );
                    return DataType<_Tp>::channels;
                }
                template<typename _Tp> inline size_t Mat_<_Tp>::stepT(int i) const { return step.p[i]/elemSize(); }
                template<typename _Tp> inline size_t Mat_<_Tp>::step1(int i) const { return step.p[i]/elemSize1(); }
                
                template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::adjustROI( int dtop, int dbottom, int dleft, int dright )
                { return (Mat_<_Tp>&)(Mat::adjustROI(dtop, dbottom, dleft, dright));  }
                
                template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range& _rowRange, const Range& _colRange ) const
                { return Mat_<_Tp>(*this, _rowRange, _colRange); }
                
                template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Rect& roi ) const
                { return Mat_<_Tp>(*this, roi); }
                
                template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range* ranges ) const
                { return Mat_<_Tp>(*this, ranges); }
                
                template<typename _Tp> inline _Tp* Mat_<_Tp>::operator [](int y)
                { return (_Tp*)ptr(y); }
                template<typename _Tp> inline const _Tp* Mat_<_Tp>::operator [](int y) const
                { return (const _Tp*)ptr(y); }
                
                template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1)
                {
                    CV_DbgAssert( dims <= 2 && data &&
                                  (unsigned)i0 < (unsigned)size.p[0] &&
                                  (unsigned)i1 < (unsigned)size.p[1] &&
                                  type() == DataType<_Tp>::type );
                    return ((_Tp*)(data + step.p[0]*i0))[i1];
                }
                
                template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1) const
                {
                    CV_DbgAssert( dims <= 2 && data &&
                                  (unsigned)i0 < (unsigned)size.p[0] &&
                                  (unsigned)i1 < (unsigned)size.p[1] &&
                                  type() == DataType<_Tp>::type );
                    return ((const _Tp*)(data + step.p[0]*i0))[i1];
                }
                
                template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(Point pt)
                {
                    CV_DbgAssert( dims <= 2 && data &&
                                  (unsigned)pt.y < (unsigned)size.p[0] &&
                                  (unsigned)pt.x < (unsigned)size.p[1] &&
                                  type() == DataType<_Tp>::type );
                    return ((_Tp*)(data + step.p[0]*pt.y))[pt.x];
                }
                
                template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(Point pt) const
                {
                    CV_DbgAssert( dims <= 2 && data &&
                                  (unsigned)pt.y < (unsigned)size.p[0] &&
                                  (unsigned)pt.x < (unsigned)size.p[1] &&
                                 type() == DataType<_Tp>::type );
                    return ((const _Tp*)(data + step.p[0]*pt.y))[pt.x];
                }
                
                template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(const int* idx)
                {
                    return Mat::at<_Tp>(idx);
                }
                
                template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(const int* idx) const
                {
                    return Mat::at<_Tp>(idx);
                }
                
                template<typename _Tp> template<int n> inline _Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx)
                {
                    return Mat::at<_Tp>(idx);
                }
                
                template<typename _Tp> template<int n> inline const _Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx) const
                {
                    return Mat::at<_Tp>(idx);
                }
                
                template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0)
                {
                    return this->at<_Tp>(i0);
                }
                
                template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0) const
                {
                    return this->at<_Tp>(i0);
                }
                
                template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2)
                {
                    return this->at<_Tp>(i0, i1, i2);
                }
                
                template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2) const
                {
                    return this->at<_Tp>(i0, i1, i2);
                }
                
                
                template<typename _Tp> inline Mat_<_Tp>::operator vector<_Tp>() const
                {
                    vector<_Tp> v;
                    copyTo(v);
                    return v;
                }
                
                template<typename _Tp> template<int n> inline Mat_<_Tp>::operator Vec<typename DataType<_Tp>::channel_type, n>() const
                {
                    CV_Assert(n % DataType<_Tp>::channels == 0);
                    return this->Mat::operator Vec<typename DataType<_Tp>::channel_type, n>();
                }
                
                template<typename _Tp> template<int m, int n> inline Mat_<_Tp>::operator Matx<typename DataType<_Tp>::channel_type, m, n>() const
                {
                    CV_Assert(n % DataType<_Tp>::channels == 0);
                
                    Matx<typename DataType<_Tp>::channel_type, m, n> res = this->Mat::operator Matx<typename DataType<_Tp>::channel_type, m, n>();
                    return res;
                }
                
                template<typename T1, typename T2, typename Op> inline void
                process( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )
                {
                    int y, x, rows = m1.rows, cols = m1.cols;
                
                    CV_DbgAssert( m1.size() == m2.size() );
                
                    for( y = 0; y < rows; y++ )
                    {
                        const T1* src = m1[y];
                        T2* dst = m2[y];
                
                        for( x = 0; x < cols; x++ )
                            dst[x] = op(src[x]);
                    }
                }
                
                template<typename T1, typename T2, typename T3, typename Op> inline void
                process( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )
                {
                    int y, x, rows = m1.rows, cols = m1.cols;
                
                    CV_DbgAssert( m1.size() == m2.size() );
                
                    for( y = 0; y < rows; y++ )
                    {
                        const T1* src1 = m1[y];
                        const T2* src2 = m2[y];
                        T3* dst = m3[y];
                
                        for( x = 0; x < cols; x++ )
                            dst[x] = op( src1[x], src2[x] );
                    }
                }
                
                
                /////////////////////////////// Input/Output Arrays /////////////////////////////////
                
        7538 -> template<typename _Tp> inline _InputArray::_InputArray(const vector<_Tp>& vec)
                    : flags(FIXED_TYPE + STD_VECTOR + DataType<_Tp>::type), obj((void*)&vec) {}
                
         844 -> template<typename _Tp> inline _InputArray::_InputArray(const vector<vector<_Tp> >& vec)
                    : flags(FIXED_TYPE + STD_VECTOR_VECTOR + DataType<_Tp>::type), obj((void*)&vec) {}
                
                template<typename _Tp> inline _InputArray::_InputArray(const vector<Mat_<_Tp> >& vec)
                    : flags(FIXED_TYPE + STD_VECTOR_MAT + DataType<_Tp>::type), obj((void*)&vec) {}
                
                template<typename _Tp, int m, int n> inline _InputArray::_InputArray(const Matx<_Tp, m, n>& mtx)
                    : flags(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type), obj((void*)&mtx), sz(n, m) {}
                
                template<typename _Tp> inline _InputArray::_InputArray(const _Tp* vec, int n)
                    : flags(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type), obj((void*)vec), sz(n, 1) {}
                
                inline _InputArray::_InputArray(const Scalar& s)
                    : flags(FIXED_TYPE + FIXED_SIZE + MATX + CV_64F), obj((void*)&s), sz(1, 4) {}
                
                template<typename _Tp> inline _InputArray::_InputArray(const Mat_<_Tp>& m)
                    : flags(FIXED_TYPE + MAT + DataType<_Tp>::type), obj((void*)&m) {}
                
        1717 -> template<typename _Tp> inline _OutputArray::_OutputArray(vector<_Tp>& vec)
                    : _InputArray(vec) {}
         844 -> template<typename _Tp> inline _OutputArray::_OutputArray(vector<vector<_Tp> >& vec)
                    : _InputArray(vec) {}
                template<typename _Tp> inline _OutputArray::_OutputArray(vector<Mat_<_Tp> >& vec)
                    : _InputArray(vec) {}
                template<typename _Tp> inline _OutputArray::_OutputArray(Mat_<_Tp>& m)
                    : _InputArray(m) {}
                template<typename _Tp, int m, int n> inline _OutputArray::_OutputArray(Matx<_Tp, m, n>& mtx)
                    : _InputArray(mtx) {}
                template<typename _Tp> inline _OutputArray::_OutputArray(_Tp* vec, int n)
                    : _InputArray(vec, n) {}
                
                template<typename _Tp> inline _OutputArray::_OutputArray(const vector<_Tp>& vec)
                    : _InputArray(vec) {flags |= FIXED_SIZE;}
                template<typename _Tp> inline _OutputArray::_OutputArray(const vector<vector<_Tp> >& vec)
                    : _InputArray(vec) {flags |= FIXED_SIZE;}
                template<typename _Tp> inline _OutputArray::_OutputArray(const vector<Mat_<_Tp> >& vec)
                    : _InputArray(vec) {flags |= FIXED_SIZE;}
                
                template<typename _Tp> inline _OutputArray::_OutputArray(const Mat_<_Tp>& m)
                    : _InputArray(m) {flags |= FIXED_SIZE;}
                template<typename _Tp, int m, int n> inline _OutputArray::_OutputArray(const Matx<_Tp, m, n>& mtx)
                    : _InputArray(mtx) {}
                template<typename _Tp> inline _OutputArray::_OutputArray(const _Tp* vec, int n)
                    : _InputArray(vec, n) {}
                
                //////////////////////////////////// Matrix Expressions /////////////////////////////////////////
                
                class CV_EXPORTS MatOp
                {
                public:
                    MatOp() {};
                    virtual ~MatOp() {};
                
                    virtual bool elementWise(const MatExpr& expr) const;
                    virtual void assign(const MatExpr& expr, Mat& m, int type=-1) const = 0;
                    virtual void roi(const MatExpr& expr, const Range& rowRange,
                                     const Range& colRange, MatExpr& res) const;
                    virtual void diag(const MatExpr& expr, int d, MatExpr& res) const;
                    virtual void augAssignAdd(const MatExpr& expr, Mat& m) const;
                    virtual void augAssignSubtract(const MatExpr& expr, Mat& m) const;
                    virtual void augAssignMultiply(const MatExpr& expr, Mat& m) const;
                    virtual void augAssignDivide(const MatExpr& expr, Mat& m) const;
                    virtual void augAssignAnd(const MatExpr& expr, Mat& m) const;
                    virtual void augAssignOr(const MatExpr& expr, Mat& m) const;
                    virtual void augAssignXor(const MatExpr& expr, Mat& m) const;
                
                    virtual void add(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
                    virtual void add(const MatExpr& expr1, const Scalar& s, MatExpr& res) const;
                
                    virtual void subtract(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
                    virtual void subtract(const Scalar& s, const MatExpr& expr, MatExpr& res) const;
                
                    virtual void multiply(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;
                    virtual void multiply(const MatExpr& expr1, double s, MatExpr& res) const;
                
                    virtual void divide(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;
                    virtual void divide(double s, const MatExpr& expr, MatExpr& res) const;
                
                    virtual void abs(const MatExpr& expr, MatExpr& res) const;
                
                    virtual void transpose(const MatExpr& expr, MatExpr& res) const;
                    virtual void matmul(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
                    virtual void invert(const MatExpr& expr, int method, MatExpr& res) const;
                
                    virtual Size size(const MatExpr& expr) const;
                    virtual int type(const MatExpr& expr) const;
                };
                
                
                class CV_EXPORTS MatExpr
                {
                public:
                    MatExpr() : op(0), flags(0), a(Mat()), b(Mat()), c(Mat()), alpha(0), beta(0), s(Scalar()) {}
                    MatExpr(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(),
                            const Mat& _c=Mat(), double _alpha=1, double _beta=1, const Scalar& _s=Scalar())
                        : op(_op), flags(_flags), a(_a), b(_b), c(_c), alpha(_alpha), beta(_beta), s(_s) {}
                    explicit MatExpr(const Mat& m);
                    operator Mat() const
                    {
                        Mat m;
                        op->assign(*this, m);
                        return m;
                    }
                
                    template<typename _Tp> operator Mat_<_Tp>() const
                    {
                        Mat_<_Tp> m;
                        op->assign(*this, m, DataType<_Tp>::type);
                        return m;
                    }
                
                    MatExpr row(int y) const;
                    MatExpr col(int x) const;
                    MatExpr diag(int d=0) const;
                    MatExpr operator()( const Range& rowRange, const Range& colRange ) const;
                    MatExpr operator()( const Rect& roi ) const;
                
                    Mat cross(const Mat& m) const;
                    double dot(const Mat& m) const;
                
                    MatExpr t() const;
                    MatExpr inv(int method = DECOMP_LU) const;
                    MatExpr mul(const MatExpr& e, double scale=1) const;
                    MatExpr mul(const Mat& m, double scale=1) const;
                
                    Size size() const;
                    int type() const;
                
                    const MatOp* op;
                    int flags;
                
                    Mat a, b, c;
                    double alpha, beta;
                    Scalar s;
                };
                
                
                CV_EXPORTS MatExpr operator + (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator + (const Mat& a, const Scalar& s);
                CV_EXPORTS MatExpr operator + (const Scalar& s, const Mat& a);
                CV_EXPORTS MatExpr operator + (const MatExpr& e, const Mat& m);
                CV_EXPORTS MatExpr operator + (const Mat& m, const MatExpr& e);
                CV_EXPORTS MatExpr operator + (const MatExpr& e, const Scalar& s);
                CV_EXPORTS MatExpr operator + (const Scalar& s, const MatExpr& e);
                CV_EXPORTS MatExpr operator + (const MatExpr& e1, const MatExpr& e2);
                
                CV_EXPORTS MatExpr operator - (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator - (const Mat& a, const Scalar& s);
                CV_EXPORTS MatExpr operator - (const Scalar& s, const Mat& a);
                CV_EXPORTS MatExpr operator - (const MatExpr& e, const Mat& m);
                CV_EXPORTS MatExpr operator - (const Mat& m, const MatExpr& e);
                CV_EXPORTS MatExpr operator - (const MatExpr& e, const Scalar& s);
                CV_EXPORTS MatExpr operator - (const Scalar& s, const MatExpr& e);
                CV_EXPORTS MatExpr operator - (const MatExpr& e1, const MatExpr& e2);
                
                CV_EXPORTS MatExpr operator - (const Mat& m);
                CV_EXPORTS MatExpr operator - (const MatExpr& e);
                
                CV_EXPORTS MatExpr operator * (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator * (const Mat& a, double s);
                CV_EXPORTS MatExpr operator * (double s, const Mat& a);
                CV_EXPORTS MatExpr operator * (const MatExpr& e, const Mat& m);
                CV_EXPORTS MatExpr operator * (const Mat& m, const MatExpr& e);
                CV_EXPORTS MatExpr operator * (const MatExpr& e, double s);
                CV_EXPORTS MatExpr operator * (double s, const MatExpr& e);
                CV_EXPORTS MatExpr operator * (const MatExpr& e1, const MatExpr& e2);
                
                CV_EXPORTS MatExpr operator / (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator / (const Mat& a, double s);
                CV_EXPORTS MatExpr operator / (double s, const Mat& a);
                CV_EXPORTS MatExpr operator / (const MatExpr& e, const Mat& m);
                CV_EXPORTS MatExpr operator / (const Mat& m, const MatExpr& e);
                CV_EXPORTS MatExpr operator / (const MatExpr& e, double s);
                CV_EXPORTS MatExpr operator / (double s, const MatExpr& e);
                CV_EXPORTS MatExpr operator / (const MatExpr& e1, const MatExpr& e2);
                
                CV_EXPORTS MatExpr operator < (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator < (const Mat& a, double s);
                CV_EXPORTS MatExpr operator < (double s, const Mat& a);
                
                CV_EXPORTS MatExpr operator <= (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator <= (const Mat& a, double s);
                CV_EXPORTS MatExpr operator <= (double s, const Mat& a);
                
                CV_EXPORTS MatExpr operator == (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator == (const Mat& a, double s);
                CV_EXPORTS MatExpr operator == (double s, const Mat& a);
                
                CV_EXPORTS MatExpr operator != (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator != (const Mat& a, double s);
                CV_EXPORTS MatExpr operator != (double s, const Mat& a);
                
                CV_EXPORTS MatExpr operator >= (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator >= (const Mat& a, double s);
                CV_EXPORTS MatExpr operator >= (double s, const Mat& a);
                
                CV_EXPORTS MatExpr operator > (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator > (const Mat& a, double s);
                CV_EXPORTS MatExpr operator > (double s, const Mat& a);
                
                CV_EXPORTS MatExpr min(const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr min(const Mat& a, double s);
                CV_EXPORTS MatExpr min(double s, const Mat& a);
                
                CV_EXPORTS MatExpr max(const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr max(const Mat& a, double s);
                CV_EXPORTS MatExpr max(double s, const Mat& a);
                
                template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
                {
                    return cv::min((const Mat&)a, (const Mat&)b);
                }
                
                template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, double s)
                {
                    return cv::min((const Mat&)a, s);
                }
                
                template<typename _Tp> static inline MatExpr min(double s, const Mat_<_Tp>& a)
                {
                    return cv::min((const Mat&)a, s);
                }
                
                template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
                {
                    return cv::max((const Mat&)a, (const Mat&)b);
                }
                
                template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, double s)
                {
                    return cv::max((const Mat&)a, s);
                }
                
                template<typename _Tp> static inline MatExpr max(double s, const Mat_<_Tp>& a)
                {
                    return cv::max((const Mat&)a, s);
                }
                
                template<typename _Tp> static inline void min(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)
                {
                    cv::min((const Mat&)a, (const Mat&)b, (Mat&)c);
                }
                
                template<typename _Tp> static inline void min(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)
                {
                    cv::min((const Mat&)a, s, (Mat&)c);
                }
                
                template<typename _Tp> static inline void min(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)
                {
                    cv::min((const Mat&)a, s, (Mat&)c);
                }
                
                template<typename _Tp> static inline void max(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)
                {
                    cv::max((const Mat&)a, (const Mat&)b, (Mat&)c);
                }
                
                template<typename _Tp> static inline void max(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)
                {
                    cv::max((const Mat&)a, s, (Mat&)c);
                }
                
                template<typename _Tp> static inline void max(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)
                {
                    cv::max((const Mat&)a, s, (Mat&)c);
                }
                
                
                CV_EXPORTS MatExpr operator & (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator & (const Mat& a, const Scalar& s);
                CV_EXPORTS MatExpr operator & (const Scalar& s, const Mat& a);
                
                CV_EXPORTS MatExpr operator | (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator | (const Mat& a, const Scalar& s);
                CV_EXPORTS MatExpr operator | (const Scalar& s, const Mat& a);
                
                CV_EXPORTS MatExpr operator ^ (const Mat& a, const Mat& b);
                CV_EXPORTS MatExpr operator ^ (const Mat& a, const Scalar& s);
                CV_EXPORTS MatExpr operator ^ (const Scalar& s, const Mat& a);
                
                CV_EXPORTS MatExpr operator ~(const Mat& m);
                
                CV_EXPORTS MatExpr abs(const Mat& m);
                CV_EXPORTS MatExpr abs(const MatExpr& e);
                
                template<typename _Tp> static inline MatExpr abs(const Mat_<_Tp>& m)
                {
                    return cv::abs((const Mat&)m);
                }
                
                ////////////////////////////// Augmenting algebraic operations //////////////////////////////////
                
                inline Mat& Mat::operator = (const MatExpr& e)
                {
                    e.op->assign(e, *this);
                    return *this;
                }
                
                template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatExpr& e)
                {
                    e.op->assign(e, *this, DataType<_Tp>::type);
                }
                
                template<typename _Tp> Mat_<_Tp>& Mat_<_Tp>::operator = (const MatExpr& e)
                {
                    e.op->assign(e, *this, DataType<_Tp>::type);
                    return *this;
                }
                
                static inline Mat& operator += (const Mat& a, const Mat& b)
                {
                    add(a, b, (Mat&)a);
                    return (Mat&)a;
                }
                
                static inline Mat& operator += (const Mat& a, const Scalar& s)
                {
                    add(a, s, (Mat&)a);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
                {
                    add(a, b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Scalar& s)
                {
                    add(a, s, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                static inline Mat& operator += (const Mat& a, const MatExpr& b)
                {
                    b.op->augAssignAdd(b, (Mat&)a);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const MatExpr& b)
                {
                    b.op->augAssignAdd(b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                static inline Mat& operator -= (const Mat& a, const Mat& b)
                {
                    subtract(a, b, (Mat&)a);
                    return (Mat&)a;
                }
                
                static inline Mat& operator -= (const Mat& a, const Scalar& s)
                {
                    subtract(a, s, (Mat&)a);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
                {
                    subtract(a, b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Scalar& s)
                {
                    subtract(a, s, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                static inline Mat& operator -= (const Mat& a, const MatExpr& b)
                {
                    b.op->augAssignSubtract(b, (Mat&)a);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const MatExpr& b)
                {
                    b.op->augAssignSubtract(b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                static inline Mat& operator *= (const Mat& a, const Mat& b)
                {
                    gemm(a, b, 1, Mat(), 0, (Mat&)a, 0);
                    return (Mat&)a;
                }
                
                static inline Mat& operator *= (const Mat& a, double s)
                {
                    a.convertTo((Mat&)a, -1, s);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
                {
                    gemm(a, b, 1, Mat(), 0, (Mat&)a, 0);
                    return (Mat_<_Tp>&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, double s)
                {
                    a.convertTo((Mat&)a, -1, s);
                    return (Mat_<_Tp>&)a;
                }
                
                static inline Mat& operator *= (const Mat& a, const MatExpr& b)
                {
                    b.op->augAssignMultiply(b, (Mat&)a);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const MatExpr& b)
                {
                    b.op->augAssignMultiply(b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                static inline Mat& operator /= (const Mat& a, const Mat& b)
                {
                    divide(a, b, (Mat&)a);
                    return (Mat&)a;
                }
                
                static inline Mat& operator /= (const Mat& a, double s)
                {
                    a.convertTo((Mat&)a, -1, 1./s);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
                {
                    divide(a, b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, double s)
                {
                    a.convertTo((Mat&)a, -1, 1./s);
                    return (Mat_<_Tp>&)a;
                }
                
                static inline Mat& operator /= (const Mat& a, const MatExpr& b)
                {
                    b.op->augAssignDivide(b, (Mat&)a);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline
                Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const MatExpr& b)
                {
                    b.op->augAssignDivide(b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                ////////////////////////////// Logical operations ///////////////////////////////
                
                static inline Mat& operator &= (const Mat& a, const Mat& b)
                {
                    bitwise_and(a, b, (Mat&)a);
                    return (Mat&)a;
                }
                
                static inline Mat& operator &= (const Mat& a, const Scalar& s)
                {
                    bitwise_and(a, s, (Mat&)a);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline Mat_<_Tp>&
                operator &= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
                {
                    bitwise_and(a, b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                template<typename _Tp> static inline Mat_<_Tp>&
                operator &= (const Mat_<_Tp>& a, const Scalar& s)
                {
                    bitwise_and(a, s, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                static inline Mat& operator |= (const Mat& a, const Mat& b)
                {
                    bitwise_or(a, b, (Mat&)a);
                    return (Mat&)a;
                }
                
                static inline Mat& operator |= (const Mat& a, const Scalar& s)
                {
                    bitwise_or(a, s, (Mat&)a);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline Mat_<_Tp>&
                operator |= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
                {
                    bitwise_or(a, b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                template<typename _Tp> static inline Mat_<_Tp>&
                operator |= (const Mat_<_Tp>& a, const Scalar& s)
                {
                    bitwise_or(a, s, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                static inline Mat& operator ^= (const Mat& a, const Mat& b)
                {
                    bitwise_xor(a, b, (Mat&)a);
                    return (Mat&)a;
                }
                
                static inline Mat& operator ^= (const Mat& a, const Scalar& s)
                {
                    bitwise_xor(a, s, (Mat&)a);
                    return (Mat&)a;
                }
                
                template<typename _Tp> static inline Mat_<_Tp>&
                operator ^= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)
                {
                    bitwise_xor(a, b, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                template<typename _Tp> static inline Mat_<_Tp>&
                operator ^= (const Mat_<_Tp>& a, const Scalar& s)
                {
                    bitwise_xor(a, s, (Mat&)a);
                    return (Mat_<_Tp>&)a;
                }
                
                /////////////////////////////// Miscellaneous operations //////////////////////////////
                
                template<typename _Tp> void split(const Mat& src, vector<Mat_<_Tp> >& mv)
                { split(src, (vector<Mat>&)mv ); }
                
                //////////////////////////////////////////////////////////////
                
                template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(int rows, int cols)
                {
                    return Mat::zeros(rows, cols, DataType<_Tp>::type);
                }
                
                template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(Size sz)
                {
                    return Mat::zeros(sz, DataType<_Tp>::type);
                }
                
                template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(int rows, int cols)
                {
                    return Mat::ones(rows, cols, DataType<_Tp>::type);
                }
                
                template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(Size sz)
                {
                    return Mat::ones(sz, DataType<_Tp>::type);
                }
                
                template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(int rows, int cols)
                {
                    return Mat::eye(rows, cols, DataType<_Tp>::type);
                }
                
                template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(Size sz)
                {
                    return Mat::eye(sz, DataType<_Tp>::type);
                }
                
                //////////////////////////////// Iterators & Comma initializers //////////////////////////////////
                
                inline MatConstIterator::MatConstIterator()
                    : m(0), elemSize(0), ptr(0), sliceStart(0), sliceEnd(0) {}
                
                inline MatConstIterator::MatConstIterator(const Mat* _m)
                    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
                {
                    if( m && m->isContinuous() )
                    {
                        sliceStart = m->data;
                        sliceEnd = sliceStart + m->total()*elemSize;
                    }
                    seek((const int*)0);
                }
                
                inline MatConstIterator::MatConstIterator(const Mat* _m, int _row, int _col)
                    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
                {
                    CV_Assert(m && m->dims <= 2);
                    if( m->isContinuous() )
                    {
                        sliceStart = m->data;
                        sliceEnd = sliceStart + m->total()*elemSize;
                    }
                    int idx[]={_row, _col};
                    seek(idx);
                }
                
                inline MatConstIterator::MatConstIterator(const Mat* _m, Point _pt)
                    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
                {
                    CV_Assert(m && m->dims <= 2);
                    if( m->isContinuous() )
                    {
                        sliceStart = m->data;
                        sliceEnd = sliceStart + m->total()*elemSize;
                    }
                    int idx[]={_pt.y, _pt.x};
                    seek(idx);
                }
                
                inline MatConstIterator::MatConstIterator(const MatConstIterator& it)
                    : m(it.m), elemSize(it.elemSize), ptr(it.ptr), sliceStart(it.sliceStart), sliceEnd(it.sliceEnd)
                {}
                
                inline MatConstIterator& MatConstIterator::operator = (const MatConstIterator& it )
                {
                    m = it.m; elemSize = it.elemSize; ptr = it.ptr;
                    sliceStart = it.sliceStart; sliceEnd = it.sliceEnd;
                    return *this;
                }
                
                inline uchar* MatConstIterator::operator *() const { return ptr; }
                
                inline MatConstIterator& MatConstIterator::operator += (ptrdiff_t ofs)
                {
                    if( !m || ofs == 0 )
                        return *this;
                    ptrdiff_t ofsb = ofs*elemSize;
                    ptr += ofsb;
                    if( ptr < sliceStart || sliceEnd <= ptr )
                    {
                        ptr -= ofsb;
                        seek(ofs, true);
                    }
                    return *this;
                }
                
                inline MatConstIterator& MatConstIterator::operator -= (ptrdiff_t ofs)
                { return (*this += -ofs); }
                
                inline MatConstIterator& MatConstIterator::operator --()
                {
                    if( m && (ptr -= elemSize) < sliceStart )
                    {
                        ptr += elemSize;
                        seek(-1, true);
                    }
                    return *this;
                }
                
                inline MatConstIterator MatConstIterator::operator --(int)
                {
                    MatConstIterator b = *this;
                    *this += -1;
                    return b;
                }
                
                inline MatConstIterator& MatConstIterator::operator ++()
                {
                    if( m && (ptr += elemSize) >= sliceEnd )
                    {
                        ptr -= elemSize;
                        seek(1, true);
                    }
                    return *this;
                }
                
                inline MatConstIterator MatConstIterator::operator ++(int)
                {
                    MatConstIterator b = *this;
                    *this += 1;
                    return b;
                }
                
                template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_() {}
                
                template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m)
                    : MatConstIterator(_m) {}
                
                template<typename _Tp> inline MatConstIterator_<_Tp>::
                    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col)
                    : MatConstIterator(_m, _row, _col) {}
                
                template<typename _Tp> inline MatConstIterator_<_Tp>::
                    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt)
                    : MatConstIterator(_m, _pt) {}
                
                template<typename _Tp> inline MatConstIterator_<_Tp>::
                    MatConstIterator_(const MatConstIterator_& it)
                    : MatConstIterator(it) {}
                
                template<typename _Tp> inline MatConstIterator_<_Tp>&
                    MatConstIterator_<_Tp>::operator = (const MatConstIterator_& it )
                {
                    MatConstIterator::operator = (it);
                    return *this;
                }
                
                template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }
                
                template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator += (ptrdiff_t ofs)
                {
                    MatConstIterator::operator += (ofs);
                    return *this;
                }
                
                template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator -= (ptrdiff_t ofs)
                { return (*this += -ofs); }
                
                template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator --()
                {
                    MatConstIterator::operator --();
                    return *this;
                }
                
                template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator --(int)
                {
                    MatConstIterator_ b = *this;
                    MatConstIterator::operator --();
                    return b;
                }
                
                template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator ++()
                {
                    MatConstIterator::operator ++();
                    return *this;
                }
                
                template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator ++(int)
                {
                    MatConstIterator_ b = *this;
                    MatConstIterator::operator ++();
                    return b;
                }
                
                template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_() : MatConstIterator_<_Tp>() {}
                
                template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m)
                    : MatConstIterator_<_Tp>(_m) {}
                
                template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, int _row, int _col)
                    : MatConstIterator_<_Tp>(_m, _row, _col) {}
                
                template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, Point _pt)
                    : MatConstIterator_<_Tp>(_m, _pt) {}
                
                template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, const int* _idx)
                    : MatConstIterator_<_Tp>(_m, _idx) {}
                
                template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const MatIterator_& it)
                    : MatConstIterator_<_Tp>(it) {}
                
                template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator = (const MatIterator_<_Tp>& it )
                {
                    MatConstIterator::operator = (it);
                    return *this;
                }
                
                template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }
                
                template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator += (ptrdiff_t ofs)
                {
                    MatConstIterator::operator += (ofs);
                    return *this;
                }
                
                template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator -= (ptrdiff_t ofs)
                {
                    MatConstIterator::operator += (-ofs);
                    return *this;
                }
                
                template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator --()
                {
                    MatConstIterator::operator --();
                    return *this;
                }
                
                template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator --(int)
                {
                    MatIterator_ b = *this;
                    MatConstIterator::operator --();
                    return b;
                }
                
                template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator ++()
                {
                    MatConstIterator::operator ++();
                    return *this;
                }
                
                template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator ++(int)
                {
                    MatIterator_ b = *this;
                    MatConstIterator::operator ++();
                    return b;
                }
                
                template<typename _Tp> inline Point MatConstIterator_<_Tp>::pos() const
                {
                    if( !m )
                        return Point();
                    CV_DbgAssert( m->dims <= 2 );
                    if( m->isContinuous() )
                    {
                        ptrdiff_t ofs = (const _Tp*)ptr - (const _Tp*)m->data;
                        int y = (int)(ofs / m->cols), x = (int)(ofs - (ptrdiff_t)y*m->cols);
                        return Point(x, y);
                    }
                    else
                    {
                        ptrdiff_t ofs = (uchar*)ptr - m->data;
                        int y = (int)(ofs / m->step), x = (int)((ofs - y*m->step)/sizeof(_Tp));
                        return Point(x, y);
                    }
                }
                
                static inline bool
                operator == (const MatConstIterator& a, const MatConstIterator& b)
                { return a.m == b.m && a.ptr == b.ptr; }
                
                template<typename _Tp> static inline bool
                operator != (const MatConstIterator& a, const MatConstIterator& b)
                { return !(a == b); }
                
                template<typename _Tp> static inline bool
                operator == (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
                { return a.m == b.m && a.ptr == b.ptr; }
                
                template<typename _Tp> static inline bool
                operator != (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
                { return a.m != b.m || a.ptr != b.ptr; }
                
                template<typename _Tp> static inline bool
                operator == (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
                { return a.m == b.m && a.ptr == b.ptr; }
                
                template<typename _Tp> static inline bool
                operator != (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
                { return a.m != b.m || a.ptr != b.ptr; }
                
                static inline bool
                operator < (const MatConstIterator& a, const MatConstIterator& b)
                { return a.ptr < b.ptr; }
                
                static inline bool
                operator > (const MatConstIterator& a, const MatConstIterator& b)
                { return a.ptr > b.ptr; }
                
                static inline bool
                operator <= (const MatConstIterator& a, const MatConstIterator& b)
                { return a.ptr <= b.ptr; }
                
                static inline bool
                operator >= (const MatConstIterator& a, const MatConstIterator& b)
                { return a.ptr >= b.ptr; }
                
                CV_EXPORTS ptrdiff_t operator - (const MatConstIterator& b, const MatConstIterator& a);
                
                static inline MatConstIterator operator + (const MatConstIterator& a, ptrdiff_t ofs)
                { MatConstIterator b = a; return b += ofs; }
                
                static inline MatConstIterator operator + (ptrdiff_t ofs, const MatConstIterator& a)
                { MatConstIterator b = a; return b += ofs; }
                
                static inline MatConstIterator operator - (const MatConstIterator& a, ptrdiff_t ofs)
                { MatConstIterator b = a; return b += -ofs; }
                
                template<typename _Tp> static inline MatConstIterator_<_Tp>
                operator + (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
                { MatConstIterator t = (const MatConstIterator&)a + ofs; return (MatConstIterator_<_Tp>&)t; }
                
                template<typename _Tp> static inline MatConstIterator_<_Tp>
                operator + (ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)
                { MatConstIterator t = (const MatConstIterator&)a + ofs; return (MatConstIterator_<_Tp>&)t; }
                
                template<typename _Tp> static inline MatConstIterator_<_Tp>
                operator - (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
                { MatConstIterator t = (const MatConstIterator&)a - ofs; return (MatConstIterator_<_Tp>&)t; }
                
                inline uchar* MatConstIterator::operator [](ptrdiff_t i) const
                { return *(*this + i); }
                
                template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator [](ptrdiff_t i) const
                { return *(_Tp*)MatConstIterator::operator [](i); }
                
                template<typename _Tp> static inline MatIterator_<_Tp>
                operator + (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
                { MatConstIterator t = (const MatConstIterator&)a + ofs; return (MatIterator_<_Tp>&)t; }
                
                template<typename _Tp> static inline MatIterator_<_Tp>
                operator + (ptrdiff_t ofs, const MatIterator_<_Tp>& a)
                { MatConstIterator t = (const MatConstIterator&)a + ofs; return (MatIterator_<_Tp>&)t; }
                
                template<typename _Tp> static inline MatIterator_<_Tp>
                operator - (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
                { MatConstIterator t = (const MatConstIterator&)a - ofs; return (MatIterator_<_Tp>&)t; }
                
                template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator [](ptrdiff_t i) const
                { return *(*this + i); }
                
                template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::begin() const
                { return Mat::begin<_Tp>(); }
                
                template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::end() const
                { return Mat::end<_Tp>(); }
                
                template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::begin()
                { return Mat::begin<_Tp>(); }
                
                template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::end()
                { return Mat::end<_Tp>(); }
                
                template<typename _Tp> inline MatCommaInitializer_<_Tp>::MatCommaInitializer_(Mat_<_Tp>* _m) : it(_m) {}
                
                template<typename _Tp> template<typename T2> inline MatCommaInitializer_<_Tp>&
                MatCommaInitializer_<_Tp>::operator , (T2 v)
                {
                    CV_DbgAssert( this->it < ((const Mat_<_Tp>*)this->it.m)->end() );
                    *this->it = _Tp(v); ++this->it;
                    return *this;
                }
                
                template<typename _Tp> inline Mat_<_Tp> MatCommaInitializer_<_Tp>::operator *() const
                {
                    CV_DbgAssert( this->it == ((const Mat_<_Tp>*)this->it.m)->end() );
                    return Mat_<_Tp>(*this->it.m);
                }
                
                template<typename _Tp> inline MatCommaInitializer_<_Tp>::operator Mat_<_Tp>() const
                {
                    CV_DbgAssert( this->it == ((const Mat_<_Tp>*)this->it.m)->end() );
                    return Mat_<_Tp>(*this->it.m);
                }
                
                template<typename _Tp, typename T2> static inline MatCommaInitializer_<_Tp>
                operator << (const Mat_<_Tp>& m, T2 val)
                {
                    MatCommaInitializer_<_Tp> commaInitializer((Mat_<_Tp>*)&m);
                    return (commaInitializer, val);
                }
                
                //////////////////////////////// SparseMat ////////////////////////////////
                
                inline SparseMat::SparseMat()
                : flags(MAGIC_VAL), hdr(0)
                {
                }
                
                inline SparseMat::SparseMat(int _dims, const int* _sizes, int _type)
                : flags(MAGIC_VAL), hdr(0)
                {
                    create(_dims, _sizes, _type);
                }
                
                inline SparseMat::SparseMat(const SparseMat& m)
                : flags(m.flags), hdr(m.hdr)
                {
                    addref();
                }
                
                inline SparseMat::~SparseMat()
                {
                    release();
                }
                
                inline SparseMat& SparseMat::operator = (const SparseMat& m)
                {
                    if( this != &m )
                    {
                        if( m.hdr )
                            CV_XADD(&m.hdr->refcount, 1);
                        release();
                        flags = m.flags;
                        hdr = m.hdr;
                    }
                    return *this;
                }
                
                inline SparseMat& SparseMat::operator = (const Mat& m)
                { return (*this = SparseMat(m)); }
                
                inline SparseMat SparseMat::clone() const
                {
                    SparseMat temp;
                    this->copyTo(temp);
                    return temp;
                }
                
                
                inline void SparseMat::assignTo( SparseMat& m, int _type ) const
                {
                    if( _type < 0 )
                        m = *this;
                    else
                        convertTo(m, _type);
                }
                
                inline void SparseMat::addref()
                { if( hdr ) CV_XADD(&hdr->refcount, 1); }
                
                inline void SparseMat::release()
                {
                    if( hdr && CV_XADD(&hdr->refcount, -1) == 1 )
                        delete hdr;
                    hdr = 0;
                }
                
                inline size_t SparseMat::elemSize() const
                { return CV_ELEM_SIZE(flags); }
                
                inline size_t SparseMat::elemSize1() const
                { return CV_ELEM_SIZE1(flags); }
                
                inline int SparseMat::type() const
                { return CV_MAT_TYPE(flags); }
                
                inline int SparseMat::depth() const
                { return CV_MAT_DEPTH(flags); }
                
                inline int SparseMat::channels() const
                { return CV_MAT_CN(flags); }
                
                inline const int* SparseMat::size() const
                {
                    return hdr ? hdr->size : 0;
                }
                
                inline int SparseMat::size(int i) const
                {
                    if( hdr )
                    {
                        CV_DbgAssert((unsigned)i < (unsigned)hdr->dims);
                        return hdr->size[i];
                    }
                    return 0;
                }
                
                inline int SparseMat::dims() const
                {
                    return hdr ? hdr->dims : 0;
                }
                
                inline size_t SparseMat::nzcount() const
                {
                    return hdr ? hdr->nodeCount : 0;
                }
                
                inline size_t SparseMat::hash(int i0) const
                {
                    return (size_t)i0;
                }
                
                inline size_t SparseMat::hash(int i0, int i1) const
                {
                    return (size_t)(unsigned)i0*HASH_SCALE + (unsigned)i1;
                }
                
                inline size_t SparseMat::hash(int i0, int i1, int i2) const
                {
                    return ((size_t)(unsigned)i0*HASH_SCALE + (unsigned)i1)*HASH_SCALE + (unsigned)i2;
                }
                
                inline size_t SparseMat::hash(const int* idx) const
                {
                    size_t h = (unsigned)idx[0];
                    if( !hdr )
                        return 0;
                    int i, d = hdr->dims;
                    for( i = 1; i < d; i++ )
                        h = h*HASH_SCALE + (unsigned)idx[i];
                    return h;
                }
                
                template<typename _Tp> inline _Tp& SparseMat::ref(int i0, size_t* hashval)
                { return *(_Tp*)((SparseMat*)this)->ptr(i0, true, hashval); }
                
                template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, size_t* hashval)
                { return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, true, hashval); }
                
                template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, int i2, size_t* hashval)
                { return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, i2, true, hashval); }
                
                template<typename _Tp> inline _Tp& SparseMat::ref(const int* idx, size_t* hashval)
                { return *(_Tp*)((SparseMat*)this)->ptr(idx, true, hashval); }
                
                template<typename _Tp> inline _Tp SparseMat::value(int i0, size_t* hashval) const
                {
                    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval);
                    return p ? *p : _Tp();
                }
                
                template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, size_t* hashval) const
                {
                    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval);
                    return p ? *p : _Tp();
                }
                
                template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, int i2, size_t* hashval) const
                {
                    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval);
                    return p ? *p : _Tp();
                }
                
                template<typename _Tp> inline _Tp SparseMat::value(const int* idx, size_t* hashval) const
                {
                    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval);
                    return p ? *p : _Tp();
                }
                
                template<typename _Tp> inline const _Tp* SparseMat::find(int i0, size_t* hashval) const
                { return (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval); }
                
                template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, size_t* hashval) const
                { return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval); }
                
                template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, int i2, size_t* hashval) const
                { return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval); }
                
                template<typename _Tp> inline const _Tp* SparseMat::find(const int* idx, size_t* hashval) const
                { return (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval); }
                
                template<typename _Tp> inline _Tp& SparseMat::value(Node* n)
                { return *(_Tp*)((uchar*)n + hdr->valueOffset); }
                
                template<typename _Tp> inline const _Tp& SparseMat::value(const Node* n) const
                { return *(const _Tp*)((const uchar*)n + hdr->valueOffset); }
                
                inline SparseMat::Node* SparseMat::node(size_t nidx)
                { return (Node*)(void*)&hdr->pool[nidx]; }
                
                inline const SparseMat::Node* SparseMat::node(size_t nidx) const
                { return (const Node*)(void*)&hdr->pool[nidx]; }
                
                inline SparseMatIterator SparseMat::begin()
                { return SparseMatIterator(this); }
                
                inline SparseMatConstIterator SparseMat::begin() const
                { return SparseMatConstIterator(this); }
                
                inline SparseMatIterator SparseMat::end()
                { SparseMatIterator it(this); it.seekEnd(); return it; }
                
                inline SparseMatConstIterator SparseMat::end() const
                { SparseMatConstIterator it(this); it.seekEnd(); return it; }
                
                template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::begin()
                { return SparseMatIterator_<_Tp>(this); }
                
                template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::begin() const
                { return SparseMatConstIterator_<_Tp>(this); }
                
                template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::end()
                { SparseMatIterator_<_Tp> it(this); it.seekEnd(); return it; }
                
                template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::end() const
                { SparseMatConstIterator_<_Tp> it(this); it.seekEnd(); return it; }
                
                
                inline SparseMatConstIterator::SparseMatConstIterator()
                : m(0), hashidx(0), ptr(0)
                {
                }
                
                inline SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator& it)
                : m(it.m), hashidx(it.hashidx), ptr(it.ptr)
                {
                }
                
                static inline bool operator == (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
                { return it1.m == it2.m && it1.ptr == it2.ptr; }
                
                static inline bool operator != (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
                { return !(it1 == it2); }
                
                
                inline SparseMatConstIterator& SparseMatConstIterator::operator = (const SparseMatConstIterator& it)
                {
                    if( this != &it )
                    {
                        m = it.m;
                        hashidx = it.hashidx;
                        ptr = it.ptr;
                    }
                    return *this;
                }
                
                template<typename _Tp> inline const _Tp& SparseMatConstIterator::value() const
                { return *(_Tp*)ptr; }
                
                inline const SparseMat::Node* SparseMatConstIterator::node() const
                {
                    return ptr && m && m->hdr ?
                        (const SparseMat::Node*)(void*)(ptr - m->hdr->valueOffset) : 0;
                }
                
                inline SparseMatConstIterator SparseMatConstIterator::operator ++(int)
                {
                    SparseMatConstIterator it = *this;
                    ++*this;
                    return it;
                }
                
                
                inline void SparseMatConstIterator::seekEnd()
                {
                    if( m && m->hdr )
                    {
                        hashidx = m->hdr->hashtab.size();
                        ptr = 0;
                    }
                }
                
                inline SparseMatIterator::SparseMatIterator()
                {}
                
                inline SparseMatIterator::SparseMatIterator(SparseMat* _m)
                : SparseMatConstIterator(_m)
                {}
                
                inline SparseMatIterator::SparseMatIterator(const SparseMatIterator& it)
                : SparseMatConstIterator(it)
                {
                }
                
                inline SparseMatIterator& SparseMatIterator::operator = (const SparseMatIterator& it)
                {
                    (SparseMatConstIterator&)*this = it;
                    return *this;
                }
                
                template<typename _Tp> inline _Tp& SparseMatIterator::value() const
                { return *(_Tp*)ptr; }
                
                inline SparseMat::Node* SparseMatIterator::node() const
                {
                    return (SparseMat::Node*)SparseMatConstIterator::node();
                }
                
                inline SparseMatIterator& SparseMatIterator::operator ++()
                {
                    SparseMatConstIterator::operator ++();
                    return *this;
                }
                
                inline SparseMatIterator SparseMatIterator::operator ++(int)
                {
                    SparseMatIterator it = *this;
                    ++*this;
                    return it;
                }
                
                
                template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_()
                { flags = MAGIC_VAL | DataType<_Tp>::type; }
                
                template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(int _dims, const int* _sizes)
                : SparseMat(_dims, _sizes, DataType<_Tp>::type)
                {}
                
                template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat& m)
                {
                    if( m.type() == DataType<_Tp>::type )
                        *this = (const SparseMat_<_Tp>&)m;
                    else
                        m.convertTo(*this, DataType<_Tp>::type);
                }
                
                template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat_<_Tp>& m)
                {
                    this->flags = m.flags;
                    this->hdr = m.hdr;
                    if( this->hdr )
                        CV_XADD(&this->hdr->refcount, 1);
                }
                
                template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const Mat& m)
                {
                    SparseMat sm(m);
                    *this = sm;
                }
                
                template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const CvSparseMat* m)
                {
                    SparseMat sm(m);
                    *this = sm;
                }
                
                template<typename _Tp> inline SparseMat_<_Tp>&
                SparseMat_<_Tp>::operator = (const SparseMat_<_Tp>& m)
                {
                    if( this != &m )
                    {
                        if( m.hdr ) CV_XADD(&m.hdr->refcount, 1);
                        release();
                        flags = m.flags;
                        hdr = m.hdr;
                    }
                    return *this;
                }
                
                template<typename _Tp> inline SparseMat_<_Tp>&
                SparseMat_<_Tp>::operator = (const SparseMat& m)
                {
                    if( m.type() == DataType<_Tp>::type )
                        return (*this = (const SparseMat_<_Tp>&)m);
                    m.convertTo(*this, DataType<_Tp>::type);
                    return *this;
                }
                
                template<typename _Tp> inline SparseMat_<_Tp>&
                SparseMat_<_Tp>::operator = (const Mat& m)
                { return (*this = SparseMat(m)); }
                
                template<typename _Tp> inline SparseMat_<_Tp>
                SparseMat_<_Tp>::clone() const
                {
                    SparseMat_<_Tp> m;
                    this->copyTo(m);
                    return m;
                }
                
                template<typename _Tp> inline void
                SparseMat_<_Tp>::create(int _dims, const int* _sizes)
                {
                    SparseMat::create(_dims, _sizes, DataType<_Tp>::type);
                }
                
                template<typename _Tp> inline
                SparseMat_<_Tp>::operator CvSparseMat*() const
                {
                    return SparseMat::operator CvSparseMat*();
                }
                
                template<typename _Tp> inline int SparseMat_<_Tp>::type() const
                { return DataType<_Tp>::type; }
                
                template<typename _Tp> inline int SparseMat_<_Tp>::depth() const
                { return DataType<_Tp>::depth; }
                
                template<typename _Tp> inline int SparseMat_<_Tp>::channels() const
                { return DataType<_Tp>::channels; }
                
                template<typename _Tp> inline _Tp&
                SparseMat_<_Tp>::ref(int i0, size_t* hashval)
                { return SparseMat::ref<_Tp>(i0, hashval); }
                
                template<typename _Tp> inline _Tp
                SparseMat_<_Tp>::operator()(int i0, size_t* hashval) const
                { return SparseMat::value<_Tp>(i0, hashval); }
                
                template<typename _Tp> inline _Tp&
                SparseMat_<_Tp>::ref(int i0, int i1, size_t* hashval)
                { return SparseMat::ref<_Tp>(i0, i1, hashval); }
                
                template<typename _Tp> inline _Tp
                SparseMat_<_Tp>::operator()(int i0, int i1, size_t* hashval) const
                { return SparseMat::value<_Tp>(i0, i1, hashval); }
                
                template<typename _Tp> inline _Tp&
                SparseMat_<_Tp>::ref(int i0, int i1, int i2, size_t* hashval)
                { return SparseMat::ref<_Tp>(i0, i1, i2, hashval); }
                
                template<typename _Tp> inline _Tp
                SparseMat_<_Tp>::operator()(int i0, int i1, int i2, size_t* hashval) const
                { return SparseMat::value<_Tp>(i0, i1, i2, hashval); }
                
                template<typename _Tp> inline _Tp&
                SparseMat_<_Tp>::ref(const int* idx, size_t* hashval)
                { return SparseMat::ref<_Tp>(idx, hashval); }
                
                template<typename _Tp> inline _Tp
                SparseMat_<_Tp>::operator()(const int* idx, size_t* hashval) const
                { return SparseMat::value<_Tp>(idx, hashval); }
                
                template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::begin()
                { return SparseMatIterator_<_Tp>(this); }
                
                template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::begin() const
                { return SparseMatConstIterator_<_Tp>(this); }
                
                template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::end()
                { SparseMatIterator_<_Tp> it(this); it.seekEnd(); return it; }
                
                template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::end() const
                { SparseMatConstIterator_<_Tp> it(this); it.seekEnd(); return it; }
                
                template<typename _Tp> inline
                SparseMatConstIterator_<_Tp>::SparseMatConstIterator_()
                {}
                
                template<typename _Tp> inline
                SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat_<_Tp>* _m)
                : SparseMatConstIterator(_m)
                {}
                
                template<typename _Tp> inline
                SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat* _m)
                : SparseMatConstIterator(_m)
                {
                    CV_Assert( _m->type() == DataType<_Tp>::type );
                }
                
                template<typename _Tp> inline
                SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMatConstIterator_<_Tp>& it)
                : SparseMatConstIterator(it)
                {}
                
                template<typename _Tp> inline SparseMatConstIterator_<_Tp>&
                SparseMatConstIterator_<_Tp>::operator = (const SparseMatConstIterator_<_Tp>& it)
                { return reinterpret_cast<SparseMatConstIterator_<_Tp>&>
                    (*reinterpret_cast<SparseMatConstIterator*>(this) =
                     reinterpret_cast<const SparseMatConstIterator&>(it)); }
                
                template<typename _Tp> inline const _Tp&
                SparseMatConstIterator_<_Tp>::operator *() const
                { return *(const _Tp*)this->ptr; }
                
                template<typename _Tp> inline SparseMatConstIterator_<_Tp>&
                SparseMatConstIterator_<_Tp>::operator ++()
                {
                    SparseMatConstIterator::operator ++();
                    return *this;
                }
                
                template<typename _Tp> inline SparseMatConstIterator_<_Tp>
                SparseMatConstIterator_<_Tp>::operator ++(int)
                {
                    SparseMatConstIterator_<_Tp> it = *this;
                    SparseMatConstIterator::operator ++();
                    return it;
                }
                
                template<typename _Tp> inline
                SparseMatIterator_<_Tp>::SparseMatIterator_()
                {}
                
                template<typename _Tp> inline
                SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat_<_Tp>* _m)
                : SparseMatConstIterator_<_Tp>(_m)
                {}
                
                template<typename _Tp> inline
                SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat* _m)
                : SparseMatConstIterator_<_Tp>(_m)
                {}
                
                template<typename _Tp> inline
                SparseMatIterator_<_Tp>::SparseMatIterator_(const SparseMatIterator_<_Tp>& it)
                : SparseMatConstIterator_<_Tp>(it)
                {}
                
                template<typename _Tp> inline SparseMatIterator_<_Tp>&
                SparseMatIterator_<_Tp>::operator = (const SparseMatIterator_<_Tp>& it)
                { return reinterpret_cast<SparseMatIterator_<_Tp>&>
                    (*reinterpret_cast<SparseMatConstIterator*>(this) =
                     reinterpret_cast<const SparseMatConstIterator&>(it)); }
                
                template<typename _Tp> inline _Tp&
                SparseMatIterator_<_Tp>::operator *() const
                { return *(_Tp*)this->ptr; }
                
                template<typename _Tp> inline SparseMatIterator_<_Tp>&
                SparseMatIterator_<_Tp>::operator ++()
                {
                    SparseMatConstIterator::operator ++();
                    return *this;
                }
                
                template<typename _Tp> inline SparseMatIterator_<_Tp>
                SparseMatIterator_<_Tp>::operator ++(int)
                {
                    SparseMatIterator_<_Tp> it = *this;
                    SparseMatConstIterator::operator ++();
                    return it;
                }
                
                }
                
                #endif
                #endif


Top 10 Lines:

     Line      Count

      365      15658
      274      13912
      709      12166
      738      12166
      740      10418
      741      10418
       59       8703
       67       8703
     1124       7538
      111       3463

Execution Summary:

       20   Executable lines in this file
       20   Lines executed
   100.00   Percent of the file executed

   112662   Total number of line executions
  5633.10   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _STL_VECTOR_H
                #define _STL_VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                        rebind<_Tp>::other _Tp_alloc_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
                       	pointer;
                
       12720 ->       struct _Vector_impl 
                      : public _Tp_alloc_type
                      {
                	pointer _M_start;
                	pointer _M_finish;
                	pointer _M_end_of_storage;
                
        5152 -> 	_Vector_impl()
                	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                
        1747 -> 	_Vector_impl(_Tp_alloc_type const& __a)
                	: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                
                #if __cplusplus >= 201103L
                	_Vector_impl(_Tp_alloc_type&& __a)
                	: _Tp_alloc_type(std::move(__a)),
                	  _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                #endif
                
                	void _M_swap_data(_Vector_impl& __x)
                	{
                	  std::swap(_M_start, __x._M_start);
                	  std::swap(_M_finish, __x._M_finish);
                	  std::swap(_M_end_of_storage, __x._M_end_of_storage);
                	}
                      };
                      
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
       55626 ->       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
                
                      const _Tp_alloc_type&
       28602 ->       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Tp_allocator()); }
                
        5152 ->       _Vector_base()
                      : _M_impl() { }
                
           1 ->       _Vector_base(const allocator_type& __a)
                      : _M_impl(__a) { }
                
                      _Vector_base(size_t __n)
                      : _M_impl()
                      { _M_create_storage(__n); }
                
        1746 ->       _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      { _M_create_storage(__n); }
                
                #if __cplusplus >= 201103L
                      _Vector_base(_Tp_alloc_type&& __a)
                      : _M_impl(std::move(__a)) { }
                
                      _Vector_base(_Vector_base&& __x)
                      : _M_impl(std::move(__x._M_get_Tp_allocator()))
                      { this->_M_impl._M_swap_data(__x._M_impl); }
                
                      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  this->_M_impl._M_swap_data(__x._M_impl);
                	else
                	  {
                	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                	    _M_create_storage(__n);
                	  }
                      }
                #endif
                
       12720 ->       ~_Vector_base()
                      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
                		      - this->_M_impl._M_start); }
                
                    public:
                      _Vector_impl _M_impl;
                
                      pointer
       15176 ->       _M_allocate(size_t __n)
                      { return __n != 0 ? _M_impl.allocate(__n) : 0; }
                
                      void
       26149 ->       _M_deallocate(pointer __p, size_t __n)
                      {
                	if (__p)
                	  _M_impl.deallocate(__p, __n);
                      }
                
                    private:
                      void
        1746 ->       _M_create_storage(size_t __n)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                    };
                
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Tp  Type of element.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                      // Concept requirements.
                      typedef typename _Alloc::value_type                _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                      
                      typedef _Vector_base<_Tp, _Alloc>			 _Base;
                      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>  _Alloc_traits;
                
                    public:
                      typedef _Tp					 value_type;
                      typedef typename _Base::pointer                    pointer;
                      typedef typename _Alloc_traits::const_pointer      const_pointer;
                      typedef typename _Alloc_traits::reference          reference;
                      typedef typename _Alloc_traits::const_reference    const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		 reverse_iterator;
                      typedef size_t					 size_type;
                      typedef ptrdiff_t					 difference_type;
                      typedef _Alloc                        		 allocator_type;
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                      /**
                       *  @brief  Default constructor creates no elements.
                       */
        5152 ->       vector()
                      : _Base() { }
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       *  @param  __a  An allocator object.
                       */
                      explicit
                      vector(const allocator_type& __a)
                      : _Base(__a) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Creates a %vector with default constructed elements.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n default
                       *  constructed elements.
                       */
                      explicit
                      vector(size_type __n, const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_default_initialize(__n); }
                
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      vector(size_type __n, const value_type& __value,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_fill_initialize(__n, __value); }
                #else
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      explicit
                      vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_fill_initialize(__n, __value); }
                #endif
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector uses a copy of the allocation
                       *  object used by @a __x.  All the elements of @a __x are copied,
                       *  but any extra memory in
                       *  @a __x (for fast expansion) will not be copied.
                       */
        1746 ->       vector(const vector& __x)
                      : _Base(__x.size(),
                        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector contains the exact contents of @a __x.
                       *  The contents of @a __x are a valid, but unspecified %vector.
                       */
                      vector(vector&& __x) noexcept
                      : _Base(std::move(__x)) { }
                
                      /// Copy constructor with alternative allocator
                      vector(const vector& __x, const allocator_type& __a)
                      : _Base(__x.size(), __a)
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                      /// Move constructor with alternative allocator
                      vector(vector&& __rv, const allocator_type& __m)
                      : _Base(std::move(__rv), __m)
                      {
                	if (__rv.get_allocator() != __m)
                	  {
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
                					  this->_M_impl._M_start,
                					  _M_get_Tp_allocator());
                	    __rv.clear();
                	  }
                      }
                
                      /**
                       *  @brief  Builds a %vector from an initializer list.
                       *  @param  __l  An initializer_list.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is @a __l.size()) and do no memory reallocation.
                       */
                      vector(initializer_list<value_type> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        { _M_initialize_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
           1 ->         vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
       12720 ->       ~vector() _GLIBCXX_NOEXCEPT
                      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator()); }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any extra memory in
                       *  @a __x (for fast expansion) will not be copied.  Unlike the
                       *  copy constructor, the allocator object is not copied.
                       */
                      vector&
                      operator=(const vector& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The contents of @a __x are moved into this %vector (without copying,
                       *  if the allocators permit it).
                       *  @a __x is a valid, but unspecified %vector.
                       */
                      vector&
                      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                        constexpr bool __move_storage =
                          _Alloc_traits::_S_propagate_on_move_assign()
                          || _Alloc_traits::_S_always_equal();
                        _M_move_assign(std::move(__x),
                                       integral_constant<bool, __move_storage>());
                	return *this;
                      }
                
                      /**
                       *  @brief  %Vector list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      vector&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->assign(__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  __n  Number of elements to be assigned.
                       *  @param  __val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a __n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [__first,__last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        { _M_assign_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Assigns an initializer list to a %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      { this->assign(__l.begin(), __l.end()); }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
       15989 ->       begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
        2620 ->       begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
       16832 ->       end() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
        2620 ->       end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
      513407 ->       size() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
       26856 ->       max_size() const _GLIBCXX_NOEXCEPT
                      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  default constructed elements are appended.
                       */
                      void
                      resize(size_type __new_size)
                      {
                	if (__new_size > size())
                	  _M_default_append(__new_size - size());
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, const value_type& __x)
                      {
                	if (__new_size > size())
                	  insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #else
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size > size())
                	  insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**  A non-binding request to reduce capacity() to size().  */
                      void
                      shrink_to_fit()
                      { _M_shrink_to_fit(); }
                #endif
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
         874 ->       capacity() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_end_of_storage
                			 - this->_M_impl._M_start); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  __n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
    15199624 ->       operator[](size_type __n)
                      { return *(this->_M_impl._M_start + __n); }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[](size_type __n) const
                      { return *(this->_M_impl._M_start + __n); }
                
                    protected:
                      /// Safety check used only from at().
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range(__N("vector::_M_range_check"));
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n]; 
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
                      front()
                      { return *begin(); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
                      front() const
                      { return *begin(); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
                      back()
                      { return *(end() - 1); }
                      
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
                      back() const
                      { return *(end() - 1); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                #if __cplusplus >= 201103L
                      _Tp*
                #else
                      pointer
                #endif
                      data() _GLIBCXX_NOEXCEPT
                      { return std::__addressof(front()); }
                
                #if __cplusplus >= 201103L
                      const _Tp*
                #else
                      const_pointer
                #endif
                      data() const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(front()); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
      100524 ->       push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                	                             __x);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                #if __cplusplus >= 201103L
                	  _M_emplace_back_aux(__x);
                #else
                	  _M_insert_aux(end(), __x);
                #endif
                      }
                
                #if __cplusplus >= 201103L
                      void
                      push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                        void
                        emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
                      pop_back()
                      {
                	--this->_M_impl._M_finish;
                	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts an object in %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       *  Note that this kind of operation could be expensive for a %vector
                       *  and if it is frequently used the user should consider using
                       *  std::list.
                       */
                      template<typename... _Args>
                        iterator
                        emplace(iterator __position, _Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts given rvalue into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, value_type&& __x)
                      { return emplace(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer_list into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the 
                       *  initializer_list @a l into the %vector before the location
                       *  specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, initializer_list<value_type> __l)
                      { this->insert(__position, __l.begin(), __l.end()); }
                #endif
                
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        { _M_insert_dispatch(__position, __first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  __position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                      erase(iterator __position);
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  __first  Iterator pointing to the first element to be erased.
                       *  @param  __last  Iterator pointing to one past the last element to be
                       *                  erased.
                       *  @return  An iterator pointing to the element pointed to by @a __last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range
                       *  [__first,__last) and shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                      erase(iterator __first, iterator __last);
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  __x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       */
                      void
                      swap(vector& __x)
                #if __cplusplus >= 201103L
                			noexcept(_Alloc_traits::_S_nothrow_swap())
                #endif
                      {
                	this->_M_impl._M_swap_data(__x._M_impl);
                	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                	                          __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(this->_M_impl._M_start); }
                
                    protected:
                      /**
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       */
                      template<typename _ForwardIterator>
                        pointer
           1 ->         _M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                        {
                	  pointer __result = this->_M_allocate(__n);
                	  __try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  __catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
           1 ->         _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                        {
                	  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
                	  this->_M_impl._M_end_of_storage =
                	    this->_M_impl._M_start + static_cast<size_type>(__n);
                	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_initialize(__first, __last, _IterCategory());
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_initialize(_InputIterator __first,
                			    _InputIterator __last, std::input_iterator_tag)
                        {
                	  for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	    emplace_back(*__first);
                #else
                	    push_back(*__first);
                #endif
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_initialize(_ForwardIterator __first,
                			    _ForwardIterator __last, std::forward_iterator_tag)
                        {
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start = this->_M_allocate(__n);
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                      // Called by the first initialize_dispatch above and by the
                      // vector(n,value,a) constructor.
                      void
           1 ->       _M_fill_initialize(size_type __n, const value_type& __value)
                      {
                	std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, 
                				      _M_get_Tp_allocator());
                	this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                      }
                
                #if __cplusplus >= 201103L
                      // Called by the vector(n) constructor.
                      void
                      _M_default_initialize(size_type __n)
                      {
                	std::__uninitialized_default_n_a(this->_M_impl._M_start, __n, 
                					 _M_get_Tp_allocator());
                	this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                      }
                #endif
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                        { _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_assign_aux(__first, __last, _IterCategory());
                	}
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                        { _M_fill_insert(__pos, __n, __val); }
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_insert(__pos, __first, __last, _IterCategory());
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      // Called by resize(n).
                      void
                      _M_default_append(size_type __n);
                
                      bool
                      _M_shrink_to_fit();
                #endif
                
                      // Called by insert(p,x)
                #if __cplusplus < 201103L
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                #else
                      template<typename... _Args>
                        void
                        _M_insert_aux(iterator __position, _Args&&... __args);
                
                      template<typename... _Args>
                        void
                        _M_emplace_back_aux(_Args&&... __args);
                #endif
                
                      // Called by the latter.
                      size_type
       13428 ->       _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + std::max(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      // Internal erase functions follow.
                
                      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                      // _M_assign_aux.
                      void
                      _M_erase_at_end(pointer __pos)
                      {
                	std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
                	this->_M_impl._M_finish = __pos;
                      }
                
                #if __cplusplus >= 201103L
                    private:
                      // Constant-time move assignment when source object's memory can be
                      // moved, either because the source's allocator will move too
                      // or because the allocators are equal.
                      void
                      _M_move_assign(vector&& __x, std::true_type) noexcept
                      {
                	vector __tmp(get_allocator());
                	this->_M_impl._M_swap_data(__tmp._M_impl);
                	this->_M_impl._M_swap_data(__x._M_impl);
                	if (_Alloc_traits::_S_propagate_on_move_assign())
                	  std::__alloc_on_move(_M_get_Tp_allocator(),
                			       __x._M_get_Tp_allocator());
                      }
                
                      // Do move assignment when it might not be possible to move source
                      // object's memory, resulting in a linear-time operation.
                      void
                      _M_move_assign(vector&& __x, std::false_type)
                      {
                	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                	  _M_move_assign(std::move(__x), std::true_type());
                	else
                	  {
                	    // The rvalue's allocator cannot be moved and is not equal,
                	    // so we need to individually move each element.
                	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
                			 std::__make_move_if_noexcept_iterator(__x.end()));
                	    __x.clear();
                	  }
                      }
                #endif
                    };
                
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff @a __x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #endif /* _STL_VECTOR_H */


Top 10 Lines:

     Line      Count

      770   15199624
      645     513407
      901     100524
      113      55626
      117      28602
      650      26856
      171      26149
      556      16832
      538      15989
      167      15176

Execution Summary:

       29   Executable lines in this file
       29   Lines executed
   100.00   Percent of the file executed

 16078933   Total number of line executions
554445.97   Average executions per line


*** File /usr/include/c++/4.8/ext/new_allocator.h:
                // Allocator that wraps operator new -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/new_allocator.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _NEW_ALLOCATOR_H
                #define _NEW_ALLOCATOR_H 1
                
                #include <bits/c++config.h>
                #include <new>
                #include <bits/functexcept.h>
                #include <bits/move.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  using std::size_t;
                  using std::ptrdiff_t;
                
                  /**
                   *  @brief  An allocator that uses global new, as per [20.4].
                   *  @ingroup allocators
                   *
                   *  This is precisely the allocator defined in the C++ Standard. 
                   *    - all allocation calls operator new
                   *    - all deallocation calls operator delete
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class new_allocator
                    {
                    public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef new_allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. propagate_on_container_move_assignment
                      typedef std::true_type propagate_on_container_move_assignment;
                #endif
                
        5153 ->       new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
        1747 ->       new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
                
                      template<typename _Tp1>
                        new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
                
       12721 ->       ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      pointer
                      address(reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      const_pointer
                      address(const_reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      // NB: __n is permitted to be 0.  The C++ standard says nothing
                      // about what the return value is when __n == 0.
                      pointer
       15176 ->       allocate(size_type __n, const void* = 0)
                      { 
                	if (__n > this->max_size())
                	  std::__throw_bad_alloc();
                
                	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                      }
                
                      // __p is not permitted to be a null pointer.
                      void
       23543 ->       deallocate(pointer __p, size_type)
                      { ::operator delete(__p); }
                
                      size_type
       42032 ->       max_size() const _GLIBCXX_USE_NOEXCEPT
                      { return size_t(-1) / sizeof(_Tp); }
                
                #if __cplusplus >= 201103L
                      template<typename _Up, typename... _Args>
                        void
                        construct(_Up* __p, _Args&&... __args)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                        void 
                        destroy(_Up* __p) { __p->~_Up(); }
                #else
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_] allocator::construct
                      void 
      100525 ->       construct(pointer __p, const _Tp& __val) 
                      { ::new((void *)__p) _Tp(__val); }
                
                      void 
         844 ->       destroy(pointer __p) { __p->~_Tp(); }
                #endif
                    };
                
                  template<typename _Tp>
                    inline bool
                    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return true; }
                  
                  template<typename _Tp>
                    inline bool
                    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return false; }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

      129     100525
      113      42032
      109      23543
       99      15176
       86      12721
       79       5153
       81       1747
      133        844

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

   201741   Total number of line executions
 25217.62   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_algobase.h:
                // Core algorithmic facilities -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_algobase.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _STL_ALGOBASE_H
                #define _STL_ALGOBASE_H 1
                
                #include <bits/c++config.h>
                #include <bits/functexcept.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <ext/numeric_traits.h>
                #include <bits/stl_pair.h>
                #include <bits/stl_iterator_base_types.h>
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/stl_iterator.h>
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                #include <bits/move.h> // For std::swap and _GLIBCXX_MOVE
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus < 201103L
                  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
                  // nutshell, we are partially implementing the resolution of DR 187,
                  // when it's safe, i.e., the value_types are equal.
                  template<bool _BoolType>
                    struct __iter_swap
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                        static void
                        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                        {
                          typedef typename iterator_traits<_ForwardIterator1>::value_type
                            _ValueType1;
                          _ValueType1 __tmp = _GLIBCXX_MOVE(*__a);
                          *__a = _GLIBCXX_MOVE(*__b);
                          *__b = _GLIBCXX_MOVE(__tmp);
                	}
                    };
                
                  template<>
                    struct __iter_swap<true>
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                        static void 
                        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                        {
                          swap(*__a, *__b);
                        }
                    };
                #endif
                
                  /**
                   *  @brief Swaps the contents of two iterators.
                   *  @ingroup mutating_algorithms
                   *  @param  __a  An iterator.
                   *  @param  __b  Another iterator.
                   *  @return   Nothing.
                   *
                   *  This function swaps the values pointed to by two iterators, not the
                   *  iterators themselves.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    inline void
                    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                
                #if __cplusplus < 201103L
                      typedef typename iterator_traits<_ForwardIterator1>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator2>::value_type
                	_ValueType2;
                
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
                				  _ValueType2>)
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
                				  _ValueType1>)
                
                      typedef typename iterator_traits<_ForwardIterator1>::reference
                	_ReferenceType1;
                      typedef typename iterator_traits<_ForwardIterator2>::reference
                	_ReferenceType2;
                      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
                	&& __are_same<_ValueType1&, _ReferenceType1>::__value
                	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
                	iter_swap(__a, __b);
                #else
                      swap(*__a, *__b);
                #endif
                    }
                
                  /**
                   *  @brief Swap the elements of two sequences.
                   *  @ingroup mutating_algorithms
                   *  @param  __first1  A forward iterator.
                   *  @param  __last1   A forward iterator.
                   *  @param  __first2  A forward iterator.
                   *  @return   An iterator equal to @p first2+(last1-first1).
                   *
                   *  Swaps each element in the range @p [first1,last1) with the
                   *  corresponding element in the range @p [first2,(last1-first1)).
                   *  The ranges must not overlap.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _ForwardIterator2
                    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		_ForwardIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, ++__first2)
                	std::iter_swap(__first1, __first2);
                      return __first2;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The lesser of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    inline const _Tp&
                    min(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return __b < __a ? __b : __a;
                      if (__b < __a)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The greater of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    inline const _Tp&
       13428 ->     max(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return  __a < __b ? __b : __a;
                      if (__a < __b)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The lesser of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    inline const _Tp&
                    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__b, __a) ? __b : __a;
                      if (__comp(__b, __a))
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The greater of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    inline const _Tp&
                    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__a, __b) ? __b : __a;
                      if (__comp(__a, __b))
                	return __b;
                      return __a;
                    }
                
                  // If _Iterator is a __normal_iterator return its base (a plain pointer,
                  // normally) otherwise return it untouched.  See copy, fill, ... 
                  template<typename _Iterator>
                    struct _Niter_base
                    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
                    { };
                
                  template<typename _Iterator>
                    inline typename _Niter_base<_Iterator>::iterator_type
       80953 ->     __niter_base(_Iterator __it)
                    { return std::_Niter_base<_Iterator>::_S_base(__it); }
                
                  // Likewise, for move_iterator.
                  template<typename _Iterator>
                    struct _Miter_base
                    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
                    { };
                
                  template<typename _Iterator>
                    inline typename _Miter_base<_Iterator>::iterator_type
       53968 ->     __miter_base(_Iterator __it)
                    { return std::_Miter_base<_Iterator>::_S_base(__it); }
                
                  // All of these auxiliary structs serve two purposes.  (1) Replace
                  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
                  // because the input and output ranges are permitted to overlap.)
                  // (2) If we're using random access iterators, then write the loop as
                  // a for loop with an explicit count.
                
                  template<bool, bool, typename>
                    struct __copy_move
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        __copy_m(_II __first, _II __last, _OI __result)
                        {
                	  for (; __first != __last; ++__result, ++__first)
                	    *__result = *__first;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move<true, false, _Category>
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        __copy_m(_II __first, _II __last, _OI __result)
                        {
                	  for (; __first != __last; ++__result, ++__first)
                	    *__result = std::move(*__first);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move<false, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        __copy_m(_II __first, _II __last, _OI __result)
                        { 
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = *__first;
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move<true, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        __copy_m(_II __first, _II __last, _OI __result)
                        { 
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = std::move(*__first);
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                        static _Tp*
       26984 ->         __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
                        {
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
                	  return __result + _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _II, typename _OI>
                    inline _OI
       26984 ->     __copy_move_a(_II __first, _II __last, _OI __result)
                    {
                      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
                      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
                      typedef typename iterator_traits<_II>::iterator_category _Category;
                      const bool __simple = (__is_trivial(_ValueTypeI)
                	                     && __is_pointer<_II>::__value
                	                     && __is_pointer<_OI>::__value
                			     && __are_same<_ValueTypeI, _ValueTypeO>::__value);
                
                      return std::__copy_move<_IsMove, __simple,
                	                      _Category>::__copy_m(__first, __last, __result);
                    }
                
                  // Helpers for streambuf iterators (either istream or ostream).
                  // NB: avoid including <iosfwd>, relatively large.
                  template<typename _CharT>
                    struct char_traits;
                
                  template<typename _CharT, typename _Traits>
                    class istreambuf_iterator;
                
                  template<typename _CharT, typename _Traits>
                    class ostreambuf_iterator;
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(_CharT*, _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(const _CharT*, const _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                				    _CharT*>::__type
                    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
                		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    inline _OI
       26984 ->     __copy_move_a2(_II __first, _II __last, _OI __result)
                    {
                      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
                					     std::__niter_base(__last),
                					     std::__niter_base(__result)));
                    }
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (first - last)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the copy_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    inline _OI
       26984 ->     copy(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
                	      (std::__miter_base(__first), std::__miter_base(__last),
                	       __result));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (first - last)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the move_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    inline _OI
                    move(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__copy_move_a2<true>(std::__miter_base(__first),
                				       std::__miter_base(__last), __result);
                    }
                
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
                #endif
                
                  template<bool, bool, typename>
                    struct __copy_move_backward
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        {
                	  while (__first != __last)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move_backward<true, false, _Category>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        {
                	  while (__first != __last)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move_backward<false, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
       ##### ->         __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        {
                	  typename iterator_traits<_BI1>::difference_type __n;
                	  for (__n = __last - __first; __n > 0; --__n)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move_backward<true, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        {
                	  typename iterator_traits<_BI1>::difference_type __n;
                	  for (__n = __last - __first; __n > 0; --__n)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                        static _Tp*
       ##### ->         __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
                        {
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
                	  return __result - _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    inline _BI2
       ##### ->     __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
                      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
                      typedef typename iterator_traits<_BI1>::iterator_category _Category;
                      const bool __simple = (__is_trivial(_ValueType1)
                	                     && __is_pointer<_BI1>::__value
                	                     && __is_pointer<_BI2>::__value
                			     && __are_same<_ValueType1, _ValueType2>::__value);
                
                      return std::__copy_move_backward<_IsMove, __simple,
                	                               _Category>::__copy_move_b(__first,
                								 __last,
                								 __result);
                    }
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    inline _BI2
       ##### ->     __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      return _BI2(std::__copy_move_backward_a<_IsMove>
                		  (std::__niter_base(__first), std::__niter_base(__last),
                		   std::__niter_base(__result)));
                    }
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (first - last)
                   *
                   *  The function has the same effect as copy, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use copy instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    inline _BI2
       ##### ->     copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
                	      (std::__miter_base(__first), std::__miter_base(__last),
                	       __result));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (first - last)
                   *
                   *  The function has the same effect as move, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use move instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    inline _BI2
                    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
                						std::__miter_base(__last),
                						__result);
                    }
                
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
                #endif
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
                    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                 	     const _Tp& __value)
                    {
                      for (; __first != __last; ++__first)
                	*__first = __value;
                    }
                    
                  template<typename _ForwardIterator, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
                    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                	     const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (; __first != __last; ++__first)
                	*__first = __tmp;
                    }
                
                  // Specialization: for char types we can use memset.
                  template<typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
                    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
                    {
                      const _Tp __tmp = __c;
                      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
                		       __last - __first);
                    }
                
                  /**
                   *  @brief Fills the range [first,last) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   Nothing.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @c wmemset.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
                		    __value);
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      for (__decltype(__n + 0) __niter = __n;
                	   __niter > 0; --__niter, ++__first)
                	*__first = __value;
                      return __first;
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
           1 ->     __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (__decltype(__n + 0) __niter = __n;
                	   __niter > 0; --__niter, ++__first)
                	*__first = __tmp;
                      return __first;
                    }
                
                  template<typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
                    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
                    {
                      std::__fill_a(__first, __first + __n, __c);
                      return __first + __n;
                    }
                
                  /**
                   *  @brief Fills the range [first,first+n) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An output iterator.
                   *  @param  __n      The count of copies to perform.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   The iterator at first+n.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @ wmemset.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 865. More algorithms that throw away information
                  */
                  template<typename _OI, typename _Size, typename _Tp>
                    inline _OI
           1 ->     fill_n(_OI __first, _Size __n, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
                
                      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
                    }
                
                  template<bool _BoolType>
                    struct __equal
                    {
                      template<typename _II1, typename _II2>
                        static bool
                        equal(_II1 __first1, _II1 __last1, _II2 __first2)
                        {
                	  for (; __first1 != __last1; ++__first1, ++__first2)
                	    if (!(*__first1 == *__first2))
                	      return false;
                	  return true;
                	}
                    };
                
                  template<>
                    struct __equal<true>
                    {
                      template<typename _Tp>
                        static bool
                        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
                        {
                	  return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
                				   * (__last1 - __first1));
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    inline bool
                    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple = ((__is_integer<_ValueType1>::__value
                			      || __is_pointer<_ValueType1>::__value)
                	                     && __is_pointer<_II1>::__value
                	                     && __is_pointer<_II2>::__value
                			     && __are_same<_ValueType1, _ValueType2>::__value);
                
                      return std::__equal<__simple>::equal(__first1, __last1, __first2);
                    }
                
                
                  template<typename, typename>
                    struct __lc_rai
                    {
                      template<typename _II1, typename _II2>
                        static _II1
                        __newlast1(_II1, _II1 __last1, _II2, _II2)
                        { return __last1; }
                
                      template<typename _II>
                        static bool
                        __cnd2(_II __first, _II __last)
                        { return __first != __last; }
                    };
                
                  template<>
                    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
                    {
                      template<typename _RAI1, typename _RAI2>
                        static _RAI1
                        __newlast1(_RAI1 __first1, _RAI1 __last1,
                		   _RAI2 __first2, _RAI2 __last2)
                        {
                	  const typename iterator_traits<_RAI1>::difference_type
                	    __diff1 = __last1 - __first1;
                	  const typename iterator_traits<_RAI2>::difference_type
                	    __diff2 = __last2 - __first2;
                	  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
                	}
                
                      template<typename _RAI>
                        static bool
                        __cnd2(_RAI, _RAI)
                        { return true; }
                    };
                
                  template<bool _BoolType>
                    struct __lexicographical_compare
                    {
                      template<typename _II1, typename _II2>
                        static bool __lc(_II1, _II1, _II2, _II2);
                    };
                
                  template<bool _BoolType>
                    template<typename _II1, typename _II2>
                      bool
                      __lexicographical_compare<_BoolType>::
                      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                      {
                	typedef typename iterator_traits<_II1>::iterator_category _Category1;
                	typedef typename iterator_traits<_II2>::iterator_category _Category2;
                	typedef std::__lc_rai<_Category1, _Category2> 	__rai_type;
                	
                	__last1 = __rai_type::__newlast1(__first1, __last1,
                					 __first2, __last2);
                	for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
                	     ++__first1, ++__first2)
                	  {
                	    if (*__first1 < *__first2)
                	      return true;
                	    if (*__first2 < *__first1)
                	      return false;
                	  }
                	return __first1 == __last1 && __first2 != __last2;
                      }
                
                  template<>
                    struct __lexicographical_compare<true>
                    {
                      template<typename _Tp, typename _Up>
                        static bool
                        __lc(const _Tp* __first1, const _Tp* __last1,
                	     const _Up* __first2, const _Up* __last2)
                	{
                	  const size_t __len1 = __last1 - __first1;
                	  const size_t __len2 = __last2 - __first2;
                	  const int __result = __builtin_memcmp(__first1, __first2,
                						std::min(__len1, __len2));
                	  return __result != 0 ? __result < 0 : __len1 < __len2;
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    inline bool
                    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
                				  _II2 __first2, _II2 __last2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple =
                	(__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
                	 && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
                	 && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
                	 && __is_pointer<_II1>::__value
                	 && __is_pointer<_II2>::__value);
                
                      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
                							    __first2, __last2);
                    }
                
                  /**
                   *  @brief Finds the first position in which @a val could be inserted
                   *         without changing the ordering.
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return         An iterator pointing to the first element <em>not less
                   *                  than</em> @a val, or end() if every element is less than 
                   *                  @a val.
                   *  @ingroup binary_search_algorithms
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _ForwardIterator
                    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #endif
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (*__middle < __val)
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else
                	    __len = __half;
                	}
                      return __first;
                    }
                
                  /// This is a helper function for the sort routines and for random.tcc.
                  //  Precondition: __n > 0.
                  inline _GLIBCXX_CONSTEXPR int
                  __lg(int __n)
                  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned
                  __lg(unsigned __n)
                  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long
                  __lg(long __n)
                  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long
                  __lg(unsigned long __n)
                  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long long
                  __lg(long long __n)
                  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long long
                  __lg(unsigned long long __n)
                  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return std::__equal_aux(std::__niter_base(__first1),
                			      std::__niter_base(__last1),
                			      std::__niter_base(__first2));
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, ++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return true;
                    }
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  <em>Returns true if the sequence of elements defined by the range
                   *  [first1,last1) is lexicographically less than the sequence of elements
                   *  defined by the range [first2,last2).  Returns false otherwise.</em>
                   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
                   *  then this is an inline call to @c memcmp.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // concept requirements
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                #endif
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
                						std::__niter_base(__last1),
                						std::__niter_base(__first2),
                						std::__niter_base(__last2));
                    }
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   A boolean true or false.
                   *
                   *  The same as the four-parameter @c lexicographical_compare, but uses the
                   *  comp parameter instead of @c <.
                  */
                  template<typename _II1, typename _II2, typename _Compare>
                    bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2, _Compare __comp)
                    {
                      typedef typename iterator_traits<_II1>::iterator_category _Category1;
                      typedef typename iterator_traits<_II2>::iterator_category _Category2;
                      typedef std::__lc_rai<_Category1, _Category2> 	__rai_type;
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
                      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
                	   ++__first1, ++__first2)
                	{
                	  if (__comp(*__first1, *__first2))
                	    return true;
                	  if (__comp(*__first2, *__first1))
                	    return false;
                	}
                      return __first1 == __last1 && __first2 != __last2;
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      while (__first1 != __last1 && *__first1 == *__first2)
                        {
                	  ++__first1;
                	  ++__first2;
                        }
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
                        {
                	  ++__first1;
                	  ++__first2;
                        }
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                _GLIBCXX_END_NAMESPACE_ALGO
                } // namespace std
                
                // NB: This file is included within many other C++ includes, as a way
                // of getting the base algorithms. So, make sure that parallel bits
                // come in too if requested. 
                #ifdef _GLIBCXX_PARALLEL
                # include <parallel/algobase.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      277      80953
      288      53968
      368      26984
      379      26984
      424      26984
      450      26984
      216      13428
      746          1
      781          1

Execution Summary:

       14   Executable lines in this file
       14   Lines executed
   100.00   Percent of the file executed

   256287   Total number of line executions
 18306.21   Average executions per line


*** File /usr/include/opencv2/core/operations.hpp:
                /*M///////////////////////////////////////////////////////////////////////////////////////
                //
                //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
                //
                //  By downloading, copying, installing or using the software you agree to this license.
                //  If you do not agree to this license, do not download, install,
                //  copy or use the software.
                //
                //
                //                           License Agreement
                //                For Open Source Computer Vision Library
                //
                // Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
                // Copyright (C) 2009, Willow Garage Inc., all rights reserved.
                // Third party copyrights are property of their respective owners.
                //
                // Redistribution and use in source and binary forms, with or without modification,
                // are permitted provided that the following conditions are met:
                //
                //   * Redistribution's of source code must retain the above copyright notice,
                //     this list of conditions and the following disclaimer.
                //
                //   * Redistribution's in binary form must reproduce the above copyright notice,
                //     this list of conditions and the following disclaimer in the documentation
                //     and/or other materials provided with the distribution.
                //
                //   * The name of the copyright holders may not be used to endorse or promote products
                //     derived from this software without specific prior written permission.
                //
                // This software is provided by the copyright holders and contributors "as is" and
                // any express or implied warranties, including, but not limited to, the implied
                // warranties of merchantability and fitness for a particular purpose are disclaimed.
                // In no event shall the Intel Corporation or contributors be liable for any direct,
                // indirect, incidental, special, exemplary, or consequential damages
                // (including, but not limited to, procurement of substitute goods or services;
                // loss of use, data, or profits; or business interruption) however caused
                // and on any theory of liability, whether in contract, strict liability,
                // or tort (including negligence or otherwise) arising in any way out of
                // the use of this software, even if advised of the possibility of such damage.
                //
                //M*/
                
                #ifndef __OPENCV_CORE_OPERATIONS_HPP__
                #define __OPENCV_CORE_OPERATIONS_HPP__
                
                #ifndef SKIP_INCLUDES
                  #include <string.h>
                  #include <limits.h>
                #endif // SKIP_INCLUDES
                
                
                #ifdef __cplusplus
                
                /////// exchange-add operation for atomic operations on reference counters ///////
                #if defined __INTEL_COMPILER && !(defined WIN32 || defined _WIN32)   // atomic increment on the linux version of the Intel(tm) compiler
                  #define CV_XADD(addr,delta) _InterlockedExchangeAdd(const_cast<void*>(reinterpret_cast<volatile void*>(addr)), delta)
                #elif defined __GNUC__
                
                  #if defined __clang__ && __clang_major__ >= 3 && !defined __ANDROID__ && !defined __EMSCRIPTEN__  && !defined(__CUDACC__)
                    #ifdef __ATOMIC_SEQ_CST
                        #define CV_XADD(addr, delta) __c11_atomic_fetch_add((_Atomic(int)*)(addr), (delta), __ATOMIC_SEQ_CST)
                    #else
                        #define CV_XADD(addr, delta) __atomic_fetch_add((_Atomic(int)*)(addr), (delta), 5)
                    #endif
                  #elif __GNUC__*10 + __GNUC_MINOR__ >= 42
                
                    #if !(defined WIN32 || defined _WIN32) && (defined __i486__ || defined __i586__ || \
                        defined __i686__ || defined __MMX__ || defined __SSE__  || defined __ppc__) || \
                        (defined __GNUC__ && defined _STLPORT_MAJOR) || \
                        defined __EMSCRIPTEN__
                
                      #define CV_XADD __sync_fetch_and_add
                    #else
                      #include <ext/atomicity.h>
                      #define CV_XADD __gnu_cxx::__exchange_and_add
                    #endif
                
                  #else
                    #include <bits/atomicity.h>
                    #if __GNUC__*10 + __GNUC_MINOR__ >= 34
                      #define CV_XADD __gnu_cxx::__exchange_and_add
                    #else
                      #define CV_XADD __exchange_and_add
                    #endif
                  #endif
                
                #elif defined WIN32 || defined _WIN32 || defined WINCE
                  namespace cv { CV_EXPORTS int _interlockedExchangeAdd(int* addr, int delta); }
                  #define CV_XADD cv::_interlockedExchangeAdd
                
                #else
                  static inline int CV_XADD(int* addr, int delta)
                  { int tmp = *addr; *addr += delta; return tmp; }
                #endif
                
                #include <limits>
                
                #ifdef _MSC_VER
                # pragma warning(push)
                # pragma warning(disable:4127) //conditional expression is constant
                #endif
                
                namespace cv
                {
                
                using std::cos;
                using std::sin;
                using std::max;
                using std::min;
                using std::exp;
                using std::log;
                using std::pow;
                using std::sqrt;
                
                
                /////////////// saturate_cast (used in image & signal processing) ///////////////////
                
                template<typename _Tp> static inline _Tp saturate_cast(uchar v) { return _Tp(v); }
                template<typename _Tp> static inline _Tp saturate_cast(schar v) { return _Tp(v); }
                template<typename _Tp> static inline _Tp saturate_cast(ushort v) { return _Tp(v); }
                template<typename _Tp> static inline _Tp saturate_cast(short v) { return _Tp(v); }
                template<typename _Tp> static inline _Tp saturate_cast(unsigned v) { return _Tp(v); }
           4 -> template<typename _Tp> static inline _Tp saturate_cast(int v) { return _Tp(v); }
        3100 -> template<typename _Tp> static inline _Tp saturate_cast(float v) { return _Tp(v); }
                template<typename _Tp> static inline _Tp saturate_cast(double v) { return _Tp(v); }
                
                template<> inline uchar saturate_cast<uchar>(schar v)
                { return (uchar)std::max((int)v, 0); }
                template<> inline uchar saturate_cast<uchar>(ushort v)
                { return (uchar)std::min((unsigned)v, (unsigned)UCHAR_MAX); }
                template<> inline uchar saturate_cast<uchar>(int v)
                { return (uchar)((unsigned)v <= UCHAR_MAX ? v : v > 0 ? UCHAR_MAX : 0); }
                template<> inline uchar saturate_cast<uchar>(short v)
                { return saturate_cast<uchar>((int)v); }
                template<> inline uchar saturate_cast<uchar>(unsigned v)
                { return (uchar)std::min(v, (unsigned)UCHAR_MAX); }
                template<> inline uchar saturate_cast<uchar>(float v)
                { int iv = cvRound(v); return saturate_cast<uchar>(iv); }
                template<> inline uchar saturate_cast<uchar>(double v)
                { int iv = cvRound(v); return saturate_cast<uchar>(iv); }
                
                template<> inline schar saturate_cast<schar>(uchar v)
                { return (schar)std::min((int)v, SCHAR_MAX); }
                template<> inline schar saturate_cast<schar>(ushort v)
                { return (schar)std::min((unsigned)v, (unsigned)SCHAR_MAX); }
                template<> inline schar saturate_cast<schar>(int v)
                {
                    return (schar)((unsigned)(v-SCHAR_MIN) <= (unsigned)UCHAR_MAX ?
                                v : v > 0 ? SCHAR_MAX : SCHAR_MIN);
                }
                template<> inline schar saturate_cast<schar>(short v)
                { return saturate_cast<schar>((int)v); }
                template<> inline schar saturate_cast<schar>(unsigned v)
                { return (schar)std::min(v, (unsigned)SCHAR_MAX); }
                
                template<> inline schar saturate_cast<schar>(float v)
                { int iv = cvRound(v); return saturate_cast<schar>(iv); }
                template<> inline schar saturate_cast<schar>(double v)
                { int iv = cvRound(v); return saturate_cast<schar>(iv); }
                
                template<> inline ushort saturate_cast<ushort>(schar v)
                { return (ushort)std::max((int)v, 0); }
                template<> inline ushort saturate_cast<ushort>(short v)
                { return (ushort)std::max((int)v, 0); }
                template<> inline ushort saturate_cast<ushort>(int v)
                { return (ushort)((unsigned)v <= (unsigned)USHRT_MAX ? v : v > 0 ? USHRT_MAX : 0); }
                template<> inline ushort saturate_cast<ushort>(unsigned v)
                { return (ushort)std::min(v, (unsigned)USHRT_MAX); }
                template<> inline ushort saturate_cast<ushort>(float v)
                { int iv = cvRound(v); return saturate_cast<ushort>(iv); }
                template<> inline ushort saturate_cast<ushort>(double v)
                { int iv = cvRound(v); return saturate_cast<ushort>(iv); }
                
                template<> inline short saturate_cast<short>(ushort v)
                { return (short)std::min((int)v, SHRT_MAX); }
                template<> inline short saturate_cast<short>(int v)
                {
                    return (short)((unsigned)(v - SHRT_MIN) <= (unsigned)USHRT_MAX ?
                            v : v > 0 ? SHRT_MAX : SHRT_MIN);
                }
                template<> inline short saturate_cast<short>(unsigned v)
                { return (short)std::min(v, (unsigned)SHRT_MAX); }
                template<> inline short saturate_cast<short>(float v)
                { int iv = cvRound(v); return saturate_cast<short>(iv); }
                template<> inline short saturate_cast<short>(double v)
                { int iv = cvRound(v); return saturate_cast<short>(iv); }
                
                template<> inline int saturate_cast<int>(float v) { return cvRound(v); }
                template<> inline int saturate_cast<int>(double v) { return cvRound(v); }
                
                // we intentionally do not clip negative numbers, to make -1 become 0xffffffff etc.
                template<> inline unsigned saturate_cast<unsigned>(float v){ return cvRound(v); }
                template<> inline unsigned saturate_cast<unsigned>(double v) { return cvRound(v); }
                
                inline int fast_abs(uchar v) { return v; }
                inline int fast_abs(schar v) { return std::abs((int)v); }
                inline int fast_abs(ushort v) { return v; }
                inline int fast_abs(short v) { return std::abs((int)v); }
                inline int fast_abs(int v) { return std::abs(v); }
                inline float fast_abs(float v) { return std::abs(v); }
                inline double fast_abs(double v) { return std::abs(v); }
                
                //////////////////////////////// Matx /////////////////////////////////
                
                
        2619 -> template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx()
                {
                    for(int i = 0; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0)
                {
                    val[0] = v0;
                    for(int i = 1; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1)
                {
                    assert(channels >= 2);
                    val[0] = v0; val[1] = v1;
                    for(int i = 2; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2)
                {
                    assert(channels >= 3);
                    val[0] = v0; val[1] = v1; val[2] = v2;
                    for(int i = 3; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
                {
                    assert(channels >= 4);
                    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
                    for(int i = 4; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
                {
                    assert(channels >= 5);
                    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3; val[4] = v4;
                    for(int i = 5; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                                        _Tp v4, _Tp v5)
                {
                    assert(channels >= 6);
                    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
                    val[4] = v4; val[5] = v5;
                    for(int i = 6; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                                        _Tp v4, _Tp v5, _Tp v6)
                {
                    assert(channels >= 7);
                    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
                    val[4] = v4; val[5] = v5; val[6] = v6;
                    for(int i = 7; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7)
                {
                    assert(channels >= 8);
                    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
                    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
                    for(int i = 8; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                                                        _Tp v8)
                {
                    assert(channels >= 9);
                    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
                    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
                    val[8] = v8;
                    for(int i = 9; i < channels; i++) val[i] = _Tp(0);
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                                                        _Tp v8, _Tp v9)
                {
                    assert(channels >= 10);
                    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
                    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
                    val[8] = v8; val[9] = v9;
                    for(int i = 10; i < channels; i++) val[i] = _Tp(0);
                }
                
                
                template<typename _Tp, int m, int n>
                inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                            _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                            _Tp v8, _Tp v9, _Tp v10, _Tp v11)
                {
                    assert(channels == 12);
                    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
                    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
                    val[8] = v8; val[9] = v9; val[10] = v10; val[11] = v11;
                }
                
                template<typename _Tp, int m, int n>
                inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                           _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                           _Tp v8, _Tp v9, _Tp v10, _Tp v11,
                                           _Tp v12, _Tp v13, _Tp v14, _Tp v15)
                {
                    assert(channels == 16);
                    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
                    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
                    val[8] = v8; val[9] = v9; val[10] = v10; val[11] = v11;
                    val[12] = v12; val[13] = v13; val[14] = v14; val[15] = v15;
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(const _Tp* values)
                {
                    for( int i = 0; i < channels; i++ ) val[i] = values[i];
                }
                
                template<typename _Tp, int m, int n> inline Matx<_Tp, m, n> Matx<_Tp, m, n>::all(_Tp alpha)
                {
                    Matx<_Tp, m, n> M;
                    for( int i = 0; i < m*n; i++ ) M.val[i] = alpha;
                    return M;
                }
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n> Matx<_Tp,m,n>::zeros()
                {
                    return all(0);
                }
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n> Matx<_Tp,m,n>::ones()
                {
                    return all(1);
                }
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n> Matx<_Tp,m,n>::eye()
                {
                    Matx<_Tp,m,n> M;
                    for(int i = 0; i < MIN(m,n); i++)
                        M(i,i) = 1;
                    return M;
                }
                
                template<typename _Tp, int m, int n> inline _Tp Matx<_Tp, m, n>::dot(const Matx<_Tp, m, n>& M) const
                {
                    _Tp s = 0;
                    for( int i = 0; i < m*n; i++ ) s += val[i]*M.val[i];
                    return s;
                }
                
                
                template<typename _Tp, int m, int n> inline double Matx<_Tp, m, n>::ddot(const Matx<_Tp, m, n>& M) const
                {
                    double s = 0;
                    for( int i = 0; i < m*n; i++ ) s += (double)val[i]*M.val[i];
                    return s;
                }
                
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n> Matx<_Tp,m,n>::diag(const typename Matx<_Tp,m,n>::diag_type& d)
                {
                    Matx<_Tp,m,n> M;
                    for(int i = 0; i < MIN(m,n); i++)
                        M(i,i) = d(i, 0);
                    return M;
                }
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n> Matx<_Tp,m,n>::randu(_Tp a, _Tp b)
                {
                    Matx<_Tp,m,n> M;
                    Mat matM(M, false);
                    cv::randu(matM, Scalar(a), Scalar(b));
                    return M;
                }
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n> Matx<_Tp,m,n>::randn(_Tp a, _Tp b)
                {
                    Matx<_Tp,m,n> M;
                    Mat matM(M, false);
                    cv::randn(matM, Scalar(a), Scalar(b));
                    return M;
                }
                
                template<typename _Tp, int m, int n> template<typename T2>
                inline Matx<_Tp, m, n>::operator Matx<T2, m, n>() const
                {
                    Matx<T2, m, n> M;
                    for( int i = 0; i < m*n; i++ ) M.val[i] = saturate_cast<T2>(val[i]);
                    return M;
                }
                
                
                template<typename _Tp, int m, int n> template<int m1, int n1> inline
                Matx<_Tp, m1, n1> Matx<_Tp, m, n>::reshape() const
                {
                    CV_DbgAssert(m1*n1 == m*n);
                    return (const Matx<_Tp, m1, n1>&)*this;
                }
                
                
                template<typename _Tp, int m, int n>
                template<int m1, int n1> inline
                Matx<_Tp, m1, n1> Matx<_Tp, m, n>::get_minor(int i, int j) const
                {
                    CV_DbgAssert(0 <= i && i+m1 <= m && 0 <= j && j+n1 <= n);
                    Matx<_Tp, m1, n1> s;
                    for( int di = 0; di < m1; di++ )
                        for( int dj = 0; dj < n1; dj++ )
                            s(di, dj) = (*this)(i+di, j+dj);
                    return s;
                }
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp, 1, n> Matx<_Tp, m, n>::row(int i) const
                {
                    CV_DbgAssert((unsigned)i < (unsigned)m);
                    return Matx<_Tp, 1, n>(&val[i*n]);
                }
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp, m, 1> Matx<_Tp, m, n>::col(int j) const
                {
                    CV_DbgAssert((unsigned)j < (unsigned)n);
                    Matx<_Tp, m, 1> v;
                    for( int i = 0; i < m; i++ )
                        v.val[i] = val[i*n + j];
                    return v;
                }
                
                
                template<typename _Tp, int m, int n> inline
                typename Matx<_Tp, m, n>::diag_type Matx<_Tp, m, n>::diag() const
                {
                    diag_type d;
                    for( int i = 0; i < MIN(m, n); i++ )
                        d.val[i] = val[i*n + i];
                    return d;
                }
                
                
                template<typename _Tp, int m, int n> inline
                const _Tp& Matx<_Tp, m, n>::operator ()(int i, int j) const
                {
                    CV_DbgAssert( (unsigned)i < (unsigned)m && (unsigned)j < (unsigned)n );
                    return this->val[i*n + j];
                }
                
                
                template<typename _Tp, int m, int n> inline
                _Tp& Matx<_Tp, m, n>::operator ()(int i, int j)
                {
                    CV_DbgAssert( (unsigned)i < (unsigned)m && (unsigned)j < (unsigned)n );
                    return val[i*n + j];
                }
                
                
                template<typename _Tp, int m, int n> inline
                const _Tp& Matx<_Tp, m, n>::operator ()(int i) const
                {
                    CV_DbgAssert( (m == 1 || n == 1) && (unsigned)i < (unsigned)(m+n-1) );
                    return val[i];
                }
                
                
                template<typename _Tp, int m, int n> inline
                _Tp& Matx<_Tp, m, n>::operator ()(int i)
                {
                    CV_DbgAssert( (m == 1 || n == 1) && (unsigned)i < (unsigned)(m+n-1) );
                    return val[i];
                }
                
                
                template<typename _Tp1, typename _Tp2, int m, int n> static inline
                Matx<_Tp1, m, n>& operator += (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
                {
                    for( int i = 0; i < m*n; i++ )
                        a.val[i] = saturate_cast<_Tp1>(a.val[i] + b.val[i]);
                    return a;
                }
                
                
                template<typename _Tp1, typename _Tp2, int m, int n> static inline
                Matx<_Tp1, m, n>& operator -= (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
                {
                    for( int i = 0; i < m*n; i++ )
                        a.val[i] = saturate_cast<_Tp1>(a.val[i] - b.val[i]);
                    return a;
                }
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
                {
                    for( int i = 0; i < m*n; i++ )
                        val[i] = saturate_cast<_Tp>(a.val[i] + b.val[i]);
                }
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
                {
                    for( int i = 0; i < m*n; i++ )
                        val[i] = saturate_cast<_Tp>(a.val[i] - b.val[i]);
                }
                
                
                template<typename _Tp, int m, int n> template<typename _T2> inline
                Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
                {
                    for( int i = 0; i < m*n; i++ )
                        val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
                }
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
                {
                    for( int i = 0; i < m*n; i++ )
                        val[i] = saturate_cast<_Tp>(a.val[i] * b.val[i]);
                }
                
                
                template<typename _Tp, int m, int n> template<int l> inline
                Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
                {
                    for( int i = 0; i < m; i++ )
                        for( int j = 0; j < n; j++ )
                        {
                            _Tp s = 0;
                            for( int k = 0; k < l; k++ )
                                s += a(i, k) * b(k, j);
                            val[i*n + j] = s;
                        }
                }
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp,m,n>::Matx(const Matx<_Tp, n, m>& a, Matx_TOp)
                {
                    for( int i = 0; i < m; i++ )
                        for( int j = 0; j < n; j++ )
                            val[i*n + j] = a(j, i);
                }
                
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n> operator + (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
                {
                    return Matx<_Tp, m, n>(a, b, Matx_AddOp());
                }
                
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
                {
                    return Matx<_Tp, m, n>(a, b, Matx_SubOp());
                }
                
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, int alpha)
                {
                    for( int i = 0; i < m*n; i++ )
                        a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
                    return a;
                }
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, float alpha)
                {
                    for( int i = 0; i < m*n; i++ )
                        a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
                    return a;
                }
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, double alpha)
                {
                    for( int i = 0; i < m*n; i++ )
                        a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
                    return a;
                }
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, int alpha)
                {
                    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, float alpha)
                {
                    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, double alpha)
                {
                    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n> operator * (int alpha, const Matx<_Tp, m, n>& a)
                {
                    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n> operator * (float alpha, const Matx<_Tp, m, n>& a)
                {
                    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n> operator * (double alpha, const Matx<_Tp, m, n>& a)
                {
                    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int m, int n> static inline
                Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a)
                {
                    return Matx<_Tp, m, n>(a, -1, Matx_ScaleOp());
                }
                
                
                template<typename _Tp, int m, int n, int l> static inline
                Matx<_Tp, m, n> operator * (const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)
                {
                    return Matx<_Tp, m, n>(a, b, Matx_MatMulOp());
                }
                
                
                template<typename _Tp, int m, int n> static inline
                Vec<_Tp, m> operator * (const Matx<_Tp, m, n>& a, const Vec<_Tp, n>& b)
                {
                    Matx<_Tp, m, 1> c(a, b, Matx_MatMulOp());
                    return reinterpret_cast<const Vec<_Tp, m>&>(c);
                }
                
                
                template<typename _Tp> static inline
                Point_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)
                {
                    Matx<_Tp, 2, 1> tmp = a*Vec<_Tp,2>(b.x, b.y);
                    return Point_<_Tp>(tmp.val[0], tmp.val[1]);
                }
                
                
                template<typename _Tp> static inline
                Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)
                {
                    Matx<_Tp, 3, 1> tmp = a*Vec<_Tp,3>(b.x, b.y, b.z);
                    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
                }
                
                
                template<typename _Tp> static inline
                Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)
                {
                    Matx<_Tp, 3, 1> tmp = a*Vec<_Tp,3>(b.x, b.y, 1);
                    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
                }
                
                
                template<typename _Tp> static inline
                Matx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)
                {
                    return a*Matx<_Tp, 4, 1>(b.x, b.y, b.z, 1);
                }
                
                
                template<typename _Tp> static inline
                Scalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)
                {
                    Matx<double, 4, 1> c(Matx<double, 4, 4>(a), b, Matx_MatMulOp());
                    return static_cast<const Scalar&>(c);
                }
                
                
                static inline
                Scalar operator * (const Matx<double, 4, 4>& a, const Scalar& b)
                {
                    Matx<double, 4, 1> c(a, b, Matx_MatMulOp());
                    return static_cast<const Scalar&>(c);
                }
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp, m, n> Matx<_Tp, m, n>::mul(const Matx<_Tp, m, n>& a) const
                {
                    return Matx<_Tp, m, n>(*this, a, Matx_MulOp());
                }
                
                
                CV_EXPORTS int LU(float* A, size_t astep, int m, float* b, size_t bstep, int n);
                CV_EXPORTS int LU(double* A, size_t astep, int m, double* b, size_t bstep, int n);
                CV_EXPORTS bool Cholesky(float* A, size_t astep, int m, float* b, size_t bstep, int n);
                CV_EXPORTS bool Cholesky(double* A, size_t astep, int m, double* b, size_t bstep, int n);
                
                
                template<typename _Tp, int m> struct Matx_DetOp
                {
                    double operator ()(const Matx<_Tp, m, m>& a) const
                    {
                        Matx<_Tp, m, m> temp = a;
                        double p = LU(temp.val, m*sizeof(_Tp), m, 0, 0, 0);
                        if( p == 0 )
                            return p;
                        for( int i = 0; i < m; i++ )
                            p *= temp(i, i);
                        return 1./p;
                    }
                };
                
                
                template<typename _Tp> struct Matx_DetOp<_Tp, 1>
                {
                    double operator ()(const Matx<_Tp, 1, 1>& a) const
                    {
                        return a(0,0);
                    }
                };
                
                
                template<typename _Tp> struct Matx_DetOp<_Tp, 2>
                {
                    double operator ()(const Matx<_Tp, 2, 2>& a) const
                    {
                        return a(0,0)*a(1,1) - a(0,1)*a(1,0);
                    }
                };
                
                
                template<typename _Tp> struct Matx_DetOp<_Tp, 3>
                {
                    double operator ()(const Matx<_Tp, 3, 3>& a) const
                    {
                        return a(0,0)*(a(1,1)*a(2,2) - a(2,1)*a(1,2)) -
                            a(0,1)*(a(1,0)*a(2,2) - a(2,0)*a(1,2)) +
                            a(0,2)*(a(1,0)*a(2,1) - a(2,0)*a(1,1));
                    }
                };
                
                template<typename _Tp, int m> static inline
                double determinant(const Matx<_Tp, m, m>& a)
                {
                    return Matx_DetOp<_Tp, m>()(a);
                }
                
                
                template<typename _Tp, int m, int n> static inline
                double trace(const Matx<_Tp, m, n>& a)
                {
                    _Tp s = 0;
                    for( int i = 0; i < std::min(m, n); i++ )
                        s += a(i,i);
                    return s;
                }
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp, n, m> Matx<_Tp, m, n>::t() const
                {
                    return Matx<_Tp, n, m>(*this, Matx_TOp());
                }
                
                
                template<typename _Tp, int m> struct Matx_FastInvOp
                {
                    bool operator()(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const
                    {
                        Matx<_Tp, m, m> temp = a;
                
                        // assume that b is all 0's on input => make it a unity matrix
                        for( int i = 0; i < m; i++ )
                            b(i, i) = (_Tp)1;
                
                        if( method == DECOMP_CHOLESKY )
                            return Cholesky(temp.val, m*sizeof(_Tp), m, b.val, m*sizeof(_Tp), m);
                
                        return LU(temp.val, m*sizeof(_Tp), m, b.val, m*sizeof(_Tp), m) != 0;
                    }
                };
                
                
                template<typename _Tp> struct Matx_FastInvOp<_Tp, 2>
                {
                    bool operator()(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const
                    {
                        _Tp d = determinant(a);
                        if( d == 0 )
                            return false;
                        d = 1/d;
                        b(1,1) = a(0,0)*d;
                        b(0,0) = a(1,1)*d;
                        b(0,1) = -a(0,1)*d;
                        b(1,0) = -a(1,0)*d;
                        return true;
                    }
                };
                
                
                template<typename _Tp> struct Matx_FastInvOp<_Tp, 3>
                {
                    bool operator()(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const
                    {
                        _Tp d = (_Tp)determinant(a);
                        if( d == 0 )
                            return false;
                        d = 1/d;
                        b(0,0) = (a(1,1) * a(2,2) - a(1,2) * a(2,1)) * d;
                        b(0,1) = (a(0,2) * a(2,1) - a(0,1) * a(2,2)) * d;
                        b(0,2) = (a(0,1) * a(1,2) - a(0,2) * a(1,1)) * d;
                
                        b(1,0) = (a(1,2) * a(2,0) - a(1,0) * a(2,2)) * d;
                        b(1,1) = (a(0,0) * a(2,2) - a(0,2) * a(2,0)) * d;
                        b(1,2) = (a(0,2) * a(1,0) - a(0,0) * a(1,2)) * d;
                
                        b(2,0) = (a(1,0) * a(2,1) - a(1,1) * a(2,0)) * d;
                        b(2,1) = (a(0,1) * a(2,0) - a(0,0) * a(2,1)) * d;
                        b(2,2) = (a(0,0) * a(1,1) - a(0,1) * a(1,0)) * d;
                        return true;
                    }
                };
                
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp, n, m> Matx<_Tp, m, n>::inv(int method) const
                {
                    Matx<_Tp, n, m> b;
                    bool ok;
                    if( method == DECOMP_LU || method == DECOMP_CHOLESKY )
                        ok = Matx_FastInvOp<_Tp, m>()(*this, b, method);
                    else
                    {
                        Mat A(*this, false), B(b, false);
                        ok = (invert(A, B, method) != 0);
                    }
                    return ok ? b : Matx<_Tp, n, m>::zeros();
                }
                
                
                template<typename _Tp, int m, int n> struct Matx_FastSolveOp
                {
                    bool operator()(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b,
                                    Matx<_Tp, m, n>& x, int method) const
                    {
                        Matx<_Tp, m, m> temp = a;
                        x = b;
                        if( method == DECOMP_CHOLESKY )
                            return Cholesky(temp.val, m*sizeof(_Tp), m, x.val, n*sizeof(_Tp), n);
                
                        return LU(temp.val, m*sizeof(_Tp), m, x.val, n*sizeof(_Tp), n) != 0;
                    }
                };
                
                
                template<typename _Tp> struct Matx_FastSolveOp<_Tp, 2, 1>
                {
                    bool operator()(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b,
                                    Matx<_Tp, 2, 1>& x, int) const
                    {
                        _Tp d = determinant(a);
                        if( d == 0 )
                            return false;
                        d = 1/d;
                        x(0) = (b(0)*a(1,1) - b(1)*a(0,1))*d;
                        x(1) = (b(1)*a(0,0) - b(0)*a(1,0))*d;
                        return true;
                    }
                };
                
                
                template<typename _Tp> struct Matx_FastSolveOp<_Tp, 3, 1>
                {
                    bool operator()(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b,
                                    Matx<_Tp, 3, 1>& x, int) const
                    {
                        _Tp d = (_Tp)determinant(a);
                        if( d == 0 )
                            return false;
                        d = 1/d;
                        x(0) = d*(b(0)*(a(1,1)*a(2,2) - a(1,2)*a(2,1)) -
                                a(0,1)*(b(1)*a(2,2) - a(1,2)*b(2)) +
                                a(0,2)*(b(1)*a(2,1) - a(1,1)*b(2)));
                
                        x(1) = d*(a(0,0)*(b(1)*a(2,2) - a(1,2)*b(2)) -
                                b(0)*(a(1,0)*a(2,2) - a(1,2)*a(2,0)) +
                                a(0,2)*(a(1,0)*b(2) - b(1)*a(2,0)));
                
                        x(2) = d*(a(0,0)*(a(1,1)*b(2) - b(1)*a(2,1)) -
                                a(0,1)*(a(1,0)*b(2) - b(1)*a(2,0)) +
                                b(0)*(a(1,0)*a(2,1) - a(1,1)*a(2,0)));
                        return true;
                    }
                };
                
                
                template<typename _Tp, int m, int n> template<int l> inline
                Matx<_Tp, n, l> Matx<_Tp, m, n>::solve(const Matx<_Tp, m, l>& rhs, int method) const
                {
                    Matx<_Tp, n, l> x;
                    bool ok;
                    if( method == DECOMP_LU || method == DECOMP_CHOLESKY )
                        ok = Matx_FastSolveOp<_Tp, m, l>()(*this, rhs, x, method);
                    else
                    {
                        Mat A(*this, false), B(rhs, false), X(x, false);
                        ok = cv::solve(A, B, X, method);
                    }
                
                    return ok ? x : Matx<_Tp, n, l>::zeros();
                }
                
                template<typename _Tp, int m, int n> inline
                Vec<_Tp, n> Matx<_Tp, m, n>::solve(const Vec<_Tp, m>& rhs, int method) const
                {
                    Matx<_Tp, n, 1> x = solve(reinterpret_cast<const Matx<_Tp, m, 1>&>(rhs), method);
                    return reinterpret_cast<Vec<_Tp, n>&>(x);
                }
                
                template<typename _Tp, typename _AccTp> static inline
                _AccTp normL2Sqr(const _Tp* a, int n)
                {
                    _AccTp s = 0;
                    int i=0;
                 #if CV_ENABLE_UNROLLED
                    for( ; i <= n - 4; i += 4 )
                    {
                        _AccTp v0 = a[i], v1 = a[i+1], v2 = a[i+2], v3 = a[i+3];
                        s += v0*v0 + v1*v1 + v2*v2 + v3*v3;
                    }
                #endif
                    for( ; i < n; i++ )
                    {
                        _AccTp v = a[i];
                        s += v*v;
                    }
                    return s;
                }
                
                
                template<typename _Tp, typename _AccTp> static inline
                _AccTp normL1(const _Tp* a, int n)
                {
                    _AccTp s = 0;
                    int i = 0;
                #if CV_ENABLE_UNROLLED
                    for(; i <= n - 4; i += 4 )
                    {
                        s += (_AccTp)fast_abs(a[i]) + (_AccTp)fast_abs(a[i+1]) +
                            (_AccTp)fast_abs(a[i+2]) + (_AccTp)fast_abs(a[i+3]);
                    }
                #endif
                    for( ; i < n; i++ )
                        s += fast_abs(a[i]);
                    return s;
                }
                
                
                template<typename _Tp, typename _AccTp> static inline
                _AccTp normInf(const _Tp* a, int n)
                {
                    _AccTp s = 0;
                    for( int i = 0; i < n; i++ )
                        s = std::max(s, (_AccTp)fast_abs(a[i]));
                    return s;
                }
                
                
                template<typename _Tp, typename _AccTp> static inline
                _AccTp normL2Sqr(const _Tp* a, const _Tp* b, int n)
                {
                    _AccTp s = 0;
                    int i= 0;
                #if CV_ENABLE_UNROLLED
                    for(; i <= n - 4; i += 4 )
                    {
                        _AccTp v0 = _AccTp(a[i] - b[i]), v1 = _AccTp(a[i+1] - b[i+1]), v2 = _AccTp(a[i+2] - b[i+2]), v3 = _AccTp(a[i+3] - b[i+3]);
                        s += v0*v0 + v1*v1 + v2*v2 + v3*v3;
                    }
                #endif
                    for( ; i < n; i++ )
                    {
                        _AccTp v = _AccTp(a[i] - b[i]);
                        s += v*v;
                    }
                    return s;
                }
                
                CV_EXPORTS float normL2Sqr_(const float* a, const float* b, int n);
                CV_EXPORTS float normL1_(const float* a, const float* b, int n);
                CV_EXPORTS int normL1_(const uchar* a, const uchar* b, int n);
                CV_EXPORTS int normHamming(const uchar* a, const uchar* b, int n);
                CV_EXPORTS int normHamming(const uchar* a, const uchar* b, int n, int cellSize);
                
                template<> inline float normL2Sqr(const float* a, const float* b, int n)
                {
                    if( n >= 8 )
                        return normL2Sqr_(a, b, n);
                    float s = 0;
                    for( int i = 0; i < n; i++ )
                    {
                        float v = a[i] - b[i];
                        s += v*v;
                    }
                    return s;
                }
                
                
                template<typename _Tp, typename _AccTp> static inline
                _AccTp normL1(const _Tp* a, const _Tp* b, int n)
                {
                    _AccTp s = 0;
                    int i= 0;
                #if CV_ENABLE_UNROLLED
                    for(; i <= n - 4; i += 4 )
                    {
                        _AccTp v0 = _AccTp(a[i] - b[i]), v1 = _AccTp(a[i+1] - b[i+1]), v2 = _AccTp(a[i+2] - b[i+2]), v3 = _AccTp(a[i+3] - b[i+3]);
                        s += std::abs(v0) + std::abs(v1) + std::abs(v2) + std::abs(v3);
                    }
                #endif
                    for( ; i < n; i++ )
                    {
                        _AccTp v = _AccTp(a[i] - b[i]);
                        s += std::abs(v);
                    }
                    return s;
                }
                
                template<> inline float normL1(const float* a, const float* b, int n)
                {
                    if( n >= 8 )
                        return normL1_(a, b, n);
                    float s = 0;
                    for( int i = 0; i < n; i++ )
                    {
                        float v = a[i] - b[i];
                        s += std::abs(v);
                    }
                    return s;
                }
                
                template<> inline int normL1(const uchar* a, const uchar* b, int n)
                {
                    return normL1_(a, b, n);
                }
                
                template<typename _Tp, typename _AccTp> static inline
                _AccTp normInf(const _Tp* a, const _Tp* b, int n)
                {
                    _AccTp s = 0;
                    for( int i = 0; i < n; i++ )
                    {
                        _AccTp v0 = a[i] - b[i];
                        s = std::max(s, std::abs(v0));
                    }
                    return s;
                }
                
                
                template<typename _Tp, int m, int n> static inline
                double norm(const Matx<_Tp, m, n>& M)
                {
                    return std::sqrt(normL2Sqr<_Tp, double>(M.val, m*n));
                }
                
                
                template<typename _Tp, int m, int n> static inline
                double norm(const Matx<_Tp, m, n>& M, int normType)
                {
                    return normType == NORM_INF ? (double)normInf<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n) :
                        normType == NORM_L1 ? (double)normL1<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n) :
                        std::sqrt((double)normL2Sqr<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n));
                }
                
                
                template<typename _Tp, int m, int n> static inline
                bool operator == (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
                {
                    for( int i = 0; i < m*n; i++ )
                        if( a.val[i] != b.val[i] ) return false;
                    return true;
                }
                
                template<typename _Tp, int m, int n> static inline
                bool operator != (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
                {
                    return !(a == b);
                }
                
                
                template<typename _Tp, typename _T2, int m, int n> static inline
                MatxCommaInitializer<_Tp, m, n> operator << (const Matx<_Tp, m, n>& mtx, _T2 val)
                {
                    MatxCommaInitializer<_Tp, m, n> commaInitializer((Matx<_Tp, m, n>*)&mtx);
                    return (commaInitializer, val);
                }
                
                template<typename _Tp, int m, int n> inline
                MatxCommaInitializer<_Tp, m, n>::MatxCommaInitializer(Matx<_Tp, m, n>* _mtx)
                    : dst(_mtx), idx(0)
                {}
                
                template<typename _Tp, int m, int n> template<typename _T2> inline
                MatxCommaInitializer<_Tp, m, n>& MatxCommaInitializer<_Tp, m, n>::operator , (_T2 value)
                {
                    CV_DbgAssert( idx < m*n );
                    dst->val[idx++] = saturate_cast<_Tp>(value);
                    return *this;
                }
                
                template<typename _Tp, int m, int n> inline
                Matx<_Tp, m, n> MatxCommaInitializer<_Tp, m, n>::operator *() const
                {
                    CV_DbgAssert( idx == n*m );
                    return *dst;
                }
                
                /////////////////////////// short vector (Vec) /////////////////////////////
                
        2619 -> template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec()
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0)
                    : Matx<_Tp, cn, 1>(v0)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1)
                    : Matx<_Tp, cn, 1>(v0, v1)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2)
                    : Matx<_Tp, cn, 1>(v0, v1, v2)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
                    : Matx<_Tp, cn, 1>(v0, v1, v2, v3)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
                    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
                    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                                        _Tp v4, _Tp v5, _Tp v6)
                    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7)
                    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                                                        _Tp v8)
                    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7, v8)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
                                                                        _Tp v4, _Tp v5, _Tp v6, _Tp v7,
                                                                        _Tp v8, _Tp v9)
                    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const _Tp* values)
                    : Matx<_Tp, cn, 1>(values)
                {}
                
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const Vec<_Tp, cn>& m)
                    : Matx<_Tp, cn, 1>(m.val)
                {}
                
                template<typename _Tp, int cn> inline
                Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp op)
                : Matx<_Tp, cn, 1>(a, b, op)
                {}
                
                template<typename _Tp, int cn> inline
                Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp op)
                : Matx<_Tp, cn, 1>(a, b, op)
                {}
                
                template<typename _Tp, int cn> template<typename _T2> inline
                Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp op)
                : Matx<_Tp, cn, 1>(a, alpha, op)
                {}
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::all(_Tp alpha)
                {
                    Vec v;
                    for( int i = 0; i < cn; i++ ) v.val[i] = alpha;
                    return v;
                }
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::mul(const Vec<_Tp, cn>& v) const
                {
                    Vec<_Tp, cn> w;
                    for( int i = 0; i < cn; i++ ) w.val[i] = saturate_cast<_Tp>(this->val[i]*v.val[i]);
                    return w;
                }
                
                template<typename _Tp> Vec<_Tp, 2> conjugate(const Vec<_Tp, 2>& v)
                {
                    return Vec<_Tp, 2>(v[0], -v[1]);
                }
                
                template<typename _Tp> Vec<_Tp, 4> conjugate(const Vec<_Tp, 4>& v)
                {
                    return Vec<_Tp, 4>(v[0], -v[1], -v[2], -v[3]);
                }
                
                template<> inline Vec<float, 2> Vec<float, 2>::conj() const
                {
                    return conjugate(*this);
                }
                
                template<> inline Vec<double, 2> Vec<double, 2>::conj() const
                {
                    return conjugate(*this);
                }
                
                template<> inline Vec<float, 4> Vec<float, 4>::conj() const
                {
                    return conjugate(*this);
                }
                
                template<> inline Vec<double, 4> Vec<double, 4>::conj() const
                {
                    return conjugate(*this);
                }
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::cross(const Vec<_Tp, cn>&) const
                {
                    CV_Error(CV_StsError, "for arbitrary-size vector there is no cross-product defined");
                    return Vec<_Tp, cn>();
                }
                
                template<typename _Tp, int cn> template<typename T2>
                inline Vec<_Tp, cn>::operator Vec<T2, cn>() const
                {
                    Vec<T2, cn> v;
                    for( int i = 0; i < cn; i++ ) v.val[i] = saturate_cast<T2>(this->val[i]);
                    return v;
                }
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn>::operator CvScalar() const
                {
                    CvScalar s = {{0,0,0,0}};
                    int i;
                    for( i = 0; i < std::min(cn, 4); i++ ) s.val[i] = this->val[i];
                    for( ; i < 4; i++ ) s.val[i] = 0;
                    return s;
                }
                
                template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator [](int i) const
                {
                    CV_DbgAssert( (unsigned)i < (unsigned)cn );
                    return this->val[i];
                }
                
                template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator [](int i)
                {
                    CV_DbgAssert( (unsigned)i < (unsigned)cn );
                    return this->val[i];
                }
                
                template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator ()(int i) const
                {
                    CV_DbgAssert( (unsigned)i < (unsigned)cn );
                    return this->val[i];
                }
                
                template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator ()(int i)
                {
                    CV_DbgAssert( (unsigned)i < (unsigned)cn );
                    return this->val[i];
                }
                
                template<typename _Tp1, typename _Tp2, int cn> static inline Vec<_Tp1, cn>&
                operator += (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
                {
                    for( int i = 0; i < cn; i++ )
                        a.val[i] = saturate_cast<_Tp1>(a.val[i] + b.val[i]);
                    return a;
                }
                
                template<typename _Tp1, typename _Tp2, int cn> static inline Vec<_Tp1, cn>&
                operator -= (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
                {
                    for( int i = 0; i < cn; i++ )
                        a.val[i] = saturate_cast<_Tp1>(a.val[i] - b.val[i]);
                    return a;
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator + (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
                {
                    return Vec<_Tp, cn>(a, b, Matx_AddOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator - (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
                {
                    return Vec<_Tp, cn>(a, b, Matx_SubOp());
                }
                
                template<typename _Tp, int cn> static inline
                Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, int alpha)
                {
                    for( int i = 0; i < cn; i++ )
                        a[i] = saturate_cast<_Tp>(a[i]*alpha);
                    return a;
                }
                
                template<typename _Tp, int cn> static inline
                Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, float alpha)
                {
                    for( int i = 0; i < cn; i++ )
                        a[i] = saturate_cast<_Tp>(a[i]*alpha);
                    return a;
                }
                
                template<typename _Tp, int cn> static inline
                Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, double alpha)
                {
                    for( int i = 0; i < cn; i++ )
                        a[i] = saturate_cast<_Tp>(a[i]*alpha);
                    return a;
                }
                
                template<typename _Tp, int cn> static inline
                Vec<_Tp, cn>& operator /= (Vec<_Tp, cn>& a, int alpha)
                {
                    double ialpha = 1./alpha;
                    for( int i = 0; i < cn; i++ )
                        a[i] = saturate_cast<_Tp>(a[i]*ialpha);
                    return a;
                }
                
                template<typename _Tp, int cn> static inline
                Vec<_Tp, cn>& operator /= (Vec<_Tp, cn>& a, float alpha)
                {
                    float ialpha = 1.f/alpha;
                    for( int i = 0; i < cn; i++ )
                        a[i] = saturate_cast<_Tp>(a[i]*ialpha);
                    return a;
                }
                
                template<typename _Tp, int cn> static inline
                Vec<_Tp, cn>& operator /= (Vec<_Tp, cn>& a, double alpha)
                {
                    double ialpha = 1./alpha;
                    for( int i = 0; i < cn; i++ )
                        a[i] = saturate_cast<_Tp>(a[i]*ialpha);
                    return a;
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator * (const Vec<_Tp, cn>& a, int alpha)
                {
                    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator * (int alpha, const Vec<_Tp, cn>& a)
                {
                    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator * (const Vec<_Tp, cn>& a, float alpha)
                {
                    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator * (float alpha, const Vec<_Tp, cn>& a)
                {
                    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator * (const Vec<_Tp, cn>& a, double alpha)
                {
                    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator * (double alpha, const Vec<_Tp, cn>& a)
                {
                    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator / (const Vec<_Tp, cn>& a, int alpha)
                {
                    return Vec<_Tp, cn>(a, 1./alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator / (const Vec<_Tp, cn>& a, float alpha)
                {
                    return Vec<_Tp, cn>(a, 1.f/alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator / (const Vec<_Tp, cn>& a, double alpha)
                {
                    return Vec<_Tp, cn>(a, 1./alpha, Matx_ScaleOp());
                }
                
                template<typename _Tp, int cn> static inline Vec<_Tp, cn>
                operator - (const Vec<_Tp, cn>& a)
                {
                    Vec<_Tp,cn> t;
                    for( int i = 0; i < cn; i++ ) t.val[i] = saturate_cast<_Tp>(-a.val[i]);
                    return t;
                }
                
                template<typename _Tp> inline Vec<_Tp, 4> operator * (const Vec<_Tp, 4>& v1, const Vec<_Tp, 4>& v2)
                {
                    return Vec<_Tp, 4>(saturate_cast<_Tp>(v1[0]*v2[0] - v1[1]*v2[1] - v1[2]*v2[2] - v1[3]*v2[3]),
                                       saturate_cast<_Tp>(v1[0]*v2[1] + v1[1]*v2[0] + v1[2]*v2[3] - v1[3]*v2[2]),
                                       saturate_cast<_Tp>(v1[0]*v2[2] - v1[1]*v2[3] + v1[2]*v2[0] + v1[3]*v2[1]),
                                       saturate_cast<_Tp>(v1[0]*v2[3] + v1[1]*v2[2] - v1[2]*v2[1] + v1[3]*v2[0]));
                }
                
                template<typename _Tp> inline Vec<_Tp, 4>& operator *= (Vec<_Tp, 4>& v1, const Vec<_Tp, 4>& v2)
                {
                    v1 = v1 * v2;
                    return v1;
                }
                
                template<> inline Vec<float, 3> Vec<float, 3>::cross(const Vec<float, 3>& v) const
                {
                    return Vec<float,3>(val[1]*v.val[2] - val[2]*v.val[1],
                                     val[2]*v.val[0] - val[0]*v.val[2],
                                     val[0]*v.val[1] - val[1]*v.val[0]);
                }
                
                template<> inline Vec<double, 3> Vec<double, 3>::cross(const Vec<double, 3>& v) const
                {
                    return Vec<double,3>(val[1]*v.val[2] - val[2]*v.val[1],
                                     val[2]*v.val[0] - val[0]*v.val[2],
                                     val[0]*v.val[1] - val[1]*v.val[0]);
                }
                
                template<typename _Tp, int cn> inline Vec<_Tp, cn> normalize(const Vec<_Tp, cn>& v)
                {
                    double nv = norm(v);
                    return v * (nv ? 1./nv : 0.);
                }
                
                template<typename _Tp, typename _T2, int cn> static inline
                VecCommaInitializer<_Tp, cn> operator << (const Vec<_Tp, cn>& vec, _T2 val)
                {
                    VecCommaInitializer<_Tp, cn> commaInitializer((Vec<_Tp, cn>*)&vec);
                    return (commaInitializer, val);
                }
                
                template<typename _Tp, int cn> inline
                VecCommaInitializer<_Tp, cn>::VecCommaInitializer(Vec<_Tp, cn>* _vec)
                    : MatxCommaInitializer<_Tp, cn, 1>(_vec)
                {}
                
                template<typename _Tp, int cn> template<typename _T2> inline
                VecCommaInitializer<_Tp, cn>& VecCommaInitializer<_Tp, cn>::operator , (_T2 value)
                {
                    CV_DbgAssert( this->idx < cn );
                    this->dst->val[this->idx++] = saturate_cast<_Tp>(value);
                    return *this;
                }
                
                template<typename _Tp, int cn> inline
                Vec<_Tp, cn> VecCommaInitializer<_Tp, cn>::operator *() const
                {
                    CV_DbgAssert( this->idx == cn );
                    return *this->dst;
                }
                
                //////////////////////////////// Complex //////////////////////////////
                
                template<typename _Tp> inline Complex<_Tp>::Complex() : re(0), im(0) {}
                template<typename _Tp> inline Complex<_Tp>::Complex( _Tp _re, _Tp _im ) : re(_re), im(_im) {}
                template<typename _Tp> template<typename T2> inline Complex<_Tp>::operator Complex<T2>() const
                { return Complex<T2>(saturate_cast<T2>(re), saturate_cast<T2>(im)); }
                template<typename _Tp> inline Complex<_Tp> Complex<_Tp>::conj() const
                { return Complex<_Tp>(re, -im); }
                
                template<typename _Tp> static inline
                bool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)
                { return a.re == b.re && a.im == b.im; }
                
                template<typename _Tp> static inline
                bool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)
                { return a.re != b.re || a.im != b.im; }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)
                { return Complex<_Tp>( a.re + b.re, a.im + b.im ); }
                
                template<typename _Tp> static inline
                Complex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)
                { a.re += b.re; a.im += b.im; return a; }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)
                { return Complex<_Tp>( a.re - b.re, a.im - b.im ); }
                
                template<typename _Tp> static inline
                Complex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)
                { a.re -= b.re; a.im -= b.im; return a; }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator - (const Complex<_Tp>& a)
                { return Complex<_Tp>(-a.re, -a.im); }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)
                { return Complex<_Tp>( a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re ); }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)
                { return Complex<_Tp>( a.re*b, a.im*b ); }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)
                { return Complex<_Tp>( a.re*b, a.im*b ); }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)
                { return Complex<_Tp>( a.re + b, a.im ); }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)
                { return Complex<_Tp>( a.re - b, a.im ); }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)
                { return Complex<_Tp>( a.re + b, a.im ); }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)
                { return Complex<_Tp>( b - a.re, -a.im ); }
                
                template<typename _Tp> static inline
                Complex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)
                { a.re += b; return a; }
                
                template<typename _Tp> static inline
                Complex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)
                { a.re -= b; return a; }
                
                template<typename _Tp> static inline
                Complex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)
                { a.re *= b; a.im *= b; return a; }
                
                template<typename _Tp> static inline
                double abs(const Complex<_Tp>& a)
                { return std::sqrt( (double)a.re*a.re + (double)a.im*a.im); }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator / (const Complex<_Tp>& a, const Complex<_Tp>& b)
                {
                    double t = 1./((double)b.re*b.re + (double)b.im*b.im);
                    return Complex<_Tp>( (_Tp)((a.re*b.re + a.im*b.im)*t),
                                        (_Tp)((-a.re*b.im + a.im*b.re)*t) );
                }
                
                template<typename _Tp> static inline
                Complex<_Tp>& operator /= (Complex<_Tp>& a, const Complex<_Tp>& b)
                {
                    return (a = a / b);
                }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator / (const Complex<_Tp>& a, _Tp b)
                {
                    _Tp t = (_Tp)1/b;
                    return Complex<_Tp>( a.re*t, a.im*t );
                }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator / (_Tp b, const Complex<_Tp>& a)
                {
                    return Complex<_Tp>(b)/a;
                }
                
                template<typename _Tp> static inline
                Complex<_Tp> operator /= (const Complex<_Tp>& a, _Tp b)
                {
                    _Tp t = (_Tp)1/b;
                    a.re *= t; a.im *= t; return a;
                }
                
                //////////////////////////////// 2D Point ////////////////////////////////
                
           5 -> template<typename _Tp> inline Point_<_Tp>::Point_() : x(0), y(0) {}
        7689 -> template<typename _Tp> inline Point_<_Tp>::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) {}
       14464 -> template<typename _Tp> inline Point_<_Tp>::Point_(const Point_& pt) : x(pt.x), y(pt.y) {}
                template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint& pt) : x((_Tp)pt.x), y((_Tp)pt.y) {}
                template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint2D32f& pt)
                    : x(saturate_cast<_Tp>(pt.x)), y(saturate_cast<_Tp>(pt.y)) {}
                template<typename _Tp> inline Point_<_Tp>::Point_(const Size_<_Tp>& sz) : x(sz.width), y(sz.height) {}
                template<typename _Tp> inline Point_<_Tp>::Point_(const Vec<_Tp,2>& v) : x(v[0]), y(v[1]) {}
        7468 -> template<typename _Tp> inline Point_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)
                { x = pt.x; y = pt.y; return *this; }
                
           2 -> template<typename _Tp> template<typename _Tp2> inline Point_<_Tp>::operator Point_<_Tp2>() const
                { return Point_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y)); }
                template<typename _Tp> inline Point_<_Tp>::operator CvPoint() const
                { return cvPoint(saturate_cast<int>(x), saturate_cast<int>(y)); }
                template<typename _Tp> inline Point_<_Tp>::operator CvPoint2D32f() const
                { return cvPoint2D32f((float)x, (float)y); }
                template<typename _Tp> inline Point_<_Tp>::operator Vec<_Tp, 2>() const
                { return Vec<_Tp, 2>(x, y); }
                
                template<typename _Tp> inline _Tp Point_<_Tp>::dot(const Point_& pt) const
                { return saturate_cast<_Tp>(x*pt.x + y*pt.y); }
                template<typename _Tp> inline double Point_<_Tp>::ddot(const Point_& pt) const
                { return (double)x*pt.x + (double)y*pt.y; }
                
                template<typename _Tp> inline double Point_<_Tp>::cross(const Point_& pt) const
                { return (double)x*pt.y - (double)y*pt.x; }
                
                template<typename _Tp> static inline Point_<_Tp>&
                operator += (Point_<_Tp>& a, const Point_<_Tp>& b)
                {
                    a.x = saturate_cast<_Tp>(a.x + b.x);
                    a.y = saturate_cast<_Tp>(a.y + b.y);
                    return a;
                }
                
                template<typename _Tp> static inline Point_<_Tp>&
                operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)
                {
                    a.x = saturate_cast<_Tp>(a.x - b.x);
                    a.y = saturate_cast<_Tp>(a.y - b.y);
                    return a;
                }
                
                template<typename _Tp> static inline Point_<_Tp>&
                operator *= (Point_<_Tp>& a, int b)
                {
                    a.x = saturate_cast<_Tp>(a.x*b);
                    a.y = saturate_cast<_Tp>(a.y*b);
                    return a;
                }
                
                template<typename _Tp> static inline Point_<_Tp>&
                operator *= (Point_<_Tp>& a, float b)
                {
                    a.x = saturate_cast<_Tp>(a.x*b);
                    a.y = saturate_cast<_Tp>(a.y*b);
                    return a;
                }
                
                template<typename _Tp> static inline Point_<_Tp>&
                operator *= (Point_<_Tp>& a, double b)
                {
                    a.x = saturate_cast<_Tp>(a.x*b);
                    a.y = saturate_cast<_Tp>(a.y*b);
                    return a;
                }
                
        1550 -> template<typename _Tp> static inline double norm(const Point_<_Tp>& pt)
                { return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y); }
                
                template<typename _Tp> static inline bool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)
                { return a.x == b.x && a.y == b.y; }
                
                template<typename _Tp> static inline bool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)
                { return a.x != b.x || a.y != b.y; }
                
                template<typename _Tp> static inline Point_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)
                { return Point_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y) ); }
                
        1550 -> template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)
                { return Point_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y) ); }
                
                template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a)
                { return Point_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y) ); }
                
                template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, int b)
                { return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) ); }
                
                template<typename _Tp> static inline Point_<_Tp> operator * (int a, const Point_<_Tp>& b)
                { return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) ); }
                
                template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, float b)
                { return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) ); }
                
                template<typename _Tp> static inline Point_<_Tp> operator * (float a, const Point_<_Tp>& b)
                { return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) ); }
                
                template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, double b)
                { return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) ); }
                
                template<typename _Tp> static inline Point_<_Tp> operator * (double a, const Point_<_Tp>& b)
                { return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) ); }
                
                //////////////////////////////// 3D Point ////////////////////////////////
                
                template<typename _Tp> inline Point3_<_Tp>::Point3_() : x(0), y(0), z(0) {}
                template<typename _Tp> inline Point3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z) : x(_x), y(_y), z(_z) {}
                template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point3_& pt) : x(pt.x), y(pt.y), z(pt.z) {}
                template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point_<_Tp>& pt) : x(pt.x), y(pt.y), z(_Tp()) {}
                template<typename _Tp> inline Point3_<_Tp>::Point3_(const CvPoint3D32f& pt) :
                    x(saturate_cast<_Tp>(pt.x)), y(saturate_cast<_Tp>(pt.y)), z(saturate_cast<_Tp>(pt.z)) {}
                template<typename _Tp> inline Point3_<_Tp>::Point3_(const Vec<_Tp, 3>& v) : x(v[0]), y(v[1]), z(v[2]) {}
                
                template<typename _Tp> template<typename _Tp2> inline Point3_<_Tp>::operator Point3_<_Tp2>() const
                { return Point3_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(z)); }
                
                template<typename _Tp> inline Point3_<_Tp>::operator CvPoint3D32f() const
                { return cvPoint3D32f((float)x, (float)y, (float)z); }
                
                template<typename _Tp> inline Point3_<_Tp>::operator Vec<_Tp, 3>() const
                { return Vec<_Tp, 3>(x, y, z); }
                
                template<typename _Tp> inline Point3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)
                { x = pt.x; y = pt.y; z = pt.z; return *this; }
                
                template<typename _Tp> inline _Tp Point3_<_Tp>::dot(const Point3_& pt) const
                { return saturate_cast<_Tp>(x*pt.x + y*pt.y + z*pt.z); }
                template<typename _Tp> inline double Point3_<_Tp>::ddot(const Point3_& pt) const
                { return (double)x*pt.x + (double)y*pt.y + (double)z*pt.z; }
                
                template<typename _Tp> inline Point3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const
                {
                    return Point3_<_Tp>(y*pt.z - z*pt.y, z*pt.x - x*pt.z, x*pt.y - y*pt.x);
                }
                
                template<typename _Tp> static inline Point3_<_Tp>&
                operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)
                {
                    a.x = saturate_cast<_Tp>(a.x + b.x);
                    a.y = saturate_cast<_Tp>(a.y + b.y);
                    a.z = saturate_cast<_Tp>(a.z + b.z);
                    return a;
                }
                
                template<typename _Tp> static inline Point3_<_Tp>&
                operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)
                {
                    a.x = saturate_cast<_Tp>(a.x - b.x);
                    a.y = saturate_cast<_Tp>(a.y - b.y);
                    a.z = saturate_cast<_Tp>(a.z - b.z);
                    return a;
                }
                
                template<typename _Tp> static inline Point3_<_Tp>&
                operator *= (Point3_<_Tp>& a, int b)
                {
                    a.x = saturate_cast<_Tp>(a.x*b);
                    a.y = saturate_cast<_Tp>(a.y*b);
                    a.z = saturate_cast<_Tp>(a.z*b);
                    return a;
                }
                
                template<typename _Tp> static inline Point3_<_Tp>&
                operator *= (Point3_<_Tp>& a, float b)
                {
                    a.x = saturate_cast<_Tp>(a.x*b);
                    a.y = saturate_cast<_Tp>(a.y*b);
                    a.z = saturate_cast<_Tp>(a.z*b);
                    return a;
                }
                
                template<typename _Tp> static inline Point3_<_Tp>&
                operator *= (Point3_<_Tp>& a, double b)
                {
                    a.x = saturate_cast<_Tp>(a.x*b);
                    a.y = saturate_cast<_Tp>(a.y*b);
                    a.z = saturate_cast<_Tp>(a.z*b);
                    return a;
                }
                
                template<typename _Tp> static inline double norm(const Point3_<_Tp>& pt)
                { return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y + (double)pt.z*pt.z); }
                
                template<typename _Tp> static inline bool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
                { return a.x == b.x && a.y == b.y && a.z == b.z; }
                
                template<typename _Tp> static inline bool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
                { return a.x != b.x || a.y != b.y || a.z != b.z; }
                
                template<typename _Tp> static inline Point3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
                { return Point3_<_Tp>( saturate_cast<_Tp>(a.x + b.x),
                                      saturate_cast<_Tp>(a.y + b.y),
                                      saturate_cast<_Tp>(a.z + b.z)); }
                
                template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
                { return Point3_<_Tp>( saturate_cast<_Tp>(a.x - b.x),
                                        saturate_cast<_Tp>(a.y - b.y),
                                        saturate_cast<_Tp>(a.z - b.z)); }
                
                template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a)
                { return Point3_<_Tp>( saturate_cast<_Tp>(-a.x),
                                      saturate_cast<_Tp>(-a.y),
                                      saturate_cast<_Tp>(-a.z) ); }
                
                template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, int b)
                { return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b),
                                      saturate_cast<_Tp>(a.y*b),
                                      saturate_cast<_Tp>(a.z*b) ); }
                
                template<typename _Tp> static inline Point3_<_Tp> operator * (int a, const Point3_<_Tp>& b)
                { return Point3_<_Tp>( saturate_cast<_Tp>(b.x*a),
                                      saturate_cast<_Tp>(b.y*a),
                                      saturate_cast<_Tp>(b.z*a) ); }
                
                template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, float b)
                { return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b),
                                      saturate_cast<_Tp>(a.y*b),
                                      saturate_cast<_Tp>(a.z*b) ); }
                
                template<typename _Tp> static inline Point3_<_Tp> operator * (float a, const Point3_<_Tp>& b)
                { return Point3_<_Tp>( saturate_cast<_Tp>(b.x*a),
                                      saturate_cast<_Tp>(b.y*a),
                                      saturate_cast<_Tp>(b.z*a) ); }
                
                template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, double b)
                { return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b),
                                      saturate_cast<_Tp>(a.y*b),
                                      saturate_cast<_Tp>(a.z*b) ); }
                
                template<typename _Tp> static inline Point3_<_Tp> operator * (double a, const Point3_<_Tp>& b)
                { return Point3_<_Tp>( saturate_cast<_Tp>(b.x*a),
                                      saturate_cast<_Tp>(b.y*a),
                                      saturate_cast<_Tp>(b.z*a) ); }
                
                //////////////////////////////// Size ////////////////////////////////
                
        8382 -> template<typename _Tp> inline Size_<_Tp>::Size_()
                    : width(0), height(0) {}
                template<typename _Tp> inline Size_<_Tp>::Size_(_Tp _width, _Tp _height)
                    : width(_width), height(_height) {}
                template<typename _Tp> inline Size_<_Tp>::Size_(const Size_& sz)
                    : width(sz.width), height(sz.height) {}
                template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize& sz)
                    : width(saturate_cast<_Tp>(sz.width)), height(saturate_cast<_Tp>(sz.height)) {}
                template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize2D32f& sz)
                    : width(saturate_cast<_Tp>(sz.width)), height(saturate_cast<_Tp>(sz.height)) {}
                template<typename _Tp> inline Size_<_Tp>::Size_(const Point_<_Tp>& pt) : width(pt.x), height(pt.y) {}
                
                template<typename _Tp> template<typename _Tp2> inline Size_<_Tp>::operator Size_<_Tp2>() const
                { return Size_<_Tp2>(saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height)); }
                template<typename _Tp> inline Size_<_Tp>::operator CvSize() const
                { return cvSize(saturate_cast<int>(width), saturate_cast<int>(height)); }
                template<typename _Tp> inline Size_<_Tp>::operator CvSize2D32f() const
                { return cvSize2D32f((float)width, (float)height); }
                
                template<typename _Tp> inline Size_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)
                { width = sz.width; height = sz.height; return *this; }
                template<typename _Tp> static inline Size_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)
                { return Size_<_Tp>(a.width * b, a.height * b); }
                template<typename _Tp> static inline Size_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)
                { return Size_<_Tp>(a.width + b.width, a.height + b.height); }
                template<typename _Tp> static inline Size_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)
                { return Size_<_Tp>(a.width - b.width, a.height - b.height); }
                template<typename _Tp> inline _Tp Size_<_Tp>::area() const { return width*height; }
                
                template<typename _Tp> static inline Size_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)
                { a.width += b.width; a.height += b.height; return a; }
                template<typename _Tp> static inline Size_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)
                { a.width -= b.width; a.height -= b.height; return a; }
                
                template<typename _Tp> static inline bool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)
                { return a.width == b.width && a.height == b.height; }
                template<typename _Tp> static inline bool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)
                { return a.width != b.width || a.height != b.height; }
                
                //////////////////////////////// Rect ////////////////////////////////
                
                
           1 -> template<typename _Tp> inline Rect_<_Tp>::Rect_() : x(0), y(0), width(0), height(0) {}
          99 -> template<typename _Tp> inline Rect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height) {}
        3492 -> template<typename _Tp> inline Rect_<_Tp>::Rect_(const Rect_<_Tp>& r) : x(r.x), y(r.y), width(r.width), height(r.height) {}
                template<typename _Tp> inline Rect_<_Tp>::Rect_(const CvRect& r) : x((_Tp)r.x), y((_Tp)r.y), width((_Tp)r.width), height((_Tp)r.height) {}
                template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz) :
                    x(org.x), y(org.y), width(sz.width), height(sz.height) {}
                template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
                {
                    x = std::min(pt1.x, pt2.x); y = std::min(pt1.y, pt2.y);
                    width = std::max(pt1.x, pt2.x) - x; height = std::max(pt1.y, pt2.y) - y;
                }
         972 -> template<typename _Tp> inline Rect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )
                { x = r.x; y = r.y; width = r.width; height = r.height; return *this; }
                
                template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::tl() const { return Point_<_Tp>(x,y); }
                template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::br() const { return Point_<_Tp>(x+width, y+height); }
                
                template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )
                { a.x += b.x; a.y += b.y; return a; }
                template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )
                { a.x -= b.x; a.y -= b.y; return a; }
                
                template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )
                { a.width += b.width; a.height += b.height; return a; }
                
                template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )
                { a.width -= b.width; a.height -= b.height; return a; }
                
                template<typename _Tp> static inline Rect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
                {
                    _Tp x1 = std::max(a.x, b.x), y1 = std::max(a.y, b.y);
                    a.width = std::min(a.x + a.width, b.x + b.width) - x1;
                    a.height = std::min(a.y + a.height, b.y + b.height) - y1;
                    a.x = x1; a.y = y1;
                    if( a.width <= 0 || a.height <= 0 )
                        a = Rect();
                    return a;
                }
                
                template<typename _Tp> static inline Rect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
                {
                    _Tp x1 = std::min(a.x, b.x), y1 = std::min(a.y, b.y);
                    a.width = std::max(a.x + a.width, b.x + b.width) - x1;
                    a.height = std::max(a.y + a.height, b.y + b.height) - y1;
                    a.x = x1; a.y = y1;
                    return a;
                }
                
                template<typename _Tp> inline Size_<_Tp> Rect_<_Tp>::size() const { return Size_<_Tp>(width, height); }
                template<typename _Tp> inline _Tp Rect_<_Tp>::area() const { return width*height; }
                
                template<typename _Tp> template<typename _Tp2> inline Rect_<_Tp>::operator Rect_<_Tp2>() const
                { return Rect_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y),
                                     saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height)); }
                template<typename _Tp> inline Rect_<_Tp>::operator CvRect() const
                { return cvRect(saturate_cast<int>(x), saturate_cast<int>(y),
                                saturate_cast<int>(width), saturate_cast<int>(height)); }
                
                template<typename _Tp> inline bool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const
                { return x <= pt.x && pt.x < x + width && y <= pt.y && pt.y < y + height; }
                
                template<typename _Tp> static inline bool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
                {
                    return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
                }
                
                template<typename _Tp> static inline bool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
                {
                    return a.x != b.x || a.y != b.y || a.width != b.width || a.height != b.height;
                }
                
                template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)
                {
                    return Rect_<_Tp>( a.x + b.x, a.y + b.y, a.width, a.height );
                }
                
                template<typename _Tp> static inline Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)
                {
                    return Rect_<_Tp>( a.x - b.x, a.y - b.y, a.width, a.height );
                }
                
                template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)
                {
                    return Rect_<_Tp>( a.x, a.y, a.width + b.width, a.height + b.height );
                }
                
                template<typename _Tp> static inline Rect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
                {
                    Rect_<_Tp> c = a;
                    return c &= b;
                }
                
                template<typename _Tp> static inline Rect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
                {
                    Rect_<_Tp> c = a;
                    return c |= b;
                }
                
                template<typename _Tp> inline bool Point_<_Tp>::inside( const Rect_<_Tp>& r ) const
                {
                    return r.contains(*this);
                }
                
                inline RotatedRect::RotatedRect() { angle = 0; }
                inline RotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)
                    : center(_center), size(_size), angle(_angle) {}
                inline RotatedRect::RotatedRect(const CvBox2D& box)
                    : center(box.center), size(box.size), angle(box.angle) {}
                inline RotatedRect::operator CvBox2D() const
                {
                    CvBox2D box; box.center = center; box.size = size; box.angle = angle;
                    return box;
                }
                
                //////////////////////////////// Scalar_ ///////////////////////////////
                
                template<typename _Tp> inline Scalar_<_Tp>::Scalar_()
                { this->val[0] = this->val[1] = this->val[2] = this->val[3] = 0; }
                
        2619 -> template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
                { this->val[0] = v0; this->val[1] = v1; this->val[2] = v2; this->val[3] = v3; }
                
                template<typename _Tp> inline Scalar_<_Tp>::Scalar_(const CvScalar& s)
                {
                    this->val[0] = saturate_cast<_Tp>(s.val[0]);
                    this->val[1] = saturate_cast<_Tp>(s.val[1]);
                    this->val[2] = saturate_cast<_Tp>(s.val[2]);
                    this->val[3] = saturate_cast<_Tp>(s.val[3]);
                }
                
                template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0)
                { this->val[0] = v0; this->val[1] = this->val[2] = this->val[3] = 0; }
                
                template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)
                { return Scalar_<_Tp>(v0, v0, v0, v0); }
                template<typename _Tp> inline Scalar_<_Tp>::operator CvScalar() const
                { return cvScalar(this->val[0], this->val[1], this->val[2], this->val[3]); }
                
                template<typename _Tp> template<typename T2> inline Scalar_<_Tp>::operator Scalar_<T2>() const
                {
                    return Scalar_<T2>(saturate_cast<T2>(this->val[0]),
                                  saturate_cast<T2>(this->val[1]),
                                  saturate_cast<T2>(this->val[2]),
                                  saturate_cast<T2>(this->val[3]));
                }
                
                template<typename _Tp> static inline Scalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
                {
                    a.val[0] = saturate_cast<_Tp>(a.val[0] + b.val[0]);
                    a.val[1] = saturate_cast<_Tp>(a.val[1] + b.val[1]);
                    a.val[2] = saturate_cast<_Tp>(a.val[2] + b.val[2]);
                    a.val[3] = saturate_cast<_Tp>(a.val[3] + b.val[3]);
                    return a;
                }
                
                template<typename _Tp> static inline Scalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
                {
                    a.val[0] = saturate_cast<_Tp>(a.val[0] - b.val[0]);
                    a.val[1] = saturate_cast<_Tp>(a.val[1] - b.val[1]);
                    a.val[2] = saturate_cast<_Tp>(a.val[2] - b.val[2]);
                    a.val[3] = saturate_cast<_Tp>(a.val[3] - b.val[3]);
                    return a;
                }
                
                template<typename _Tp> static inline Scalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )
                {
                    a.val[0] = saturate_cast<_Tp>(a.val[0] * v);
                    a.val[1] = saturate_cast<_Tp>(a.val[1] * v);
                    a.val[2] = saturate_cast<_Tp>(a.val[2] * v);
                    a.val[3] = saturate_cast<_Tp>(a.val[3] * v);
                    return a;
                }
                
                template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& t, double scale ) const
                {
                    return Scalar_<_Tp>( saturate_cast<_Tp>(this->val[0]*t.val[0]*scale),
                                       saturate_cast<_Tp>(this->val[1]*t.val[1]*scale),
                                       saturate_cast<_Tp>(this->val[2]*t.val[2]*scale),
                                       saturate_cast<_Tp>(this->val[3]*t.val[3]*scale));
                }
                
                template<typename _Tp> static inline bool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
                {
                    return a.val[0] == b.val[0] && a.val[1] == b.val[1] &&
                        a.val[2] == b.val[2] && a.val[3] == b.val[3];
                }
                
                template<typename _Tp> static inline bool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
                {
                    return a.val[0] != b.val[0] || a.val[1] != b.val[1] ||
                        a.val[2] != b.val[2] || a.val[3] != b.val[3];
                }
                
                template<typename _Tp> static inline Scalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
                {
                    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] + b.val[0]),
                                      saturate_cast<_Tp>(a.val[1] + b.val[1]),
                                      saturate_cast<_Tp>(a.val[2] + b.val[2]),
                                      saturate_cast<_Tp>(a.val[3] + b.val[3]));
                }
                
                template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
                {
                    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] - b.val[0]),
                                      saturate_cast<_Tp>(a.val[1] - b.val[1]),
                                      saturate_cast<_Tp>(a.val[2] - b.val[2]),
                                      saturate_cast<_Tp>(a.val[3] - b.val[3]));
                }
                
                template<typename _Tp> static inline Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)
                {
                    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] * alpha),
                                      saturate_cast<_Tp>(a.val[1] * alpha),
                                      saturate_cast<_Tp>(a.val[2] * alpha),
                                      saturate_cast<_Tp>(a.val[3] * alpha));
                }
                
                template<typename _Tp> static inline Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)
                {
                    return a*alpha;
                }
                
                template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a)
                {
                    return Scalar_<_Tp>(saturate_cast<_Tp>(-a.val[0]), saturate_cast<_Tp>(-a.val[1]),
                                      saturate_cast<_Tp>(-a.val[2]), saturate_cast<_Tp>(-a.val[3]));
                }
                
                
                template<typename _Tp> static inline Scalar_<_Tp>
                operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
                {
                    return Scalar_<_Tp>(saturate_cast<_Tp>(a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3]),
                                        saturate_cast<_Tp>(a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2]),
                                        saturate_cast<_Tp>(a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1]),
                                        saturate_cast<_Tp>(a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0]));
                }
                
                template<typename _Tp> static inline Scalar_<_Tp>&
                operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
                {
                    a = a*b;
                    return a;
                }
                
                template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::conj() const
                {
                    return Scalar_<_Tp>(saturate_cast<_Tp>(this->val[0]),
                                        saturate_cast<_Tp>(-this->val[1]),
                                        saturate_cast<_Tp>(-this->val[2]),
                                        saturate_cast<_Tp>(-this->val[3]));
                }
                
                template<typename _Tp> inline bool Scalar_<_Tp>::isReal() const
                {
                    return this->val[1] == 0 && this->val[2] == 0 && this->val[3] == 0;
                }
                
                template<typename _Tp> static inline
                Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, _Tp alpha)
                {
                    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] / alpha),
                                        saturate_cast<_Tp>(a.val[1] / alpha),
                                        saturate_cast<_Tp>(a.val[2] / alpha),
                                        saturate_cast<_Tp>(a.val[3] / alpha));
                }
                
                template<typename _Tp> static inline
                Scalar_<float> operator / (const Scalar_<float>& a, float alpha)
                {
                    float s = 1/alpha;
                    return Scalar_<float>(a.val[0]*s, a.val[1]*s, a.val[2]*s, a.val[3]*s);
                }
                
                template<typename _Tp> static inline
                Scalar_<double> operator / (const Scalar_<double>& a, double alpha)
                {
                    double s = 1/alpha;
                    return Scalar_<double>(a.val[0]*s, a.val[1]*s, a.val[2]*s, a.val[3]*s);
                }
                
                template<typename _Tp> static inline
                Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, _Tp alpha)
                {
                    a = a/alpha;
                    return a;
                }
                
                template<typename _Tp> static inline
                Scalar_<_Tp> operator / (_Tp a, const Scalar_<_Tp>& b)
                {
                    _Tp s = a/(b[0]*b[0] + b[1]*b[1] + b[2]*b[2] + b[3]*b[3]);
                    return b.conj()*s;
                }
                
                template<typename _Tp> static inline
                Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
                {
                    return a*((_Tp)1/b);
                }
                
                template<typename _Tp> static inline
                Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
                {
                    a = a/b;
                    return a;
                }
                
                //////////////////////////////// Range /////////////////////////////////
                
                inline Range::Range() : start(0), end(0) {}
        1746 -> inline Range::Range(int _start, int _end) : start(_start), end(_end) {}
                inline Range::Range(const CvSlice& slice) : start(slice.start_index), end(slice.end_index)
                {
                    if( start == 0 && end == CV_WHOLE_SEQ_END_INDEX )
                        *this = Range::all();
                }
                
                inline int Range::size() const { return end - start; }
                inline bool Range::empty() const { return start == end; }
         873 -> inline Range Range::all() { return Range(INT_MIN, INT_MAX); }
                
                static inline bool operator == (const Range& r1, const Range& r2)
                { return r1.start == r2.start && r1.end == r2.end; }
                
                static inline bool operator != (const Range& r1, const Range& r2)
                { return !(r1 == r2); }
                
                static inline bool operator !(const Range& r)
                { return r.start == r.end; }
                
                static inline Range operator & (const Range& r1, const Range& r2)
                {
                    Range r(std::max(r1.start, r2.start), std::min(r1.end, r2.end));
                    r.end = std::max(r.end, r.start);
                    return r;
                }
                
                static inline Range& operator &= (Range& r1, const Range& r2)
                {
                    r1 = r1 & r2;
                    return r1;
                }
                
                static inline Range operator + (const Range& r1, int delta)
                {
                    return Range(r1.start + delta, r1.end + delta);
                }
                
                static inline Range operator + (int delta, const Range& r1)
                {
                    return Range(r1.start + delta, r1.end + delta);
                }
                
                static inline Range operator - (const Range& r1, int delta)
                {
                    return r1 + (-delta);
                }
                
                inline Range::operator CvSlice() const
                { return *this != Range::all() ? cvSlice(start, end) : CV_WHOLE_SEQ; }
                
                
                
                //////////////////////////////// Vector ////////////////////////////////
                
                // template vector class. It is similar to STL's vector,
                // with a few important differences:
                //   1) it can be created on top of user-allocated data w/o copying it
                //   2) vector b = a means copying the header,
                //      not the underlying data (use clone() to make a deep copy)
                template <typename _Tp> class Vector
                {
                public:
                    typedef _Tp value_type;
                    typedef _Tp* iterator;
                    typedef const _Tp* const_iterator;
                    typedef _Tp& reference;
                    typedef const _Tp& const_reference;
                
                    struct Hdr
                    {
                        Hdr() : data(0), datastart(0), refcount(0), size(0), capacity(0) {};
                        _Tp* data;
                        _Tp* datastart;
                        int* refcount;
                        size_t size;
                        size_t capacity;
                    };
                
                    Vector() {}
                    Vector(size_t _size)  { resize(_size); }
                    Vector(size_t _size, const _Tp& val)
                    {
                        resize(_size);
                        for(size_t i = 0; i < _size; i++)
                            hdr.data[i] = val;
                    }
                    Vector(_Tp* _data, size_t _size, bool _copyData=false)
                    { set(_data, _size, _copyData); }
                
                    template<int n> Vector(const Vec<_Tp, n>& vec)
                    { set((_Tp*)&vec.val[0], n, true); }
                
                    Vector(const std::vector<_Tp>& vec, bool _copyData=false)
                    { set(!vec.empty() ? (_Tp*)&vec[0] : 0, vec.size(), _copyData); }
                
                    Vector(const Vector& d) { *this = d; }
                
                    Vector(const Vector& d, const Range& r_)
                    {
                        Range r = r_ == Range::all() ? Range(0, d.size()) : r_;
                        /*if( r == Range::all() )
                            r = Range(0, d.size());*/
                        if( r.size() > 0 && r.start >= 0 && r.end <= d.size() )
                        {
                            if( d.hdr.refcount )
                                CV_XADD(d.hdr.refcount, 1);
                            hdr.refcount = d.hdr.refcount;
                            hdr.datastart = d.hdr.datastart;
                            hdr.data = d.hdr.data + r.start;
                            hdr.capacity = hdr.size = r.size();
                        }
                    }
                
                    Vector<_Tp>& operator = (const Vector& d)
                    {
                        if( this != &d )
                        {
                            if( d.hdr.refcount )
                                CV_XADD(d.hdr.refcount, 1);
                            release();
                            hdr = d.hdr;
                        }
                        return *this;
                    }
                
                    ~Vector()  { release(); }
                
                    Vector<_Tp> clone() const
                    { return hdr.data ? Vector<_Tp>(hdr.data, hdr.size, true) : Vector<_Tp>(); }
                
                    void copyTo(Vector<_Tp>& vec) const
                    {
                        size_t i, sz = size();
                        vec.resize(sz);
                        const _Tp* src = hdr.data;
                        _Tp* dst = vec.hdr.data;
                        for( i = 0; i < sz; i++ )
                            dst[i] = src[i];
                    }
                
                    void copyTo(std::vector<_Tp>& vec) const
                    {
                        size_t i, sz = size();
                        vec.resize(sz);
                        const _Tp* src = hdr.data;
                        _Tp* dst = sz ? &vec[0] : 0;
                        for( i = 0; i < sz; i++ )
                            dst[i] = src[i];
                    }
                
                    operator CvMat() const
                    { return cvMat((int)size(), 1, type(), (void*)hdr.data); }
                
                    _Tp& operator [] (size_t i) { CV_DbgAssert( i < size() ); return hdr.data[i]; }
                    const _Tp& operator [] (size_t i) const { CV_DbgAssert( i < size() ); return hdr.data[i]; }
                    Vector operator() (const Range& r) const { return Vector(*this, r); }
                    _Tp& back() { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }
                    const _Tp& back() const { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }
                    _Tp& front() { CV_DbgAssert(!empty()); return hdr.data[0]; }
                    const _Tp& front() const { CV_DbgAssert(!empty()); return hdr.data[0]; }
                
                    _Tp* begin() { return hdr.data; }
                    _Tp* end() { return hdr.data + hdr.size; }
                    const _Tp* begin() const { return hdr.data; }
                    const _Tp* end() const { return hdr.data + hdr.size; }
                
                    void addref() { if( hdr.refcount ) CV_XADD(hdr.refcount, 1); }
                    void release()
                    {
                        if( hdr.refcount && CV_XADD(hdr.refcount, -1) == 1 )
                        {
                            delete[] hdr.datastart;
                            delete hdr.refcount;
                        }
                        hdr = Hdr();
                    }
                
                    void set(_Tp* _data, size_t _size, bool _copyData=false)
                    {
                        if( !_copyData )
                        {
                            release();
                            hdr.data = hdr.datastart = _data;
                            hdr.size = hdr.capacity = _size;
                            hdr.refcount = 0;
                        }
                        else
                        {
                            reserve(_size);
                            for( size_t i = 0; i < _size; i++ )
                                hdr.data[i] = _data[i];
                            hdr.size = _size;
                        }
                    }
                
                    void reserve(size_t newCapacity)
                    {
                        _Tp* newData;
                        int* newRefcount;
                        size_t i, oldSize = hdr.size;
                        if( (!hdr.refcount || *hdr.refcount == 1) && hdr.capacity >= newCapacity )
                            return;
                        newCapacity = std::max(newCapacity, oldSize);
                        newData = new _Tp[newCapacity];
                        newRefcount = new int(1);
                        for( i = 0; i < oldSize; i++ )
                            newData[i] = hdr.data[i];
                        release();
                        hdr.data = hdr.datastart = newData;
                        hdr.capacity = newCapacity;
                        hdr.size = oldSize;
                        hdr.refcount = newRefcount;
                    }
                
                    void resize(size_t newSize)
                    {
                        size_t i;
                        newSize = std::max(newSize, (size_t)0);
                        if( (!hdr.refcount || *hdr.refcount == 1) && hdr.size == newSize )
                            return;
                        if( newSize > hdr.capacity )
                            reserve(std::max(newSize, std::max((size_t)4, hdr.capacity*2)));
                        for( i = hdr.size; i < newSize; i++ )
                            hdr.data[i] = _Tp();
                        hdr.size = newSize;
                    }
                
                    Vector<_Tp>& push_back(const _Tp& elem)
                    {
                        if( hdr.size == hdr.capacity )
                            reserve( std::max((size_t)4, hdr.capacity*2) );
                        hdr.data[hdr.size++] = elem;
                        return *this;
                    }
                
                    Vector<_Tp>& pop_back()
                    {
                        if( hdr.size > 0 )
                            --hdr.size;
                        return *this;
                    }
                
                    size_t size() const { return hdr.size; }
                    size_t capacity() const { return hdr.capacity; }
                    bool empty() const { return hdr.size == 0; }
                    void clear() { resize(0); }
                    int type() const { return DataType<_Tp>::type; }
                
                protected:
                    Hdr hdr;
                };
                
                
                template<typename _Tp> inline typename DataType<_Tp>::work_type
                dot(const Vector<_Tp>& v1, const Vector<_Tp>& v2)
                {
                    typedef typename DataType<_Tp>::work_type _Tw;
                    size_t i = 0, n = v1.size();
                    assert(v1.size() == v2.size());
                
                    _Tw s = 0;
                    const _Tp *ptr1 = &v1[0], *ptr2 = &v2[0];
                    for( ; i < n; i++ )
                        s += (_Tw)ptr1[i]*ptr2[i];
                
                    return s;
                }
                
                // Multiply-with-Carry RNG
                inline RNG::RNG() { state = 0xffffffff; }
                inline RNG::RNG(uint64 _state) { state = _state ? _state : 0xffffffff; }
                inline unsigned RNG::next()
                {
                    state = (uint64)(unsigned)state*CV_RNG_COEFF + (unsigned)(state >> 32);
                    return (unsigned)state;
                }
                
                inline RNG::operator uchar() { return (uchar)next(); }
                inline RNG::operator schar() { return (schar)next(); }
                inline RNG::operator ushort() { return (ushort)next(); }
                inline RNG::operator short() { return (short)next(); }
                inline RNG::operator unsigned() { return next(); }
                inline unsigned RNG::operator ()(unsigned N) {return (unsigned)uniform(0,N);}
                inline unsigned RNG::operator ()() {return next();}
                inline RNG::operator int() { return (int)next(); }
                // * (2^32-1)^-1
                inline RNG::operator float() { return next()*2.3283064365386962890625e-10f; }
                inline RNG::operator double()
                {
                    unsigned t = next();
                    return (((uint64)t << 32) | next())*5.4210108624275221700372640043497e-20;
                }
                inline int RNG::uniform(int a, int b) { return a == b ? a : (int)(next()%(b - a) + a); }
                inline float RNG::uniform(float a, float b) { return ((float)*this)*(b - a) + a; }
                inline double RNG::uniform(double a, double b) { return ((double)*this)*(b - a) + a; }
                
                inline TermCriteria::TermCriteria() : type(0), maxCount(0), epsilon(0) {}
                inline TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)
                    : type(_type), maxCount(_maxCount), epsilon(_epsilon) {}
                inline TermCriteria::TermCriteria(const CvTermCriteria& criteria)
                    : type(criteria.type), maxCount(criteria.max_iter), epsilon(criteria.epsilon) {}
                inline TermCriteria::operator CvTermCriteria() const
                { return cvTermCriteria(type, maxCount, epsilon); }
                
                inline uchar* LineIterator::operator *() { return ptr; }
                inline LineIterator& LineIterator::operator ++()
                {
                    int mask = err < 0 ? -1 : 0;
                    err += minusDelta + (plusDelta & mask);
                    ptr += minusStep + (plusStep & mask);
                    return *this;
                }
                inline LineIterator LineIterator::operator ++(int)
                {
                    LineIterator it = *this;
                    ++(*this);
                    return it;
                }
                inline Point LineIterator::pos() const
                {
                    Point p;
                    p.y = (int)((ptr - ptr0)/step);
                    p.x = (int)(((ptr - ptr0) - p.y*step)/elemSize);
                    return p;
                }
                
                /////////////////////////////// AutoBuffer ////////////////////////////////////////
                
                template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer()
                {
                    ptr = buf;
                    size = fixed_size;
                }
                
                template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer(size_t _size)
                {
                    ptr = buf;
                    size = fixed_size;
                    allocate(_size);
                }
                
                template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::~AutoBuffer()
                { deallocate(); }
                
                template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::allocate(size_t _size)
                {
                    if(_size <= size)
                        return;
                    deallocate();
                    if(_size > fixed_size)
                    {
                        ptr = cv::allocate<_Tp>(_size);
                        size = _size;
                    }
                }
                
                template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::deallocate()
                {
                    if( ptr != buf )
                    {
                        cv::deallocate<_Tp>(ptr, size);
                        ptr = buf;
                        size = fixed_size;
                    }
                }
                
                template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator _Tp* ()
                { return ptr; }
                
                template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator const _Tp* () const
                { return ptr; }
                
                
                /////////////////////////////////// Ptr ////////////////////////////////////////
                
                template<typename _Tp> inline Ptr<_Tp>::Ptr() : obj(0), refcount(0) {}
                template<typename _Tp> inline Ptr<_Tp>::Ptr(_Tp* _obj) : obj(_obj)
                {
                    if(obj)
                    {
                        refcount = (int*)fastMalloc(sizeof(*refcount));
                        *refcount = 1;
                    }
                    else
                        refcount = 0;
                }
                
                template<typename _Tp> inline void Ptr<_Tp>::addref()
                { if( refcount ) CV_XADD(refcount, 1); }
                
                template<typename _Tp> inline void Ptr<_Tp>::release()
                {
                    if( refcount && CV_XADD(refcount, -1) == 1 )
                    {
                        delete_obj();
                        fastFree(refcount);
                    }
                    refcount = 0;
                    obj = 0;
                }
                
                template<typename _Tp> inline void Ptr<_Tp>::delete_obj()
                {
                    if( obj ) delete obj;
                }
                
                template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }
                
                template<typename _Tp> inline Ptr<_Tp>::Ptr(const Ptr<_Tp>& _ptr)
                {
                    obj = _ptr.obj;
                    refcount = _ptr.refcount;
                    addref();
                }
                
                template<typename _Tp> inline Ptr<_Tp>& Ptr<_Tp>::operator = (const Ptr<_Tp>& _ptr)
                {
                    if (this != &_ptr)
                    {
                      int* _refcount = _ptr.refcount;
                      if( _refcount )
                          CV_XADD(_refcount, 1);
                      release();
                      obj = _ptr.obj;
                      refcount = _refcount;
                    }
                    return *this;
                }
                
                template<typename _Tp> inline _Tp* Ptr<_Tp>::operator -> () { return obj; }
                template<typename _Tp> inline const _Tp* Ptr<_Tp>::operator -> () const { return obj; }
                
                template<typename _Tp> inline Ptr<_Tp>::operator _Tp* () { return obj; }
                template<typename _Tp> inline Ptr<_Tp>::operator const _Tp*() const { return obj; }
                
                template<typename _Tp> inline bool Ptr<_Tp>::empty() const { return obj == 0; }
                
                template<typename _Tp> template<typename _Tp2> Ptr<_Tp>::Ptr(const Ptr<_Tp2>& p)
                    : obj(0), refcount(0)
                {
                    if (p.empty())
                        return;
                
                    _Tp* p_casted = dynamic_cast<_Tp*>(p.obj);
                    if (!p_casted)
                        return;
                
                    obj = p_casted;
                    refcount = p.refcount;
                    addref();
                }
                
                template<typename _Tp> template<typename _Tp2> inline Ptr<_Tp2> Ptr<_Tp>::ptr()
                {
                    Ptr<_Tp2> p;
                    if( !obj )
                        return p;
                
                    _Tp2* obj_casted = dynamic_cast<_Tp2*>(obj);
                    if (!obj_casted)
                        return p;
                
                    if( refcount )
                        CV_XADD(refcount, 1);
                
                    p.obj = obj_casted;
                    p.refcount = refcount;
                    return p;
                }
                
                template<typename _Tp> template<typename _Tp2> inline const Ptr<_Tp2> Ptr<_Tp>::ptr() const
                {
                    Ptr<_Tp2> p;
                    if( !obj )
                        return p;
                
                    _Tp2* obj_casted = dynamic_cast<_Tp2*>(obj);
                    if (!obj_casted)
                        return p;
                
                    if( refcount )
                        CV_XADD(refcount, 1);
                
                    p.obj = obj_casted;
                    p.refcount = refcount;
                    return p;
                }
                
                //// specializied implementations of Ptr::delete_obj() for classic OpenCV types
                
                template<> CV_EXPORTS void Ptr<CvMat>::delete_obj();
                template<> CV_EXPORTS void Ptr<IplImage>::delete_obj();
                template<> CV_EXPORTS void Ptr<CvMatND>::delete_obj();
                template<> CV_EXPORTS void Ptr<CvSparseMat>::delete_obj();
                template<> CV_EXPORTS void Ptr<CvMemStorage>::delete_obj();
                template<> CV_EXPORTS void Ptr<CvFileStorage>::delete_obj();
                
                //////////////////////////////////////// XML & YAML I/O ////////////////////////////////////
                
                CV_EXPORTS_W void write( FileStorage& fs, const string& name, int value );
                CV_EXPORTS_W void write( FileStorage& fs, const string& name, float value );
                CV_EXPORTS_W void write( FileStorage& fs, const string& name, double value );
                CV_EXPORTS_W void write( FileStorage& fs, const string& name, const string& value );
                
                template<typename _Tp> inline void write(FileStorage& fs, const _Tp& value)
                { write(fs, string(), value); }
                
                CV_EXPORTS void writeScalar( FileStorage& fs, int value );
                CV_EXPORTS void writeScalar( FileStorage& fs, float value );
                CV_EXPORTS void writeScalar( FileStorage& fs, double value );
                CV_EXPORTS void writeScalar( FileStorage& fs, const string& value );
                
                template<> inline void write( FileStorage& fs, const int& value )
                {
                    writeScalar(fs, value);
                }
                
                template<> inline void write( FileStorage& fs, const float& value )
                {
                    writeScalar(fs, value);
                }
                
                template<> inline void write( FileStorage& fs, const double& value )
                {
                    writeScalar(fs, value);
                }
                
                template<> inline void write( FileStorage& fs, const string& value )
                {
                    writeScalar(fs, value);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const Point_<_Tp>& pt )
                {
                    write(fs, pt.x);
                    write(fs, pt.y);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const Point3_<_Tp>& pt )
                {
                    write(fs, pt.x);
                    write(fs, pt.y);
                    write(fs, pt.z);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const Size_<_Tp>& sz )
                {
                    write(fs, sz.width);
                    write(fs, sz.height);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const Complex<_Tp>& c )
                {
                    write(fs, c.re);
                    write(fs, c.im);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const Rect_<_Tp>& r )
                {
                    write(fs, r.x);
                    write(fs, r.y);
                    write(fs, r.width);
                    write(fs, r.height);
                }
                
                template<typename _Tp, int cn> inline void write(FileStorage& fs, const Vec<_Tp, cn>& v )
                {
                    for(int i = 0; i < cn; i++)
                        write(fs, v.val[i]);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const Scalar_<_Tp>& s )
                {
                    write(fs, s.val[0]);
                    write(fs, s.val[1]);
                    write(fs, s.val[2]);
                    write(fs, s.val[3]);
                }
                
                inline void write(FileStorage& fs, const Range& r )
                {
                    write(fs, r.start);
                    write(fs, r.end);
                }
                
                class CV_EXPORTS WriteStructContext
                {
                public:
                    WriteStructContext(FileStorage& _fs, const string& name,
                        int flags, const string& typeName=string());
                    ~WriteStructContext();
                    FileStorage* fs;
                };
                
                template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point_<_Tp>& pt )
                {
                    WriteStructContext ws(fs, name, CV_NODE_SEQ+CV_NODE_FLOW);
                    write(fs, pt.x);
                    write(fs, pt.y);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )
                {
                    WriteStructContext ws(fs, name, CV_NODE_SEQ+CV_NODE_FLOW);
                    write(fs, pt.x);
                    write(fs, pt.y);
                    write(fs, pt.z);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Size_<_Tp>& sz )
                {
                    WriteStructContext ws(fs, name, CV_NODE_SEQ+CV_NODE_FLOW);
                    write(fs, sz.width);
                    write(fs, sz.height);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Complex<_Tp>& c )
                {
                    WriteStructContext ws(fs, name, CV_NODE_SEQ+CV_NODE_FLOW);
                    write(fs, c.re);
                    write(fs, c.im);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Rect_<_Tp>& r )
                {
                    WriteStructContext ws(fs, name, CV_NODE_SEQ+CV_NODE_FLOW);
                    write(fs, r.x);
                    write(fs, r.y);
                    write(fs, r.width);
                    write(fs, r.height);
                }
                
                template<typename _Tp, int cn> inline void write(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )
                {
                    WriteStructContext ws(fs, name, CV_NODE_SEQ+CV_NODE_FLOW);
                    for(int i = 0; i < cn; i++)
                        write(fs, v.val[i]);
                }
                
                template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )
                {
                    WriteStructContext ws(fs, name, CV_NODE_SEQ+CV_NODE_FLOW);
                    write(fs, s.val[0]);
                    write(fs, s.val[1]);
                    write(fs, s.val[2]);
                    write(fs, s.val[3]);
                }
                
                inline void write(FileStorage& fs, const string& name, const Range& r )
                {
                    WriteStructContext ws(fs, name, CV_NODE_SEQ+CV_NODE_FLOW);
                    write(fs, r.start);
                    write(fs, r.end);
                }
                
                template<typename _Tp, int numflag> class VecWriterProxy
                {
                public:
                    VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}
                    void operator()(const vector<_Tp>& vec) const
                    {
                        size_t i, count = vec.size();
                        for( i = 0; i < count; i++ )
                            write( *fs, vec[i] );
                    }
                    FileStorage* fs;
                };
                
                template<typename _Tp> class VecWriterProxy<_Tp,1>
                {
                public:
                    VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}
                    void operator()(const vector<_Tp>& vec) const
                    {
                        int _fmt = DataType<_Tp>::fmt;
                        char fmt[] = { (char)((_fmt>>8)+'1'), (char)_fmt, '\0' };
                        fs->writeRaw( string(fmt), !vec.empty() ? (uchar*)&vec[0] : 0, vec.size()*sizeof(_Tp) );
                    }
                    FileStorage* fs;
                };
                
                template<typename _Tp> static inline void write( FileStorage& fs, const vector<_Tp>& vec )
                {
                    VecWriterProxy<_Tp, DataType<_Tp>::fmt != 0> w(&fs);
                    w(vec);
                }
                
                template<typename _Tp> static inline void write( FileStorage& fs, const string& name,
                                                                const vector<_Tp>& vec )
                {
                    WriteStructContext ws(fs, name, CV_NODE_SEQ+(DataType<_Tp>::fmt != 0 ? CV_NODE_FLOW : 0));
                    write(fs, vec);
                }
                
                CV_EXPORTS_W void write( FileStorage& fs, const string& name, const Mat& value );
                CV_EXPORTS void write( FileStorage& fs, const string& name, const SparseMat& value );
                
                template<typename _Tp> static inline FileStorage& operator << (FileStorage& fs, const _Tp& value)
                {
                    if( !fs.isOpened() )
                        return fs;
                    if( fs.state == FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP )
                        CV_Error( CV_StsError, "No element name has been given" );
                    write( fs, fs.elname, value );
                    if( fs.state & FileStorage::INSIDE_MAP )
                        fs.state = FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP;
                    return fs;
                }
                
                CV_EXPORTS FileStorage& operator << (FileStorage& fs, const string& str);
                
                static inline FileStorage& operator << (FileStorage& fs, const char* str)
                { return (fs << string(str)); }
                
                static inline FileStorage& operator << (FileStorage& fs, char* value)
                { return (fs << string(value)); }
                
                inline FileNode::FileNode() : fs(0), node(0) {}
                inline FileNode::FileNode(const CvFileStorage* _fs, const CvFileNode* _node)
                    : fs(_fs), node(_node) {}
                
                inline FileNode::FileNode(const FileNode& _node) : fs(_node.fs), node(_node.node) {}
                
                inline int FileNode::type() const { return !node ? NONE : (node->tag & TYPE_MASK); }
                inline bool FileNode::empty() const { return node == 0; }
                inline bool FileNode::isNone() const { return type() == NONE; }
                inline bool FileNode::isSeq() const { return type() == SEQ; }
                inline bool FileNode::isMap() const { return type() == MAP; }
                inline bool FileNode::isInt() const { return type() == INT; }
                inline bool FileNode::isReal() const { return type() == REAL; }
                inline bool FileNode::isString() const { return type() == STR; }
                inline bool FileNode::isNamed() const { return !node ? false : (node->tag & NAMED) != 0; }
                inline size_t FileNode::size() const
                {
                    int t = type();
                    return t == MAP ? (size_t)((CvSet*)node->data.map)->active_count :
                        t == SEQ ? (size_t)node->data.seq->total : (size_t)!isNone();
                }
                
                inline CvFileNode* FileNode::operator *() { return (CvFileNode*)node; }
                inline const CvFileNode* FileNode::operator* () const { return node; }
                
                static inline void read(const FileNode& node, int& value, int default_value)
                {
                    value = !node.node ? default_value :
                    CV_NODE_IS_INT(node.node->tag) ? node.node->data.i :
                    CV_NODE_IS_REAL(node.node->tag) ? cvRound(node.node->data.f) : 0x7fffffff;
                }
                
                static inline void read(const FileNode& node, bool& value, bool default_value)
                {
                    int temp; read(node, temp, (int)default_value);
                    value = temp != 0;
                }
                
                static inline void read(const FileNode& node, uchar& value, uchar default_value)
                {
                    int temp; read(node, temp, (int)default_value);
                    value = saturate_cast<uchar>(temp);
                }
                
                static inline void read(const FileNode& node, schar& value, schar default_value)
                {
                    int temp; read(node, temp, (int)default_value);
                    value = saturate_cast<schar>(temp);
                }
                
                static inline void read(const FileNode& node, ushort& value, ushort default_value)
                {
                    int temp; read(node, temp, (int)default_value);
                    value = saturate_cast<ushort>(temp);
                }
                
                static inline void read(const FileNode& node, short& value, short default_value)
                {
                    int temp; read(node, temp, (int)default_value);
                    value = saturate_cast<short>(temp);
                }
                
                static inline void read(const FileNode& node, float& value, float default_value)
                {
                    value = !node.node ? default_value :
                        CV_NODE_IS_INT(node.node->tag) ? (float)node.node->data.i :
                        CV_NODE_IS_REAL(node.node->tag) ? (float)node.node->data.f : 1e30f;
                }
                
                static inline void read(const FileNode& node, double& value, double default_value)
                {
                    value = !node.node ? default_value :
                        CV_NODE_IS_INT(node.node->tag) ? (double)node.node->data.i :
                        CV_NODE_IS_REAL(node.node->tag) ? node.node->data.f : 1e300;
                }
                
                static inline void read(const FileNode& node, string& value, const string& default_value)
                {
                    value = !node.node ? default_value : CV_NODE_IS_STRING(node.node->tag) ? string(node.node->data.str.ptr) : string("");
                }
                
                template<typename _Tp> static inline void read(const FileNode& node, Point_<_Tp>& value, const Point_<_Tp>& default_value)
                {
                    vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
                    value = temp.size() != 2 ? default_value : Point_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]));
                }
                
                template<typename _Tp> static inline void read(const FileNode& node, Point3_<_Tp>& value, const Point3_<_Tp>& default_value)
                {
                    vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
                    value = temp.size() != 3 ? default_value : Point3_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]),
                                                                            saturate_cast<_Tp>(temp[2]));
                }
                
                template<typename _Tp> static inline void read(const FileNode& node, Size_<_Tp>& value, const Size_<_Tp>& default_value)
                {
                    vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
                    value = temp.size() != 2 ? default_value : Size_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]));
                }
                
                template<typename _Tp> static inline void read(const FileNode& node, Complex<_Tp>& value, const Complex<_Tp>& default_value)
                {
                    vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
                    value = temp.size() != 2 ? default_value : Complex<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]));
                }
                
                template<typename _Tp> static inline void read(const FileNode& node, Rect_<_Tp>& value, const Rect_<_Tp>& default_value)
                {
                    vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
                    value = temp.size() != 4 ? default_value : Rect_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]),
                                                                          saturate_cast<_Tp>(temp[2]), saturate_cast<_Tp>(temp[3]));
                }
                
                template<typename _Tp, int cn> static inline void read(const FileNode& node, Vec<_Tp, cn>& value, const Vec<_Tp, cn>& default_value)
                {
                    vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
                    value = temp.size() != cn ? default_value : Vec<_Tp, cn>(&temp[0]);
                }
                
                template<typename _Tp> static inline void read(const FileNode& node, Scalar_<_Tp>& value, const Scalar_<_Tp>& default_value)
                {
                    vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
                    value = temp.size() != 4 ? default_value : Scalar_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]),
                                                                            saturate_cast<_Tp>(temp[2]), saturate_cast<_Tp>(temp[3]));
                }
                
                static inline void read(const FileNode& node, Range& value, const Range& default_value)
                {
                    Point2i temp(value.start, value.end); const Point2i default_temp = Point2i(default_value.start, default_value.end);
                    read(node, temp, default_temp);
                    value.start = temp.x; value.end = temp.y;
                }
                
                CV_EXPORTS_W void read(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() );
                CV_EXPORTS void read(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() );
                
                inline FileNode::operator int() const
                {
                    int value;
                    read(*this, value, 0);
                    return value;
                }
                inline FileNode::operator float() const
                {
                    float value;
                    read(*this, value, 0.f);
                    return value;
                }
                inline FileNode::operator double() const
                {
                    double value;
                    read(*this, value, 0.);
                    return value;
                }
                inline FileNode::operator string() const
                {
                    string value;
                    read(*this, value, value);
                    return value;
                }
                
                inline void FileNode::readRaw( const string& fmt, uchar* vec, size_t len ) const
                {
                    begin().readRaw( fmt, vec, len );
                }
                
                template<typename _Tp, int numflag> class VecReaderProxy
                {
                public:
                    VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}
                    void operator()(vector<_Tp>& vec, size_t count) const
                    {
                        count = std::min(count, it->remaining);
                        vec.resize(count);
                        for( size_t i = 0; i < count; i++, ++(*it) )
                            read(**it, vec[i], _Tp());
                    }
                    FileNodeIterator* it;
                };
                
                template<typename _Tp> class VecReaderProxy<_Tp,1>
                {
                public:
                    VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}
                    void operator()(vector<_Tp>& vec, size_t count) const
                    {
                        size_t remaining = it->remaining, cn = DataType<_Tp>::channels;
                        int _fmt = DataType<_Tp>::fmt;
                        char fmt[] = { (char)((_fmt>>8)+'1'), (char)_fmt, '\0' };
                        size_t remaining1 = remaining/cn;
                        count = count < remaining1 ? count : remaining1;
                        vec.resize(count);
                        it->readRaw( string(fmt), !vec.empty() ? (uchar*)&vec[0] : 0, count*sizeof(_Tp) );
                    }
                    FileNodeIterator* it;
                };
                
                template<typename _Tp> static inline void
                read( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)INT_MAX )
                {
                    VecReaderProxy<_Tp, DataType<_Tp>::fmt != 0> r(&it);
                    r(vec, maxCount);
                }
                
                template<typename _Tp> static inline void
                read( const FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )
                {
                    if(!node.node)
                        vec = default_value;
                    else
                    {
                        FileNodeIterator it = node.begin();
                        read( it, vec );
                    }
                }
                
                inline FileNodeIterator FileNode::begin() const
                {
                    return FileNodeIterator(fs, node);
                }
                
                inline FileNodeIterator FileNode::end() const
                {
                    return FileNodeIterator(fs, node, size());
                }
                
                inline FileNode FileNodeIterator::operator *() const
                { return FileNode(fs, (const CvFileNode*)(void*)reader.ptr); }
                
                inline FileNode FileNodeIterator::operator ->() const
                { return FileNode(fs, (const CvFileNode*)(void*)reader.ptr); }
                
                template<typename _Tp> static inline FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)
                { read( *it, value, _Tp()); return ++it; }
                
                template<typename _Tp> static inline
                FileNodeIterator& operator >> (FileNodeIterator& it, vector<_Tp>& vec)
                {
                    VecReaderProxy<_Tp, DataType<_Tp>::fmt != 0> r(&it);
                    r(vec, (size_t)INT_MAX);
                    return it;
                }
                
                template<typename _Tp> static inline void operator >> (const FileNode& n, _Tp& value)
                { read( n, value, _Tp()); }
                
                template<typename _Tp> static inline void operator >> (const FileNode& n, vector<_Tp>& vec)
                { FileNodeIterator it = n.begin(); it >> vec; }
                
                static inline bool operator == (const FileNodeIterator& it1, const FileNodeIterator& it2)
                {
                    return it1.fs == it2.fs && it1.container == it2.container &&
                        it1.reader.ptr == it2.reader.ptr && it1.remaining == it2.remaining;
                }
                
                static inline bool operator != (const FileNodeIterator& it1, const FileNodeIterator& it2)
                {
                    return !(it1 == it2);
                }
                
                static inline ptrdiff_t operator - (const FileNodeIterator& it1, const FileNodeIterator& it2)
                {
                    return it2.remaining - it1.remaining;
                }
                
                static inline bool operator < (const FileNodeIterator& it1, const FileNodeIterator& it2)
                {
                    return it1.remaining > it2.remaining;
                }
                
                inline FileNode FileStorage::getFirstTopLevelNode() const
                {
                    FileNode r = root();
                    FileNodeIterator it = r.begin();
                    return it != r.end() ? *it : FileNode();
                }
                
                //////////////////////////////////////// Various algorithms ////////////////////////////////////
                
                template<typename _Tp> static inline _Tp gcd(_Tp a, _Tp b)
                {
                    if( a < b )
                        std::swap(a, b);
                    while( b > 0 )
                    {
                        _Tp r = a % b;
                        a = b;
                        b = r;
                    }
                    return a;
                }
                
                /****************************************************************************************\
                
                  Generic implementation of QuickSort algorithm
                  Use it as: vector<_Tp> a; ... sort(a,<less_than_predictor>);
                
                  The current implementation was derived from *BSD system qsort():
                
                    * Copyright (c) 1992, 1993
                    *  The Regents of the University of California.  All rights reserved.
                    *
                    * Redistribution and use in source and binary forms, with or without
                    * modification, are permitted provided that the following conditions
                    * are met:
                    * 1. Redistributions of source code must retain the above copyright
                    *    notice, this list of conditions and the following disclaimer.
                    * 2. Redistributions in binary form must reproduce the above copyright
                    *    notice, this list of conditions and the following disclaimer in the
                    *    documentation and/or other materials provided with the distribution.
                    * 3. All advertising materials mentioning features or use of this software
                    *    must display the following acknowledgement:
                    *  This product includes software developed by the University of
                    *  California, Berkeley and its contributors.
                    * 4. Neither the name of the University nor the names of its contributors
                    *    may be used to endorse or promote products derived from this software
                    *    without specific prior written permission.
                    *
                    * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
                    * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                    * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
                    * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                    * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
                    * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
                    * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
                    * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
                    * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
                    * SUCH DAMAGE.
                
                \****************************************************************************************/
                
                template<typename _Tp, class _LT> void sort( vector<_Tp>& vec, _LT LT=_LT() )
                {
                    int isort_thresh = 7;
                    int sp = 0;
                
                    struct
                    {
                        _Tp *lb;
                        _Tp *ub;
                    } stack[48];
                
                    size_t total = vec.size();
                
                    if( total <= 1 )
                        return;
                
                    _Tp* arr = &vec[0];
                    stack[0].lb = arr;
                    stack[0].ub = arr + (total - 1);
                
                    while( sp >= 0 )
                    {
                        _Tp* left = stack[sp].lb;
                        _Tp* right = stack[sp--].ub;
                
                        for(;;)
                        {
                            int i, n = (int)(right - left) + 1, m;
                            _Tp* ptr;
                            _Tp* ptr2;
                
                            if( n <= isort_thresh )
                            {
                            insert_sort:
                                for( ptr = left + 1; ptr <= right; ptr++ )
                                {
                                    for( ptr2 = ptr; ptr2 > left && LT(ptr2[0],ptr2[-1]); ptr2--)
                                        std::swap( ptr2[0], ptr2[-1] );
                                }
                                break;
                            }
                            else
                            {
                                _Tp* left0;
                                _Tp* left1;
                                _Tp* right0;
                                _Tp* right1;
                                _Tp* pivot;
                                _Tp* a;
                                _Tp* b;
                                _Tp* c;
                                int swap_cnt = 0;
                
                                left0 = left;
                                right0 = right;
                                pivot = left + (n/2);
                
                                if( n > 40 )
                                {
                                    int d = n / 8;
                                    a = left, b = left + d, c = left + 2*d;
                                    left = LT(*a, *b) ? (LT(*b, *c) ? b : (LT(*a, *c) ? c : a))
                                                      : (LT(*c, *b) ? b : (LT(*a, *c) ? a : c));
                
                                    a = pivot - d, b = pivot, c = pivot + d;
                                    pivot = LT(*a, *b) ? (LT(*b, *c) ? b : (LT(*a, *c) ? c : a))
                                                      : (LT(*c, *b) ? b : (LT(*a, *c) ? a : c));
                
                                    a = right - 2*d, b = right - d, c = right;
                                    right = LT(*a, *b) ? (LT(*b, *c) ? b : (LT(*a, *c) ? c : a))
                                                      : (LT(*c, *b) ? b : (LT(*a, *c) ? a : c));
                                }
                
                                a = left, b = pivot, c = right;
                                pivot = LT(*a, *b) ? (LT(*b, *c) ? b : (LT(*a, *c) ? c : a))
                                                   : (LT(*c, *b) ? b : (LT(*a, *c) ? a : c));
                                if( pivot != left0 )
                                {
                                    std::swap( *pivot, *left0 );
                                    pivot = left0;
                                }
                                left = left1 = left0 + 1;
                                right = right1 = right0;
                
                                for(;;)
                                {
                                    while( left <= right && !LT(*pivot, *left) )
                                    {
                                        if( !LT(*left, *pivot) )
                                        {
                                            if( left > left1 )
                                                std::swap( *left1, *left );
                                            swap_cnt = 1;
                                            left1++;
                                        }
                                        left++;
                                    }
                
                                    while( left <= right && !LT(*right, *pivot) )
                                    {
                                        if( !LT(*pivot, *right) )
                                        {
                                            if( right < right1 )
                                                std::swap( *right1, *right );
                                            swap_cnt = 1;
                                            right1--;
                                        }
                                        right--;
                                    }
                
                                    if( left > right )
                                        break;
                                    std::swap( *left, *right );
                                    swap_cnt = 1;
                                    left++;
                                    right--;
                                }
                
                                if( swap_cnt == 0 )
                                {
                                    left = left0, right = right0;
                                    goto insert_sort;
                                }
                
                                n = std::min( (int)(left1 - left0), (int)(left - left1) );
                                for( i = 0; i < n; i++ )
                                    std::swap( left0[i], left[i-n] );
                
                                n = std::min( (int)(right0 - right1), (int)(right1 - right) );
                                for( i = 0; i < n; i++ )
                                    std::swap( left[i], right0[i-n+1] );
                                n = (int)(left - left1);
                                m = (int)(right1 - right);
                                if( n > 1 )
                                {
                                    if( m > 1 )
                                    {
                                        if( n > m )
                                        {
                                            stack[++sp].lb = left0;
                                            stack[sp].ub = left0 + n - 1;
                                            left = right0 - m + 1, right = right0;
                                        }
                                        else
                                        {
                                            stack[++sp].lb = right0 - m + 1;
                                            stack[sp].ub = right0;
                                            left = left0, right = left0 + n - 1;
                                        }
                                    }
                                    else
                                        left = left0, right = left0 + n - 1;
                                }
                                else if( m > 1 )
                                    left = right0 - m + 1, right = right0;
                                else
                                    break;
                            }
                        }
                    }
                }
                
                template<typename _Tp> class LessThan
                {
                public:
                    bool operator()(const _Tp& a, const _Tp& b) const { return a < b; }
                };
                
                template<typename _Tp> class GreaterEq
                {
                public:
                    bool operator()(const _Tp& a, const _Tp& b) const { return a >= b; }
                };
                
                template<typename _Tp> class LessThanIdx
                {
                public:
                    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}
                    bool operator()(int a, int b) const { return arr[a] < arr[b]; }
                    const _Tp* arr;
                };
                
                template<typename _Tp> class GreaterEqIdx
                {
                public:
                    GreaterEqIdx( const _Tp* _arr ) : arr(_arr) {}
                    bool operator()(int a, int b) const { return arr[a] >= arr[b]; }
                    const _Tp* arr;
                };
                
                
                // This function splits the input sequence or set into one or more equivalence classes and
                // returns the vector of labels - 0-based class indexes for each element.
                // predicate(a,b) returns true if the two sequence elements certainly belong to the same class.
                //
                // The algorithm is described in "Introduction to Algorithms"
                // by Cormen, Leiserson and Rivest, the chapter "Data structures for disjoint sets"
                template<typename _Tp, class _EqPredicate> int
                partition( const vector<_Tp>& _vec, vector<int>& labels,
                           _EqPredicate predicate=_EqPredicate())
                {
                    int i, j, N = (int)_vec.size();
                    const _Tp* vec = &_vec[0];
                
                    const int PARENT=0;
                    const int RANK=1;
                
                    vector<int> _nodes(N*2);
                    int (*nodes)[2] = (int(*)[2])&_nodes[0];
                
                    // The first O(N) pass: create N single-vertex trees
                    for(i = 0; i < N; i++)
                    {
                        nodes[i][PARENT]=-1;
                        nodes[i][RANK] = 0;
                    }
                
                    // The main O(N^2) pass: merge connected components
                    for( i = 0; i < N; i++ )
                    {
                        int root = i;
                
                        // find root
                        while( nodes[root][PARENT] >= 0 )
                            root = nodes[root][PARENT];
                
                        for( j = 0; j < N; j++ )
                        {
                            if( i == j || !predicate(vec[i], vec[j]))
                                continue;
                            int root2 = j;
                
                            while( nodes[root2][PARENT] >= 0 )
                                root2 = nodes[root2][PARENT];
                
                            if( root2 != root )
                            {
                                // unite both trees
                                int rank = nodes[root][RANK], rank2 = nodes[root2][RANK];
                                if( rank > rank2 )
                                    nodes[root2][PARENT] = root;
                                else
                                {
                                    nodes[root][PARENT] = root2;
                                    nodes[root2][RANK] += rank == rank2;
                                    root = root2;
                                }
                                assert( nodes[root][PARENT] < 0 );
                
                                int k = j, parent;
                
                                // compress the path from node2 to root
                                while( (parent = nodes[k][PARENT]) >= 0 )
                                {
                                    nodes[k][PARENT] = root;
                                    k = parent;
                                }
                
                                // compress the path from node to root
                                k = i;
                                while( (parent = nodes[k][PARENT]) >= 0 )
                                {
                                    nodes[k][PARENT] = root;
                                    k = parent;
                                }
                            }
                        }
                    }
                
                    // Final O(N) pass: enumerate classes
                    labels.resize(N);
                    int nclasses = 0;
                
                    for( i = 0; i < N; i++ )
                    {
                        int root = i;
                        while( nodes[root][PARENT] >= 0 )
                            root = nodes[root][PARENT];
                        // re-use the rank as the class label
                        if( nodes[root][RANK] >= 0 )
                            nodes[root][RANK] = ~nclasses++;
                        labels[i] = ~nodes[root][RANK];
                    }
                
                    return nclasses;
                }
                
                
                //////////////////////////////////////////////////////////////////////////////
                
                // bridge C++ => C Seq API
                CV_EXPORTS schar*  seqPush( CvSeq* seq, const void* element=0);
                CV_EXPORTS schar*  seqPushFront( CvSeq* seq, const void* element=0);
                CV_EXPORTS void  seqPop( CvSeq* seq, void* element=0);
                CV_EXPORTS void  seqPopFront( CvSeq* seq, void* element=0);
                CV_EXPORTS void  seqPopMulti( CvSeq* seq, void* elements,
                                              int count, int in_front=0 );
                CV_EXPORTS void  seqRemove( CvSeq* seq, int index );
                CV_EXPORTS void  clearSeq( CvSeq* seq );
                CV_EXPORTS schar*  getSeqElem( const CvSeq* seq, int index );
                CV_EXPORTS void  seqRemoveSlice( CvSeq* seq, CvSlice slice );
                CV_EXPORTS void  seqInsertSlice( CvSeq* seq, int before_index, const CvArr* from_arr );
                
                template<typename _Tp> inline Seq<_Tp>::Seq() : seq(0) {}
                template<typename _Tp> inline Seq<_Tp>::Seq( const CvSeq* _seq ) : seq((CvSeq*)_seq)
                {
                    CV_Assert(!_seq || _seq->elem_size == sizeof(_Tp));
                }
                
                template<typename _Tp> inline Seq<_Tp>::Seq( MemStorage& storage,
                                                             int headerSize )
                {
                    CV_Assert(headerSize >= (int)sizeof(CvSeq));
                    seq = cvCreateSeq(DataType<_Tp>::type, headerSize, sizeof(_Tp), storage);
                }
                
                template<typename _Tp> inline _Tp& Seq<_Tp>::operator [](int idx)
                { return *(_Tp*)getSeqElem(seq, idx); }
                
                template<typename _Tp> inline const _Tp& Seq<_Tp>::operator [](int idx) const
                { return *(_Tp*)getSeqElem(seq, idx); }
                
                template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::begin() const
                { return SeqIterator<_Tp>(*this); }
                
                template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::end() const
                { return SeqIterator<_Tp>(*this, true); }
                
                template<typename _Tp> inline size_t Seq<_Tp>::size() const
                { return seq ? seq->total : 0; }
                
                template<typename _Tp> inline int Seq<_Tp>::type() const
                { return seq ? CV_MAT_TYPE(seq->flags) : 0; }
                
                template<typename _Tp> inline int Seq<_Tp>::depth() const
                { return seq ? CV_MAT_DEPTH(seq->flags) : 0; }
                
                template<typename _Tp> inline int Seq<_Tp>::channels() const
                { return seq ? CV_MAT_CN(seq->flags) : 0; }
                
                template<typename _Tp> inline size_t Seq<_Tp>::elemSize() const
                { return seq ? seq->elem_size : 0; }
                
                template<typename _Tp> inline size_t Seq<_Tp>::index(const _Tp& elem) const
                { return cvSeqElemIdx(seq, &elem); }
                
                template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp& elem)
                { cvSeqPush(seq, &elem); }
                
                template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp& elem)
                { cvSeqPushFront(seq, &elem); }
                
                template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp* elem, size_t count)
                { cvSeqPushMulti(seq, elem, (int)count, 0); }
                
                template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp* elem, size_t count)
                { cvSeqPushMulti(seq, elem, (int)count, 1); }
                
                template<typename _Tp> inline _Tp& Seq<_Tp>::back()
                { return *(_Tp*)getSeqElem(seq, -1); }
                
                template<typename _Tp> inline const _Tp& Seq<_Tp>::back() const
                { return *(const _Tp*)getSeqElem(seq, -1); }
                
                template<typename _Tp> inline _Tp& Seq<_Tp>::front()
                { return *(_Tp*)getSeqElem(seq, 0); }
                
                template<typename _Tp> inline const _Tp& Seq<_Tp>::front() const
                { return *(const _Tp*)getSeqElem(seq, 0); }
                
                template<typename _Tp> inline bool Seq<_Tp>::empty() const
                { return !seq || seq->total == 0; }
                
                template<typename _Tp> inline void Seq<_Tp>::clear()
                { if(seq) clearSeq(seq); }
                
                template<typename _Tp> inline void Seq<_Tp>::pop_back()
                { seqPop(seq); }
                
                template<typename _Tp> inline void Seq<_Tp>::pop_front()
                { seqPopFront(seq); }
                
                template<typename _Tp> inline void Seq<_Tp>::pop_back(_Tp* elem, size_t count)
                { seqPopMulti(seq, elem, (int)count, 0); }
                
                template<typename _Tp> inline void Seq<_Tp>::pop_front(_Tp* elem, size_t count)
                { seqPopMulti(seq, elem, (int)count, 1); }
                
                template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp& elem)
                { seqInsert(seq, idx, &elem); }
                
                template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp* elems, size_t count)
                {
                    CvMat m = cvMat(1, count, DataType<_Tp>::type, elems);
                    seqInsertSlice(seq, idx, &m);
                }
                
                template<typename _Tp> inline void Seq<_Tp>::remove(int idx)
                { seqRemove(seq, idx); }
                
                template<typename _Tp> inline void Seq<_Tp>::remove(const Range& r)
                { seqRemoveSlice(seq, r); }
                
                template<typename _Tp> inline void Seq<_Tp>::copyTo(vector<_Tp>& vec, const Range& range) const
                {
                    size_t len = !seq ? 0 : range == Range::all() ? seq->total : range.end - range.start;
                    vec.resize(len);
                    if( seq && len )
                        cvCvtSeqToArray(seq, &vec[0], range);
                }
                
                template<typename _Tp> inline Seq<_Tp>::operator vector<_Tp>() const
                {
                    vector<_Tp> vec;
                    copyTo(vec);
                    return vec;
                }
                
                template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator()
                { memset(this, 0, sizeof(*this)); }
                
                template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator(const Seq<_Tp>& _seq, bool seekEnd)
                {
                    cvStartReadSeq(_seq.seq, this);
                    index = seekEnd ? _seq.seq->total : 0;
                }
                
                template<typename _Tp> inline void SeqIterator<_Tp>::seek(size_t pos)
                {
                    cvSetSeqReaderPos(this, (int)pos, false);
                    index = pos;
                }
                
                template<typename _Tp> inline size_t SeqIterator<_Tp>::tell() const
                { return index; }
                
                template<typename _Tp> inline _Tp& SeqIterator<_Tp>::operator *()
                { return *(_Tp*)ptr; }
                
                template<typename _Tp> inline const _Tp& SeqIterator<_Tp>::operator *() const
                { return *(const _Tp*)ptr; }
                
                template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator ++()
                {
                    CV_NEXT_SEQ_ELEM(sizeof(_Tp), *this);
                    if( ++index >= seq->total*2 )
                        index = 0;
                    return *this;
                }
                
                template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator ++(int) const
                {
                    SeqIterator<_Tp> it = *this;
                    ++*this;
                    return it;
                }
                
                template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator --()
                {
                    CV_PREV_SEQ_ELEM(sizeof(_Tp), *this);
                    if( --index < 0 )
                        index = seq->total*2-1;
                    return *this;
                }
                
                template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator --(int) const
                {
                    SeqIterator<_Tp> it = *this;
                    --*this;
                    return it;
                }
                
                template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator +=(int delta)
                {
                    cvSetSeqReaderPos(this, delta, 1);
                    index += delta;
                    int n = seq->total*2;
                    if( index < 0 )
                        index += n;
                    if( index >= n )
                        index -= n;
                    return *this;
                }
                
                template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator -=(int delta)
                {
                    return (*this += -delta);
                }
                
                template<typename _Tp> inline ptrdiff_t operator - (const SeqIterator<_Tp>& a,
                                                                    const SeqIterator<_Tp>& b)
                {
                    ptrdiff_t delta = a.index - b.index, n = a.seq->total;
                    if( std::abs(static_cast<long>(delta)) > n )
                        delta += delta < 0 ? n : -n;
                    return delta;
                }
                
                template<typename _Tp> inline bool operator == (const SeqIterator<_Tp>& a,
                                                                const SeqIterator<_Tp>& b)
                {
                    return a.seq == b.seq && a.index == b.index;
                }
                
                template<typename _Tp> inline bool operator != (const SeqIterator<_Tp>& a,
                                                                const SeqIterator<_Tp>& b)
                {
                    return !(a == b);
                }
                
                
                template<typename _ClsName> struct RTTIImpl
                {
                public:
                    static int isInstance(const void* ptr)
                    {
                        static _ClsName dummy;
                        static void* dummyp = &dummy;
                        union
                        {
                            const void* p;
                            const void** pp;
                        } a, b;
                        a.p = dummyp;
                        b.p = ptr;
                        return *a.pp == *b.pp;
                    }
                    static void release(void** dbptr)
                    {
                        if(dbptr && *dbptr)
                        {
                            delete (_ClsName*)*dbptr;
                            *dbptr = 0;
                        }
                    }
                    static void* read(CvFileStorage* fs, CvFileNode* n)
                    {
                        FileNode fn(fs, n);
                        _ClsName* obj = new _ClsName;
                        if(obj->read(fn))
                            return obj;
                        delete obj;
                        return 0;
                    }
                
                    static void write(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)
                    {
                        if(ptr && _fs)
                        {
                            FileStorage fs(_fs);
                            fs.fs.addref();
                            ((const _ClsName*)ptr)->write(fs, string(name));
                        }
                    }
                
                    static void* clone(const void* ptr)
                    {
                        if(!ptr)
                            return 0;
                        return new _ClsName(*(const _ClsName*)ptr);
                    }
                };
                
                
                class CV_EXPORTS Formatter
                {
                public:
                    virtual ~Formatter() {}
                    virtual void write(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const = 0;
                    virtual void write(std::ostream& out, const void* data, int nelems, int type,
                                       const int* params=0, int nparams=0) const = 0;
                    static const Formatter* get(const char* fmt="");
                    static const Formatter* setDefault(const Formatter* fmt);
                };
                
                
                struct CV_EXPORTS Formatted
                {
                    Formatted(const Mat& m, const Formatter* fmt,
                              const vector<int>& params);
                    Formatted(const Mat& m, const Formatter* fmt,
                              const int* params=0);
                    Mat mtx;
                    const Formatter* fmt;
                    vector<int> params;
                };
                
                static inline Formatted format(const Mat& mtx, const char* fmt,
                                               const vector<int>& params=vector<int>())
                {
                    return Formatted(mtx, Formatter::get(fmt), params);
                }
                
                template<typename _Tp> static inline Formatted format(const vector<Point_<_Tp> >& vec,
                                                                      const char* fmt, const vector<int>& params=vector<int>())
                {
                    return Formatted(Mat(vec), Formatter::get(fmt), params);
                }
                
                template<typename _Tp> static inline Formatted format(const vector<Point3_<_Tp> >& vec,
                                                                      const char* fmt, const vector<int>& params=vector<int>())
                {
                    return Formatted(Mat(vec), Formatter::get(fmt), params);
                }
                
                /** \brief prints Mat to the output stream in Matlab notation
                 * use like
                 @verbatim
                 Mat my_mat = Mat::eye(3,3,CV_32F);
                 std::cout << my_mat;
                 @endverbatim
                 */
                static inline std::ostream& operator << (std::ostream& out, const Mat& mtx)
                {
                    Formatter::get()->write(out, mtx);
                    return out;
                }
                
                /** \brief prints Mat to the output stream allows in the specified notation (see format)
                 * use like
                 @verbatim
                 Mat my_mat = Mat::eye(3,3,CV_32F);
                 std::cout << my_mat;
                 @endverbatim
                 */
                static inline std::ostream& operator << (std::ostream& out, const Formatted& fmtd)
                {
                    fmtd.fmt->write(out, fmtd.mtx);
                    return out;
                }
                
                
                template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,
                                                                                const vector<Point_<_Tp> >& vec)
                {
                    Formatter::get()->write(out, Mat(vec));
                    return out;
                }
                
                
                template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,
                                                                                const vector<Point3_<_Tp> >& vec)
                {
                    Formatter::get()->write(out, Mat(vec));
                    return out;
                }
                
                
                /** Writes a Matx to an output stream.
                 */
                template<typename _Tp, int m, int n> inline std::ostream& operator<<(std::ostream& out, const Matx<_Tp, m, n>& matx)
                {
                    out << cv::Mat(matx);
                    return out;
                }
                
                /** Writes a point to an output stream in Matlab notation
                 */
                template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point_<_Tp>& p)
                {
                    out << "[" << p.x << ", " << p.y << "]";
                    return out;
                }
                
                /** Writes a point to an output stream in Matlab notation
                 */
                template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point3_<_Tp>& p)
                {
                    out << "[" << p.x << ", " << p.y << ", " << p.z << "]";
                    return out;
                }
                
                /** Writes a Vec to an output stream. Format example : [10, 20, 30]
                 */
                template<typename _Tp, int n> inline std::ostream& operator<<(std::ostream& out, const Vec<_Tp, n>& vec)
                {
                    out << "[";
                
                    if(Vec<_Tp, n>::depth < CV_32F)
                    {
                        for (int i = 0; i < n - 1; ++i) {
                            out << (int)vec[i] << ", ";
                        }
                        out << (int)vec[n-1] << "]";
                    }
                    else
                    {
                        for (int i = 0; i < n - 1; ++i) {
                            out << vec[i] << ", ";
                        }
                        out << vec[n-1] << "]";
                    }
                
                    return out;
                }
                
                /** Writes a Size_ to an output stream. Format example : [640 x 480]
                 */
                template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Size_<_Tp>& size)
                {
                    out << "[" << size.width << " x " << size.height << "]";
                    return out;
                }
                
                /** Writes a Rect_ to an output stream. Format example : [640 x 480 from (10, 20)]
                 */
                template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Rect_<_Tp>& rect)
                {
                    out << "[" << rect.width << " x " << rect.height << " from (" << rect.x << ", " << rect.y << ")]";
                    return out;
                }
                
                
                template<typename _Tp> inline Ptr<_Tp> Algorithm::create(const string& name)
                {
                    return _create(name).ptr<_Tp>();
                }
                
                template<typename _Tp>
                inline void Algorithm::set(const char* _name, const Ptr<_Tp>& value)
                {
                    Ptr<Algorithm> algo_ptr = value. template ptr<cv::Algorithm>();
                    if (algo_ptr.empty()) {
                        CV_Error( CV_StsUnsupportedFormat, "unknown/unsupported Ptr type of the second parameter of the method Algorithm::set");
                    }
                    info()->set(this, _name, ParamType<Algorithm>::type, &algo_ptr);
                }
                
                template<typename _Tp>
                inline void Algorithm::set(const string& _name, const Ptr<_Tp>& value)
                {
                    this->set<_Tp>(_name.c_str(), value);
                }
                
                template<typename _Tp>
                inline void Algorithm::setAlgorithm(const char* _name, const Ptr<_Tp>& value)
                {
                    Ptr<Algorithm> algo_ptr = value. template ptr<cv::Algorithm>();
                    if (algo_ptr.empty()) {
                        CV_Error( CV_StsUnsupportedFormat, "unknown/unsupported Ptr type of the second parameter of the method Algorithm::set");
                    }
                    info()->set(this, _name, ParamType<Algorithm>::type, &algo_ptr);
                }
                
                template<typename _Tp>
                inline void Algorithm::setAlgorithm(const string& _name, const Ptr<_Tp>& value)
                {
                    this->set<_Tp>(_name.c_str(), value);
                }
                
                template<typename _Tp> inline typename ParamType<_Tp>::member_type Algorithm::get(const string& _name) const
                {
                    typename ParamType<_Tp>::member_type value;
                    info()->get(this, _name.c_str(), ParamType<_Tp>::type, &value);
                    return value;
                }
                
                template<typename _Tp> inline typename ParamType<_Tp>::member_type Algorithm::get(const char* _name) const
                {
                    typename ParamType<_Tp>::member_type value;
                    info()->get(this, _name, ParamType<_Tp>::type, &value);
                    return value;
                }
                
                template<typename _Tp, typename _Base> inline void AlgorithmInfo::addParam(Algorithm& algo, const char* parameter,
                                  Ptr<_Tp>& value, bool readOnly, Ptr<_Tp> (Algorithm::*getter)(), void (Algorithm::*setter)(const Ptr<_Tp>&),
                                  const string& help)
                {
                    //TODO: static assert: _Tp inherits from _Base
                    addParam_(algo, parameter, ParamType<_Base>::type, &value, readOnly,
                              (Algorithm::Getter)getter, (Algorithm::Setter)setter, help);
                }
                
                template<typename _Tp> inline void AlgorithmInfo::addParam(Algorithm& algo, const char* parameter,
                                  Ptr<_Tp>& value, bool readOnly, Ptr<_Tp> (Algorithm::*getter)(), void (Algorithm::*setter)(const Ptr<_Tp>&),
                                  const string& help)
                {
                    //TODO: static assert: _Tp inherits from Algorithm
                    addParam_(algo, parameter, ParamType<Algorithm>::type, &value, readOnly,
                              (Algorithm::Getter)getter, (Algorithm::Setter)setter, help);
                }
                
                }
                
                #ifdef _MSC_VER
                # pragma warning(pop)
                #endif
                
                #endif // __cplusplus
                #endif


Top 10 Lines:

     Line      Count

     1622      14464
     1857       8382
     1621       7689
     1628       7468
     1901       3492
      124       3100
      206       2619
     1137       2619
     2018       2619
     2210       1746

Execution Summary:

       19   Executable lines in this file
       19   Lines executed
   100.00   Percent of the file executed

    59254   Total number of line executions
  3118.63   Average executions per line


*** File /home/ubuntu/fyp/Project2_NT/Project2/Main.cpp:
                #include <opencv2/core/core.hpp>
                #include <opencv2/imgproc/imgproc.hpp>
                #include <opencv2/highgui/highgui.hpp>
                #include <opencv2/video/tracking.hpp>
                #include <iostream>
                #include <stdio.h>
                
                #include "Thresholding.h"
                #include "Insect.h"
                #include "Fps.h"
                //#include "IrCam.h"
                //#include "Kalman.h"
                
                using namespace cv;
                using namespace std;
                
                //#define DEBUG		//display video output windows
                #define FPS //wall breaks (==0) on release mode.
                //#define KALMAN
                #define WAIT_PERIOD	10
                //#define USE_CAM		// On to use IR cam (real-time), off to use recorded footage
                
                
                void drawCross(Mat img, Point centre, Scalar colour, int d)
       ##### -> {
                	line(img, Point(centre.x - d, centre.y - d), Point(centre.x + d, centre.y + d), colour, 2, CV_AA, 0);
                	line(img, Point(centre.x + d, centre.y - d), Point(centre.x - d, centre.y + d), colour, 2, CV_AA, 0);
                }
                
                
                
         844 -> vector<Point2f> findObjects(Mat inputImage) {
                	vector<vector<Point> > contours;
                	vector<Point2f> centres;
                	vector<Vec4i> hierarchy;
                	Mat contourEdges;
                
                	Canny(inputImage, contourEdges, 100, 100 * 2, 3);
                	findContours(contourEdges, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));
                	
                	for (int i = 0; i < contours.size(); i++)
                	{
                		Moments conMom = (moments(contours[i], false));
                		if ((conMom.m00 < 500) && (conMom.m00 > 5)) {
                			centres.push_back(Point2f(conMom.m10 / conMom.m00, conMom.m01 / conMom.m00));
                		}
                	}
                	return centres;
                }
                
                
         873 -> Insect findInsect(Insect insect, Mat* inputImage) {
                	Mat values[3], image_hsl, lum;
                
                	//cvtColor(src, image_hsl, CV_BGR2HLS);		// Convert image to HSL - redundant for IR
                	split(*inputImage, values);						// Split into channels
                	lum = values[0];
                
                	int lumThreshold = findThreshold(lum);		//Perform Dynamic thresholding on the saturation image
                
                	if (lumThreshold < 0) {
                		insect.found = false;
                		return insect;
                	}
                
                	threshold(lum, lum, lumThreshold, 255, 0);
                	insect.updateHeight(lumThreshold);
                
                	vector<Point2f> objectCentres = findObjects(lum);
                
                	if (objectCentres.size() == 0) {
                		insect.found = false;
                		return insect;
                	}
                
                	insect.found = true;
                	insect.updatePosition(objectCentres[0]);
                	return insect;
                }
                
                
                /** @function main */
                int main(int argc, char** argv)
       ##### -> {
                	VideoCapture capture;
                #ifdef USE_CAM
                	if(!irCamInit()) {
                		cout << "\nFailed to connect to camera. Aborting.\n";
                		return -1;
                	}
                #else
                	//EARLY TESTS:
                	//capture.open("C:/Users/myadmin/Documents/_M2D2/Data/Ancient_times/plainHigh1.avi");
                	//capture.open("C:/Users/myadmin/Documents/_M2D2/Data/Tests/MVI_2990.MOV"); //runs at ~6fps
                	//capture.open("C:/Users/myadmin/Documents/_M2D2/Data/Tests/MVI_2987.MOV");
                
                	//IR RREFLEC TESTS:
                	//capture.open("C:/Users/myadmin/Documents/IR footage/retro2_2015-05-09-193310-0000.avi");
                	//capture.open("C:/Users/myadmin/Documents/_M2D2/Data/IR footage/retro2_2015-05-09-193310-0000.avi");
                	//capture.open("C:/Users/myadmin/Documents/_M2D2/Data/IR footage/retro2_2015-05-09-193310-0000_8seconds_only.avi"); 
                	//capture.open("C:/Users/myadmin/Documents/_M2D2/Data/IR footage/retro2_2015-05-09-193310-0000_8seconds_only_Uncompressed_Grayscale.avi");
                	//capture.open("C:/Users/myadmin/Documents/_M2D2/Data/IR footage/retro2_2015-05-09-193006-0000_8bit_uncompressed.avi"); // Princess Beetle and the sparkly dress, Co-Staring Michael
                	//capture.open("C:/Users/myadmin/Documents/_M2D2/Data/IR footage/retro1_2015-05-09-192708-0000.avi"); //persistent bright region on lower portion of frame
                
                	//DEPTH TESTS:
                	//capture.open("C:/Users/myadmin/Documents/_M2D2/Data/IR_footage_depth/realRun2_0.avi");
                
                	// Relative path to small test file
                	//capture.open("../../test.avi");
                	capture.open("../../retro2_2015-05-09-193310-0000.avi");
                
                	//DYLANS folder structure:
                	//capture.open("C:/Users/Dylan/Documents/FYP/data/MVI_2987.MOV");
                #endif
                
                	#ifdef RECORD_SOURCE_W_BOX
                		int frame_width = capture.get(CV_CAP_PROP_FRAME_WIDTH);
                		int frame_height = capture.get(CV_CAP_PROP_FRAME_HEIGHT);
                		int input_fps = capture.get(CV_CAP_PROP_FPS);
                		input_fps = 25;
                		VideoWriter outputVideo("out.avi", CV_FOURCC('M', 'J', 'P', 'G'), input_fps, Size(frame_width, frame_height), true);
                	#endif
                
                	#ifdef KALMAN
                		KalmanFilter KF = kalmanInit();
                		#ifdef DEBUG
                			vector<Point> targetv, kalmanv;
                		#endif //DEBUG
                	#endif    // KALMAN
                
                	#ifdef FPS
                	Fps fps(WAIT_PERIOD, WALL); // set what displays by changing mode to WALL, CPU, or BOTH
                	#endif // FPS
                
                	Mat src, src_ROI;
                	
                
                #ifdef USE_CAM
                	src = irGetImage();
                #else
                	capture >> src;
                #endif
                	
                	Insect insect(&src);
                
                
                
                
                	/********** WHILE LOOP *********/
                
                
                	while (!src.empty()) {
                
                #ifdef RECORD_SOURCE_W_BOX
                		// write output video w/ text
                		outputVideo.write(src_w_text);
                #endif
                
                		src_ROI = src(insect.ROI);
                
                		insect = findInsect(insect, &src_ROI);
                		insect.updateROI(&src);
                
                #ifdef DEBUG
                		Mat srcBox = src.clone();
                		rectangle(srcBox, insect.ROI, Scalar(255, 255, 255), 2, 8, 0);
                		imshow("Source w Box", srcBox);
                		imshow("Frame", src_ROI);
                		//imshow("Luminance", lum);
                		printf("Height Bracket: %i	", insect.heightBracket);
                
                		/// Draw contours
                		Mat contourOutput = Mat::zeros(src_ROI.size(), CV_8UC3);
                		//for (int i = 0; i < objectCentres.size(); i++)
                		//{
                		//	circle(contourOutput, objectCentres[i], 4, Scalar(255, 0, 0), -1, 8, 0);
                		//}
                		//imshow("Contours", contourOutput);
                		printf("Speed: %.1f	", insect.speed);
                		printf("Angle: %.0f", insect.relAngle);
                		Mat insectPosition = src.clone();
                		line(insectPosition, Point(src.cols / 2, src.rows / 2), insect.position, Scalar(255, 0, 0), 3);
                		line(insectPosition, insect.position, insect.position + 5*insect.velocity, Scalar(0, 255, 0), 3);
                		imshow("Insect Position", insectPosition);
                #endif // DEBUG
                
                
                #ifdef KALMAN
                		kalmanProcess(&KF, &insect);	
                	#ifdef DEBUG
                		// Plot Kalman info
                		Point2f stateLoc = kalmanGetStateLoc();
                		Point2f measLoc = kalmanGetMeasLoc();
                
                		// Only run in debug mode to avoid consuming a large amount of memory
                		targetv.push_back(measLoc);
                		kalmanv.push_back(stateLoc);
                		src = Scalar::all(0);
                
                		drawCross(src, stateLoc, Scalar(255, 255, 255), 5);
                		drawCross(src, measLoc, Scalar(0, 0, 255), 5);
                
                		for (int i = 0; i < targetv.size() - 1; i++)
                			line(src, targetv[i], targetv[i + 1], Scalar(255, 255, 0), 1);
                
                		for (int i = 0; i < kalmanv.size() - 1; i++)
                			line(src, kalmanv[i], kalmanv[i + 1], Scalar(0, 155, 255), 1);
                
                		imshow("Frame Kalman", src);
                	#endif //DEBUG
                #endif //KALMAN
                
                #ifdef FPS
                		fps.checkFPS();
                		fps.displayFPS(src, insect.ROI);
                #endif // FPS
                
                #ifdef USE_CAM
                		src = irGetImage();
                #else
                		capture >> src;
                #endif
                		//resize(src, src, Size(), 0.3, 0.3);
                
                		waitKey(WAIT_PERIOD);
                		printf("\n");
                	}
                	cout << "Done\n";
                
                #ifdef USE_CAM
                	irReleaseCam();
                #else
                	capture.release();
                #endif
                
                	return(0);
           2 -> }


Top 10 Lines:

     Line      Count

       52        873
       32        844
      237          2

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

     1719   Total number of line executions
   343.80   Average executions per line


*** File /usr/include/c++/4.8/ext/atomicity.h:
                // Support for atomic operations -*- C++ -*-
                
                // Copyright (C) 2004-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/atomicity.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _GLIBCXX_ATOMICITY_H
                #define _GLIBCXX_ATOMICITY_H	1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <bits/gthr.h>
                #include <bits/atomic_word.h>
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Functions for portable atomic access.
                  // To abstract locking primitives across all thread policies, use:
                  // __exchange_and_add_dispatch
                  // __atomic_add_dispatch
                #ifdef _GLIBCXX_ATOMIC_BUILTINS
                  static inline _Atomic_word 
                  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
       17373 ->   { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
                
                  static inline void
                  __atomic_add(volatile _Atomic_word* __mem, int __val)
                  { __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
                #else
                  _Atomic_word
                  __attribute__ ((__unused__))
                  __exchange_and_add(volatile _Atomic_word*, int) throw ();
                
                  void
                  __attribute__ ((__unused__))
                  __atomic_add(volatile _Atomic_word*, int) throw ();
                #endif
                
                  static inline _Atomic_word
                  __exchange_and_add_single(_Atomic_word* __mem, int __val)
                  {
                    _Atomic_word __result = *__mem;
                    *__mem += __val;
                    return __result;
                  }
                
                  static inline void
                  __atomic_add_single(_Atomic_word* __mem, int __val)
                  { *__mem += __val; }
                
                  static inline _Atomic_word
                  __attribute__ ((__unused__))
                  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
                  {
                #ifdef __GTHREADS
                    if (__gthread_active_p())
                      return __exchange_and_add(__mem, __val);
                    else
                      return __exchange_and_add_single(__mem, __val);
                #else
                    return __exchange_and_add_single(__mem, __val);
                #endif
                  }
                
                  static inline void
                  __attribute__ ((__unused__))
                  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
                  {
                #ifdef __GTHREADS
                    if (__gthread_active_p())
                      __atomic_add(__mem, __val);
                    else
                      __atomic_add_single(__mem, __val);
                #else
                    __atomic_add_single(__mem, __val);
                #endif
                  }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                // Even if the CPU doesn't need a memory barrier, we need to ensure
                // that the compiler doesn't reorder memory accesses across the
                // barriers.
                #ifndef _GLIBCXX_READ_MEM_BARRIER
                #define _GLIBCXX_READ_MEM_BARRIER __asm __volatile ("":::"memory")
                #endif
                #ifndef _GLIBCXX_WRITE_MEM_BARRIER
                #define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile ("":::"memory")
                #endif
                
                #endif 


Top 10 Lines:

     Line      Count

       49      17373

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    17373   Total number of line executions
 17373.00   Average executions per line
