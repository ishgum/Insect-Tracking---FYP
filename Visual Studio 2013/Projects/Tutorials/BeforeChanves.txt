#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>


#include <iostream>
#include <ctype.h>

using namespace cv;
using namespace std;

Mat src; Mat src_gray; Mat src_hls;	Mat dst; Mat detected_edges; Mat morph; Mat cdst;

RNG rng(12345);

int printArea = 0;

int d = 0;
int col = 0;
int space = 0;

int edgeThresh = 1;
int lowThreshold = 80;
int const max_lowThreshold = 100;
int ratio = 3;
int kernel_size = 3;


int morph_elem = 0;
int morph_size = 0;
int morph_operator = 0;
int const max_operator = 4;
int const max_elem = 2;
int const max_kernel_size = 21;

int printVector = 0;

bool endProgram = false;

/// Function header
void filter(int, void*);

void Morphology_Operations(int, void*);

/** @function main */
	int main(int argc, char** argv)
	{
		CvCapture* capture = cvCreateCameraCapture(0);

		while (waitKey(10) < 0) {
			vector<vector<Point> > contours;
			vector<Vec4i> hierarchy;

			src = cvQueryFrame(capture);
			//src = imread("C:/Users/myadmin/Documents/Image/MichaelsTestImages/LineTest12.jpg");

			namedWindow("Source", CV_WINDOW_AUTOSIZE);
			imshow("Source", src);
			/// Create Window

			bilateralFilter(src, dst, 10, 20, 40);
			//adaptiveBilateralFilter(src, dst, Size(5, 5), 10, 20);
			GaussianBlur(dst, dst, Size(5, 5), 0, 0);
			//medianBlur(src, dst, 11);

			Mat values[3];

			// Convert image to gray and blur it
			cvtColor(dst, src_hls, CV_BGR2HLS);
			split(src_hls, values);

			Mat sat = values[2];
			
			imshow("Hue", values[0]);
			imshow("Lightness", values[1]);
			imshow("Sat", values[2]);

			Mat values2[3];
			Mat src_hsv;
			cvtColor(dst, src_hsv, CV_BGR2HSV);
			split(src_hsv, values2);

			//Mat sat = values2[1];

			imshow("Hue2", values2[0]);
			imshow("Sat2", values2[1]);
			imshow("Value2", values2[2]);

			Mat test;
			threshold(values2[1], test, 130, 255, 1);
			//imshow("Test", test);

			

			threshold(sat, sat, 200, 255, 0);
			//adaptiveThreshold(sat, sat, 255, CV_ADAPTIVE_THRESH_MEAN_C, 1, 5, 12);

			namedWindow("Sat", CV_WINDOW_AUTOSIZE);
			//imshow("Sat", sat);


			cvtColor(dst, src_gray, CV_BGR2GRAY);

			//threshold(src_gray, src_gray, 150, 255, 1);

			//namedWindow("Gray", CV_WINDOW_AUTOSIZE);
			//imshow("Gray", src_gray);


			Canny(src_gray, detected_edges, 50, 100, 3);
			imshow("Canny", detected_edges);

			GaussianBlur(detected_edges, detected_edges, Size(61, 61), 0, 0);
			threshold(detected_edges, detected_edges, 1, 255, 0);

			namedWindow("Blurred", CV_WINDOW_AUTOSIZE);
			imshow("Blurred", detected_edges);

			Mat sum = detected_edges & sat;

			namedWindow("Sum", CV_WINDOW_AUTOSIZE);
			imshow("Sum", sum);

			Mat background;

			//GaussianBlur(dst, background, Size(21, 21), 0, 0);
			//medianBlur(dst, background, 21);
			//imshow("Background", background);


			//Morphology_Operations(0, 0);

			//namedWindow("Source", CV_WINDOW_AUTOSIZE);
			//imshow("Source", detected_edges);
			
			cvtColor(detected_edges, cdst, CV_GRAY2BGR);

			//imshow("Colour", cdst);

			findContours(sum, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));


			/// Get the moments
			vector<Moments> mu(contours.size());
			for (int i = 0; i < contours.size(); i++)
			{
				mu[i] = moments(contours[i], false);
			}

			///  Get the mass centers:
			vector<Point2f> mc(contours.size());
			for (int i = 0; i < contours.size(); i++)
			{
				mc[i] = Point2f(mu[i].m10 / mu[i].m00, mu[i].m01 / mu[i].m00);
			}

			
			int j = 0;
			vector<vector<Point> > useContours(contours.size());
			for (int i = 0; i < contours.size(); i++) {
				if ((mu[i].m00 > 1000) && (mu[i].m00 < 20000)) {
					if ((arcLength(contours[i], true) > 500) && (arcLength(contours[i], true) < 10000)) {
						useContours[j++] = vector<Point>(contours[i]);
					}
				}
			}
			

			/// Draw contours
			Mat drawing = Mat::zeros(sum.size(), CV_8UC3);

			for (int i = 0; i < contours.size(); i++)
			{
				/*
				if (printArea < 3) {
					printf("\t Info: Area and Contour Length \n");
					printf(" * Contour[%d] - Area (M_00) = %.2f - Area OpenCV: %.2f - Length: %.2f \n", i, mu[i].m00, contourArea(useContours[i]), arcLength(useContours[i], true));
				}
				*/
				Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
				drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, Point());
			}
			printArea++;

			/// Show in a window
			namedWindow("Contours", CV_WINDOW_AUTOSIZE);
			imshow("Contours", drawing);


			/// Calculate the area with the moments 00 and compare with the result of the OpenCV function
			
			//waitKey(0);
		}
		cvReleaseCapture(&capture);
		return(0);

	}


/** @function thresh_callback */
void filter(int, void*)
{

}

/*
Mat image;
image = imread("C:/Users/myadmin/Documents/Image/TestImageInfraRed.jpg", 1);


Mat gray_image;
cvtColor(image, gray_image, CV_BGR2GRAY);

Mat small_image(image, Range::all(), Range(1, 500));

namedWindow("Pointless", CV_WINDOW_AUTOSIZE);
namedWindow("Gray image", CV_WINDOW_AUTOSIZE);
namedWindow("Small image", CV_WINDOW_AUTOSIZE);


imshow("Pointless", image);
imshow("Gray image", gray_image);
imshow("Small image", small_image);
Z*/


/*

int alpha = 0; // Simple contrast control
int beta = 1;

void contrast(void) {
	namedWindow("Contrast", CV_WINDOW_AUTOSIZE);

	createTrackbar("Alpha:", "Contrast", &alpha, 3);
	createTrackbar("Beta:", "Contrast", &beta, 100);
	/// Load source image and convert it to gray

	Mat src_2 = Mat::zeros(src.size(), src.type());

	for (int y = 0; y < src.rows; y++)
	{
		for (int x = 0; x < src.cols; x++)
		{
			for (int c = 0; c < 3; c++)
			{
				src_2.at<Vec3b>(y, x)[c] =
					saturate_cast<uchar>(alpha*(src.at<Vec3b>(y, x)[c]) + beta);
			}
		}
	}

	imshow("Contrast", src_2);
}
*/


void Morphology_Operations(int, void*)
{
	int morph_size = 1;

	Mat element = getStructuringElement(0, Size(2 * morph_size + 1, 2 * morph_size + 1), Point(morph_size, morph_size));

	/// Apply the specified morphology operation
	morphologyEx(detected_edges, detected_edges, 4, element);

}


/*

void contours(void) {
	findContours(detected_edges, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));


	/// Get the moments
	vector<Moments> mu(contours.size());
	for (int i = 0; i < contours.size(); i++)
	{
		mu[i] = moments(contours[i], false);
	}

	///  Get the mass centers:
	vector<Point2f> mc(contours.size());
	for (int i = 0; i < contours.size(); i++)
	{
		mc[i] = Point2f(mu[i].m10 / mu[i].m00, mu[i].m01 / mu[i].m00);
	}



	/// Draw contours
	Mat drawing = Mat::zeros(detected_edges.size(), CV_8UC3);
	for (int i = 0; i< contours.size(); i++)
	{
		Scalar color = Scalar(255, 0, 0);
		drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, Point());
		circle(drawing, mc[i], 4, color, -1, 8, 0);
	}

	/// Show in a window
	namedWindow("Contours", CV_WINDOW_AUTOSIZE);
	imshow("Contours", drawing);


} */



//Hough Lines


/*
vector<Vec2f> lines; vector<Vec2f> parallel_lines;
HoughLines(detected_edges, lines, 1, CV_PI / 180, 300, 0, 0);

int num_lines = 0;

for (size_t i = 0; i < lines.size(); i++)
{
float rho = lines[i][0], theta = lines[i][1];


for (size_t j = 0; j < lines.size(); j++) {
if (theta == lines[j][1] && i != j) {
Point pt1, pt2;
double a = cos(theta), b = sin(theta);
double x0 = a*rho, y0 = b*rho;
pt1.x = cvRound(x0 + 1000 * (-b));
pt1.y = cvRound(y0 + 1000 * (a));
pt2.x = cvRound(x0 - 1000 * (-b));
pt2.y = cvRound(y0 - 1000 * (a));
line(cdst, pt1, pt2, Scalar(0, 0, 255), 3, CV_AA);
}
}

/*
if (printVector == 0) {
printf(" Rho = %.2f, Theta %.2f \n", rho, theta);
}

}
printVector = 1;

if (waitKey(10) > 0) {
printVector = 0;
printf("\n");
}
*/
//imshow("detected lines", cdst);